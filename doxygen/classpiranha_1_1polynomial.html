<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>piranha: piranha::polynomial&lt; Cf, Key &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepiranha.html">piranha</a></li><li class="navelem"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classpiranha_1_1polynomial-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">piranha::polynomial&lt; Cf, Key &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Polynomial class.  
 <a href="classpiranha_1_1polynomial.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for piranha::polynomial&lt; Cf, Key &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpiranha_1_1polynomial__inherit__graph.png" border="0" usemap="#piranha_1_1polynomial_3_01_cf_00_01_key_01_4_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for piranha::polynomial&lt; Cf, Key &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpiranha_1_1polynomial__coll__graph.png" border="0" usemap="#piranha_1_1polynomial_3_01_cf_00_01_key_01_4_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a60f87ff3c3f9faecd9500d697b8a80c1"><td class="memTemplParams" colspan="2"><a id="a60f87ff3c3f9faecd9500d697b8a80c1"></a>
template&lt;typename Cf2 &gt; </td></tr>
<tr class="memitem:a60f87ff3c3f9faecd9500d697b8a80c1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a60f87ff3c3f9faecd9500d697b8a80c1">rebind</a> = <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf2, Key &gt;</td></tr>
<tr class="memdesc:a60f87ff3c3f9faecd9500d697b8a80c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series rebind alias. <br /></td></tr>
<tr class="separator:a60f87ff3c3f9faecd9500d697b8a80c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10de1584bd47b244c1b17dd9ce85ec3"><td class="memItemLeft" align="right" valign="top"><a id="ad10de1584bd47b244c1b17dd9ce85ec3"></a>
typedef <a class="el" href="classpiranha_1_1term.html">term</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3">term_type</a></td></tr>
<tr class="memdesc:ad10de1584bd47b244c1b17dd9ce85ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for term type. <br /></td></tr>
<tr class="separator:ad10de1584bd47b244c1b17dd9ce85ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06139c15c51191a979417513882cb02c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a> = typename <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">container_type::size_type</a></td></tr>
<tr class="memdesc:a06139c15c51191a979417513882cb02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type.  <a href="#a06139c15c51191a979417513882cb02c">More...</a><br /></td></tr>
<tr class="separator:a06139c15c51191a979417513882cb02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f4fc0e8a9566adbb560680df6d9084"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a> = const_iterator_impl</td></tr>
<tr class="memdesc:a35f4fc0e8a9566adbb560680df6d9084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator.  <a href="#a35f4fc0e8a9566adbb560680df6d9084">More...</a><br /></td></tr>
<tr class="separator:a35f4fc0e8a9566adbb560680df6d9084"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0914f9af9b1ee5c488856270eda31347"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a0914f9af9b1ee5c488856270eda31347">polynomial</a> ()=default</td></tr>
<tr class="memdesc:a0914f9af9b1ee5c488856270eda31347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted default constructor.  <a href="#a0914f9af9b1ee5c488856270eda31347">More...</a><br /></td></tr>
<tr class="separator:a0914f9af9b1ee5c488856270eda31347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837862d19037a8e20cb065f259374ba4"><td class="memItemLeft" align="right" valign="top"><a id="a837862d19037a8e20cb065f259374ba4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a837862d19037a8e20cb065f259374ba4">polynomial</a> (const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;)=default</td></tr>
<tr class="memdesc:a837862d19037a8e20cb065f259374ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor. <br /></td></tr>
<tr class="separator:a837862d19037a8e20cb065f259374ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1184e52cd9d0ab660af0163e2380c02"><td class="memItemLeft" align="right" valign="top"><a id="ac1184e52cd9d0ab660af0163e2380c02"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#ac1184e52cd9d0ab660af0163e2380c02">polynomial</a> (<a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:ac1184e52cd9d0ab660af0163e2380c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move constructor. <br /></td></tr>
<tr class="separator:ac1184e52cd9d0ab660af0163e2380c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba66717c404103b97f68167c4a3b151"><td class="memTemplParams" colspan="2">template&lt;typename Str , str_enabler&lt; Str &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9ba66717c404103b97f68167c4a3b151"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a9ba66717c404103b97f68167c4a3b151">polynomial</a> (Str &amp;&amp;name)</td></tr>
<tr class="memdesc:a9ba66717c404103b97f68167c4a3b151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from symbol name.  <a href="#a9ba66717c404103b97f68167c4a3b151">More...</a><br /></td></tr>
<tr class="separator:a9ba66717c404103b97f68167c4a3b151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a66434ef5da58fb8d72383107880e3e"><td class="memItemLeft" align="right" valign="top"><a id="a7a66434ef5da58fb8d72383107880e3e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a7a66434ef5da58fb8d72383107880e3e">~polynomial</a> ()</td></tr>
<tr class="memdesc:a7a66434ef5da58fb8d72383107880e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial destructor. <br /></td></tr>
<tr class="separator:a7a66434ef5da58fb8d72383107880e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258b31100cdab8aa1bcaa9e000704c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a258b31100cdab8aa1bcaa9e000704c78">operator=</a> (const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;other)=default</td></tr>
<tr class="memdesc:a258b31100cdab8aa1bcaa9e000704c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a258b31100cdab8aa1bcaa9e000704c78">More...</a><br /></td></tr>
<tr class="separator:a258b31100cdab8aa1bcaa9e000704c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b95d091bc0c79624201de1a8685c6b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a3b95d091bc0c79624201de1a8685c6b4">operator=</a> (<a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:a3b95d091bc0c79624201de1a8685c6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a3b95d091bc0c79624201de1a8685c6b4">More...</a><br /></td></tr>
<tr class="separator:a3b95d091bc0c79624201de1a8685c6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d60879cf510ec513ede92bc2c36367"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5d60879cf510ec513ede92bc2c36367"><td class="memTemplItemLeft" align="right" valign="top">pow_ret_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#ac5d60879cf510ec513ede92bc2c36367">pow</a> (const T &amp;x) const</td></tr>
<tr class="memdesc:ac5d60879cf510ec513ede92bc2c36367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override default exponentiation method.  <a href="#ac5d60879cf510ec513ede92bc2c36367">More...</a><br /></td></tr>
<tr class="separator:ac5d60879cf510ec513ede92bc2c36367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1447ac4780d76075517d587661649759"><td class="memTemplParams" colspan="2">template&lt;typename Series  = polynomial&gt; </td></tr>
<tr class="memitem:a1447ac4780d76075517d587661649759"><td class="memTemplItemLeft" align="right" valign="top">inverse_type&lt; Series &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a1447ac4780d76075517d587661649759">invert</a> () const</td></tr>
<tr class="memdesc:a1447ac4780d76075517d587661649759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversion.  <a href="#a1447ac4780d76075517d587661649759">More...</a><br /></td></tr>
<tr class="separator:a1447ac4780d76075517d587661649759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff11306cd945d956dd8edb3c55c068d"><td class="memTemplParams" colspan="2">template&lt;typename T  = polynomial&gt; </td></tr>
<tr class="memitem:aeff11306cd945d956dd8edb3c55c068d"><td class="memTemplItemLeft" align="right" valign="top">integrate_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#aeff11306cd945d956dd8edb3c55c068d">integrate</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:aeff11306cd945d956dd8edb3c55c068d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integration.  <a href="#aeff11306cd945d956dd8edb3c55c068d">More...</a><br /></td></tr>
<tr class="separator:aeff11306cd945d956dd8edb3c55c068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95670ce5893aae7e1e0954287a7026ba"><td class="memTemplParams" colspan="2">template&lt;typename T , find_cf_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a95670ce5893aae7e1e0954287a7026ba"><td class="memTemplItemLeft" align="right" valign="top">Cf&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a95670ce5893aae7e1e0954287a7026ba">find_cf</a> (const T &amp;c) const</td></tr>
<tr class="memdesc:a95670ce5893aae7e1e0954287a7026ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find coefficient.  <a href="#a95670ce5893aae7e1e0954287a7026ba">More...</a><br /></td></tr>
<tr class="separator:a95670ce5893aae7e1e0954287a7026ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd863b2c626c0f80b1260559739171a0"><td class="memTemplParams" colspan="2">template&lt;typename T , find_cf_init_list_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:afd863b2c626c0f80b1260559739171a0"><td class="memTemplItemLeft" align="right" valign="top">Cf&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#afd863b2c626c0f80b1260559739171a0">find_cf</a> (std::initializer_list&lt; T &gt; l) const</td></tr>
<tr class="memdesc:afd863b2c626c0f80b1260559739171a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find coefficient.  <a href="#afd863b2c626c0f80b1260559739171a0">More...</a><br /></td></tr>
<tr class="separator:afd863b2c626c0f80b1260559739171a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6f280141e3414f7369de6133329b5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#abe6f280141e3414f7369de6133329b5c">split</a> () const</td></tr>
<tr class="memdesc:abe6f280141e3414f7369de6133329b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split polynomial.  <a href="#abe6f280141e3414f7369de6133329b5c">More...</a><br /></td></tr>
<tr class="separator:abe6f280141e3414f7369de6133329b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e990b9b3b2d6b2c009fa9ce676dc45"><td class="memTemplParams" colspan="2">template&lt;typename T  = polynomial, join_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a73e990b9b3b2d6b2c009fa9ce676dc45"><td class="memTemplItemLeft" align="right" valign="top">Cf&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a73e990b9b3b2d6b2c009fa9ce676dc45">join</a> () const</td></tr>
<tr class="memdesc:a73e990b9b3b2d6b2c009fa9ce676dc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join polynomial.  <a href="#a73e990b9b3b2d6b2c009fa9ce676dc45">More...</a><br /></td></tr>
<tr class="separator:a73e990b9b3b2d6b2c009fa9ce676dc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7a5bed3df4141581eb77e1a85d7723"><td class="memTemplParams" colspan="2">template&lt;typename T  = polynomial, content_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:aaa7a5bed3df4141581eb77e1a85d7723"><td class="memTemplItemLeft" align="right" valign="top">Cf&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#aaa7a5bed3df4141581eb77e1a85d7723">content</a> () const</td></tr>
<tr class="memdesc:aaa7a5bed3df4141581eb77e1a85d7723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Content.  <a href="#aaa7a5bed3df4141581eb77e1a85d7723">More...</a><br /></td></tr>
<tr class="separator:aaa7a5bed3df4141581eb77e1a85d7723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ed5d8e1fd5c9d0ff66546286b4e1f3"><td class="memTemplParams" colspan="2">template&lt;typename T  = polynomial, pp_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a55ed5d8e1fd5c9d0ff66546286b4e1f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a55ed5d8e1fd5c9d0ff66546286b4e1f3">primitive_part</a> () const</td></tr>
<tr class="memdesc:a55ed5d8e1fd5c9d0ff66546286b4e1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive part.  <a href="#a55ed5d8e1fd5c9d0ff66546286b4e1f3">More...</a><br /></td></tr>
<tr class="separator:a55ed5d8e1fd5c9d0ff66546286b4e1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81e0fd771d7ebeeb97fca4a8656e16d"><td class="memTemplParams" colspan="2">template&lt;typename T  = polynomial&gt; </td></tr>
<tr class="memitem:af81e0fd771d7ebeeb97fca4a8656e16d"><td class="memTemplItemLeft" align="right" valign="top">height_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#af81e0fd771d7ebeeb97fca4a8656e16d">height</a> () const</td></tr>
<tr class="memdesc:af81e0fd771d7ebeeb97fca4a8656e16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Height.  <a href="#af81e0fd771d7ebeeb97fca4a8656e16d">More...</a><br /></td></tr>
<tr class="separator:af81e0fd771d7ebeeb97fca4a8656e16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5735ddbc2dd58808c625cbe652888f8b"><td class="memItemLeft" align="right" valign="top">degree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a5735ddbc2dd58808c625cbe652888f8b">degree</a> () const</td></tr>
<tr class="memdesc:a5735ddbc2dd58808c625cbe652888f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total degree.  <a href="#a5735ddbc2dd58808c625cbe652888f8b">More...</a><br /></td></tr>
<tr class="separator:a5735ddbc2dd58808c625cbe652888f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f206670c33151c3b8c3d715d2dfd4d6"><td class="memItemLeft" align="right" valign="top">pdegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a1f206670c33151c3b8c3d715d2dfd4d6">degree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:a1f206670c33151c3b8c3d715d2dfd4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial degree.  <a href="#a1f206670c33151c3b8c3d715d2dfd4d6">More...</a><br /></td></tr>
<tr class="separator:a1f206670c33151c3b8c3d715d2dfd4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740700e20a5a450958c183d8eef33430"><td class="memItemLeft" align="right" valign="top">ldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a740700e20a5a450958c183d8eef33430">ldegree</a> () const</td></tr>
<tr class="memdesc:a740700e20a5a450958c183d8eef33430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total low degree.  <a href="#a740700e20a5a450958c183d8eef33430">More...</a><br /></td></tr>
<tr class="separator:a740700e20a5a450958c183d8eef33430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b89d255d38827c62014bd47b6cf2cd"><td class="memItemLeft" align="right" valign="top">pldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a86b89d255d38827c62014bd47b6cf2cd">ldegree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:a86b89d255d38827c62014bd47b6cf2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial low degree.  <a href="#a86b89d255d38827c62014bd47b6cf2cd">More...</a><br /></td></tr>
<tr class="separator:a86b89d255d38827c62014bd47b6cf2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105b7fa2770982a071e2452af0fd94f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a105b7fa2770982a071e2452af0fd94f4">truncate_degree</a> (const T &amp;max_degree) const</td></tr>
<tr class="memdesc:a105b7fa2770982a071e2452af0fd94f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total degree truncation.  <a href="#a105b7fa2770982a071e2452af0fd94f4">More...</a><br /></td></tr>
<tr class="separator:a105b7fa2770982a071e2452af0fd94f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac308a9c055ae2d5af5dac621268d3e43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#ac308a9c055ae2d5af5dac621268d3e43">truncate_degree</a> (const T &amp;max_degree, const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:ac308a9c055ae2d5af5dac621268d3e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial degree truncation.  <a href="#ac308a9c055ae2d5af5dac621268d3e43">More...</a><br /></td></tr>
<tr class="separator:ac308a9c055ae2d5af5dac621268d3e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae055ad2a53547134d4bac1759221c871"><td class="memItemLeft" align="right" valign="top">t_degree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#ae055ad2a53547134d4bac1759221c871">t_degree</a> () const</td></tr>
<tr class="memdesc:ae055ad2a53547134d4bac1759221c871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric degree.  <a href="#ae055ad2a53547134d4bac1759221c871">More...</a><br /></td></tr>
<tr class="separator:ae055ad2a53547134d4bac1759221c871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566e79c1366a8219d9128a28dbebed59"><td class="memItemLeft" align="right" valign="top">pt_degree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#a566e79c1366a8219d9128a28dbebed59">t_degree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:a566e79c1366a8219d9128a28dbebed59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric degree.  <a href="#a566e79c1366a8219d9128a28dbebed59">More...</a><br /></td></tr>
<tr class="separator:a566e79c1366a8219d9128a28dbebed59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0018c0b7cfe05ab3ebb7452095efa4"><td class="memItemLeft" align="right" valign="top">t_ldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#a6a0018c0b7cfe05ab3ebb7452095efa4">t_ldegree</a> () const</td></tr>
<tr class="memdesc:a6a0018c0b7cfe05ab3ebb7452095efa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric low degree.  <a href="#a6a0018c0b7cfe05ab3ebb7452095efa4">More...</a><br /></td></tr>
<tr class="separator:a6a0018c0b7cfe05ab3ebb7452095efa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac799485b3eadf858158b0278943913c3"><td class="memItemLeft" align="right" valign="top">pt_ldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#ac799485b3eadf858158b0278943913c3">t_ldegree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:ac799485b3eadf858158b0278943913c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric low degree.  <a href="#ac799485b3eadf858158b0278943913c3">More...</a><br /></td></tr>
<tr class="separator:ac799485b3eadf858158b0278943913c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bc03df227a3a3db5f2c4eb41d871b3"><td class="memItemLeft" align="right" valign="top">t_order_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#ad1bc03df227a3a3db5f2c4eb41d871b3">t_order</a> () const</td></tr>
<tr class="memdesc:ad1bc03df227a3a3db5f2c4eb41d871b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric order.  <a href="#ad1bc03df227a3a3db5f2c4eb41d871b3">More...</a><br /></td></tr>
<tr class="separator:ad1bc03df227a3a3db5f2c4eb41d871b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba924a5f7c4a8131c57d97e030281bcf"><td class="memItemLeft" align="right" valign="top">pt_order_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#aba924a5f7c4a8131c57d97e030281bcf">t_order</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:aba924a5f7c4a8131c57d97e030281bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric order.  <a href="#aba924a5f7c4a8131c57d97e030281bcf">More...</a><br /></td></tr>
<tr class="separator:aba924a5f7c4a8131c57d97e030281bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb13ea6366fc63fb613316784833373b"><td class="memItemLeft" align="right" valign="top">t_lorder_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#adb13ea6366fc63fb613316784833373b">t_lorder</a> () const</td></tr>
<tr class="memdesc:adb13ea6366fc63fb613316784833373b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric low order.  <a href="#adb13ea6366fc63fb613316784833373b">More...</a><br /></td></tr>
<tr class="separator:adb13ea6366fc63fb613316784833373b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f4e0d251557e578c43ae01ccb8640b"><td class="memItemLeft" align="right" valign="top">pt_lorder_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#ae3f4e0d251557e578c43ae01ccb8640b">t_lorder</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:ae3f4e0d251557e578c43ae01ccb8640b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric low order.  <a href="#ae3f4e0d251557e578c43ae01ccb8640b">More...</a><br /></td></tr>
<tr class="separator:ae3f4e0d251557e578c43ae01ccb8640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1b859da8985051abeb1fa01a8dbbd8"><td class="memItemLeft" align="right" valign="top">ipow_subs_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a3b1b859da8985051abeb1fa01a8dbbd8">ipow_subs</a> (const std::string &amp;name, const <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b">integer</a> &amp;n, const T &amp;x) const</td></tr>
<tr class="memdesc:a3b1b859da8985051abeb1fa01a8dbbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#a3b1b859da8985051abeb1fa01a8dbbd8">More...</a><br /></td></tr>
<tr class="separator:a3b1b859da8985051abeb1fa01a8dbbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23d5585f793eeaa6c612eb0cfdcc357"><td class="memItemLeft" align="right" valign="top">ipow_subs_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1ipow__substitutable__series.html#ac23d5585f793eeaa6c612eb0cfdcc357">ipow_subs</a> (const std::string &amp;name, const Int &amp;n, const T &amp;x) const</td></tr>
<tr class="memdesc:ac23d5585f793eeaa6c612eb0cfdcc357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#ac23d5585f793eeaa6c612eb0cfdcc357">More...</a><br /></td></tr>
<tr class="separator:ac23d5585f793eeaa6c612eb0cfdcc357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83de874d3264155ff92521be46dc57f6"><td class="memItemLeft" align="right" valign="top">subs_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1substitutable__series.html#a83de874d3264155ff92521be46dc57f6">subs</a> (const std::string &amp;name, const T &amp;x) const</td></tr>
<tr class="memdesc:a83de874d3264155ff92521be46dc57f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#a83de874d3264155ff92521be46dc57f6">More...</a><br /></td></tr>
<tr class="separator:a83de874d3264155ff92521be46dc57f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c3c5fe0e03df2581ff107412dd1607"><td class="memItemLeft" align="right" valign="top">t_subs_type&lt; T, U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1t__substitutable__series.html#a75c3c5fe0e03df2581ff107412dd1607">t_subs</a> (const std::string &amp;name, const T &amp;c, const U &amp;s) const</td></tr>
<tr class="memdesc:a75c3c5fe0e03df2581ff107412dd1607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric substitution.  <a href="#a75c3c5fe0e03df2581ff107412dd1607">More...</a><br /></td></tr>
<tr class="separator:a75c3c5fe0e03df2581ff107412dd1607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3d2e7f83e5f80f5e7535ab3c74ae54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#afa3d2e7f83e5f80f5e7535ab3c74ae54">size</a> () const</td></tr>
<tr class="memdesc:afa3d2e7f83e5f80f5e7535ab3c74ae54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series size.  <a href="#afa3d2e7f83e5f80f5e7535ab3c74ae54">More...</a><br /></td></tr>
<tr class="separator:afa3d2e7f83e5f80f5e7535ab3c74ae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38eec0bf05c2275b7dfdbeb37f156dd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a38eec0bf05c2275b7dfdbeb37f156dd3">empty</a> () const</td></tr>
<tr class="memdesc:a38eec0bf05c2275b7dfdbeb37f156dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty test.  <a href="#a38eec0bf05c2275b7dfdbeb37f156dd3">More...</a><br /></td></tr>
<tr class="separator:a38eec0bf05c2275b7dfdbeb37f156dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a826064332b8a234c2343d6975d2240"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a0a826064332b8a234c2343d6975d2240">is_single_coefficient</a> () const</td></tr>
<tr class="memdesc:a0a826064332b8a234c2343d6975d2240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for single-coefficient series.  <a href="#a0a826064332b8a234c2343d6975d2240">More...</a><br /></td></tr>
<tr class="separator:a0a826064332b8a234c2343d6975d2240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac049565106ddee1881fedf6481de9458"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458">insert</a> (T &amp;&amp;<a class="el" href="classpiranha_1_1term.html">term</a>)</td></tr>
<tr class="memdesc:ac049565106ddee1881fedf6481de9458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert term.  <a href="#ac049565106ddee1881fedf6481de9458">More...</a><br /></td></tr>
<tr class="separator:ac049565106ddee1881fedf6481de9458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a2d1924707f1dbc3c82284e48bdaf87f1">insert</a> (T &amp;&amp;<a class="el" href="classpiranha_1_1term.html">term</a>)</td></tr>
<tr class="memdesc:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert generic term with <code>Sign = true</code>.  <a href="#a2d1924707f1dbc3c82284e48bdaf87f1">More...</a><br /></td></tr>
<tr class="separator:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70cf84d7727f2ac0a449dddfc48e76c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad70cf84d7727f2ac0a449dddfc48e76c">operator+</a> () const</td></tr>
<tr class="memdesc:ad70cf84d7727f2ac0a449dddfc48e76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity operator.  <a href="#ad70cf84d7727f2ac0a449dddfc48e76c">More...</a><br /></td></tr>
<tr class="separator:ad70cf84d7727f2ac0a449dddfc48e76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60edb0a90a58e4750209fa0bf849a161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a60edb0a90a58e4750209fa0bf849a161">operator-</a> () const</td></tr>
<tr class="memdesc:a60edb0a90a58e4750209fa0bf849a161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation operator.  <a href="#a60edb0a90a58e4750209fa0bf849a161">More...</a><br /></td></tr>
<tr class="separator:a60edb0a90a58e4750209fa0bf849a161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dce8005ee4919ce2f68b508e6292118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118">negate</a> ()</td></tr>
<tr class="memdesc:a3dce8005ee4919ce2f68b508e6292118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate series in-place.  <a href="#a3dce8005ee4919ce2f68b508e6292118">More...</a><br /></td></tr>
<tr class="separator:a3dce8005ee4919ce2f68b508e6292118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0fc5df866edb13f058cc2ebdc741d6"><td class="memItemLeft" align="right" valign="top">partial_type&lt; Series &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#adb0fc5df866edb13f058cc2ebdc741d6">partial</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:adb0fc5df866edb13f058cc2ebdc741d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial derivative.  <a href="#adb0fc5df866edb13f058cc2ebdc741d6">More...</a><br /></td></tr>
<tr class="separator:adb0fc5df866edb13f058cc2ebdc741d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98b21393d8659e1257f79dbca5a759a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a">begin</a> () const</td></tr>
<tr class="memdesc:ad98b21393d8659e1257f79dbca5a759a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator.  <a href="#ad98b21393d8659e1257f79dbca5a759a">More...</a><br /></td></tr>
<tr class="separator:ad98b21393d8659e1257f79dbca5a759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9963bb8ab72b8f7b2ffbd38cf286eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a5c9963bb8ab72b8f7b2ffbd38cf286eb">end</a> () const</td></tr>
<tr class="memdesc:a5c9963bb8ab72b8f7b2ffbd38cf286eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator.  <a href="#a5c9963bb8ab72b8f7b2ffbd38cf286eb">More...</a><br /></td></tr>
<tr class="separator:a5c9963bb8ab72b8f7b2ffbd38cf286eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33216a696a195e177799649af9a6720c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a33216a696a195e177799649af9a6720c">filter</a> (std::function&lt; bool(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt; &amp;)&gt; func) const</td></tr>
<tr class="memdesc:a33216a696a195e177799649af9a6720c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Term filtering.  <a href="#a33216a696a195e177799649af9a6720c">More...</a><br /></td></tr>
<tr class="separator:a33216a696a195e177799649af9a6720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea750c31fed6a17346955d34f119aa74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aea750c31fed6a17346955d34f119aa74">transform</a> (std::function&lt; std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt; &amp;)&gt; func) const</td></tr>
<tr class="memdesc:aea750c31fed6a17346955d34f119aa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Term transformation.  <a href="#aea750c31fed6a17346955d34f119aa74">More...</a><br /></td></tr>
<tr class="separator:aea750c31fed6a17346955d34f119aa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c9ee4d3741bec3a93ec78bf0831f43"><td class="memItemLeft" align="right" valign="top">eval_type&lt; Series, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ae5c9ee4d3741bec3a93ec78bf0831f43">evaluate</a> (const std::unordered_map&lt; std::string, T &gt; &amp;dict) const</td></tr>
<tr class="memdesc:ae5c9ee4d3741bec3a93ec78bf0831f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation.  <a href="#ae5c9ee4d3741bec3a93ec78bf0831f43">More...</a><br /></td></tr>
<tr class="separator:ae5c9ee4d3741bec3a93ec78bf0831f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4d59b09e4496548b895a4c1212545d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#abc4d59b09e4496548b895a4c1212545d">trim</a> () const</td></tr>
<tr class="memdesc:abc4d59b09e4496548b895a4c1212545d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim.  <a href="#abc4d59b09e4496548b895a4c1212545d">More...</a><br /></td></tr>
<tr class="separator:abc4d59b09e4496548b895a4c1212545d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c22ff3703ce20884442a7cb3fbe0bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aa1c22ff3703ce20884442a7cb3fbe0bd">print_tex</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:aa1c22ff3703ce20884442a7cb3fbe0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print in TeX mode.  <a href="#aa1c22ff3703ce20884442a7cb3fbe0bd">More...</a><br /></td></tr>
<tr class="separator:aa1c22ff3703ce20884442a7cb3fbe0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5650572085cb49da6c36ab4f12af12f4"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a5650572085cb49da6c36ab4f12af12f4">hash</a> () const</td></tr>
<tr class="memdesc:a5650572085cb49da6c36ab4f12af12f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash value.  <a href="#a5650572085cb49da6c36ab4f12af12f4">More...</a><br /></td></tr>
<tr class="separator:a5650572085cb49da6c36ab4f12af12f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feab0d5ff5aa889f30caf9e1fb116ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3feab0d5ff5aa889f30caf9e1fb116ce">is_identical</a> (const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;other) const</td></tr>
<tr class="memdesc:a3feab0d5ff5aa889f30caf9e1fb116ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for identical series.  <a href="#a3feab0d5ff5aa889f30caf9e1fb116ce">More...</a><br /></td></tr>
<tr class="separator:a3feab0d5ff5aa889f30caf9e1fb116ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44128f48b629d89fcc0be3659affd0e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a44128f48b629d89fcc0be3659affd0e5">get_symbol_set</a> () const</td></tr>
<tr class="memdesc:a44128f48b629d89fcc0be3659affd0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set getter.  <a href="#a44128f48b629d89fcc0be3659affd0e5">More...</a><br /></td></tr>
<tr class="separator:a44128f48b629d89fcc0be3659affd0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ac3752460cc7a4c4cc0bea3330b31bcc9">set_symbol_set</a> (const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;args)</td></tr>
<tr class="memdesc:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set setter.  <a href="#ac3752460cc7a4c4cc0bea3330b31bcc9">More...</a><br /></td></tr>
<tr class="separator:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafc56eba07220821ab4b7f026105bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aaafc56eba07220821ab4b7f026105bd9">extend_symbol_set</a> (const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;new_ss) const</td></tr>
<tr class="memdesc:aaafc56eba07220821ab4b7f026105bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend symbol set.  <a href="#aaafc56eba07220821ab4b7f026105bd9">More...</a><br /></td></tr>
<tr class="separator:aaafc56eba07220821ab4b7f026105bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Table-querying methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods to query the properties of the internal container used to store the terms. </p>
</div></td></tr>
<tr class="memitem:a9fd2a6b0508e72ba3e3b0012a6eb4cce"><td class="memItemLeft" align="right" valign="top">sparsity_info_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a9fd2a6b0508e72ba3e3b0012a6eb4cce">table_sparsity</a> () const</td></tr>
<tr class="memdesc:a9fd2a6b0508e72ba3e3b0012a6eb4cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table sparsity.  <a href="#a9fd2a6b0508e72ba3e3b0012a6eb4cce">More...</a><br /></td></tr>
<tr class="separator:a9fd2a6b0508e72ba3e3b0012a6eb4cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cb3fb9005133515123a3c0a4d7a28f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a05cb3fb9005133515123a3c0a4d7a28f">table_load_factor</a> () const</td></tr>
<tr class="memdesc:a05cb3fb9005133515123a3c0a4d7a28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table load factor.  <a href="#a05cb3fb9005133515123a3c0a4d7a28f">More...</a><br /></td></tr>
<tr class="separator:a05cb3fb9005133515123a3c0a4d7a28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456359928f9f7134aaf23488d3e47928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a456359928f9f7134aaf23488d3e47928">table_bucket_count</a> () const</td></tr>
<tr class="memdesc:a456359928f9f7134aaf23488d3e47928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table bucket count.  <a href="#a456359928f9f7134aaf23488d3e47928">More...</a><br /></td></tr>
<tr class="separator:a456359928f9f7134aaf23488d3e47928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low-level interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Low-level methods. </p>
</div></td></tr>
<tr class="memitem:a2af49084d17c39794e0b6802bcc1b530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#ac17a849c8ad4558c158a6f04477ab44f">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a2af49084d17c39794e0b6802bcc1b530">_container</a> ()</td></tr>
<tr class="memdesc:a2af49084d17c39794e0b6802bcc1b530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable reference to the container of terms.  <a href="#a2af49084d17c39794e0b6802bcc1b530">More...</a><br /></td></tr>
<tr class="separator:a2af49084d17c39794e0b6802bcc1b530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3d05e9347eecb91b17db09689e32a1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpiranha_1_1series.html#ac17a849c8ad4558c158a6f04477ab44f">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aef3d05e9347eecb91b17db09689e32a1">_container</a> () const</td></tr>
<tr class="memdesc:aef3d05e9347eecb91b17db09689e32a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the container of terms.  <a href="#aef3d05e9347eecb91b17db09689e32a1">More...</a><br /></td></tr>
<tr class="separator:aef3d05e9347eecb91b17db09689e32a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9e0d36ebf9f6415d0fca2b70476f1e02"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T  = polynomial, at_degree_set_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9e0d36ebf9f6415d0fca2b70476f1e02"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a9e0d36ebf9f6415d0fca2b70476f1e02">set_auto_truncate_degree</a> (const U &amp;max_degree)</td></tr>
<tr class="memdesc:a9e0d36ebf9f6415d0fca2b70476f1e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set total-degree-based auto-truncation.  <a href="#a9e0d36ebf9f6415d0fca2b70476f1e02">More...</a><br /></td></tr>
<tr class="separator:a9e0d36ebf9f6415d0fca2b70476f1e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41229241399b211ec2cc929fb7624bc4"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T  = polynomial, at_degree_set_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a41229241399b211ec2cc929fb7624bc4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a41229241399b211ec2cc929fb7624bc4">set_auto_truncate_degree</a> (const U &amp;max_degree, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:a41229241399b211ec2cc929fb7624bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set partial-degree-based auto-truncation.  <a href="#a41229241399b211ec2cc929fb7624bc4">More...</a><br /></td></tr>
<tr class="separator:a41229241399b211ec2cc929fb7624bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea90736f6a57b604347543e9339416d1"><td class="memTemplParams" colspan="2">template&lt;typename T  = polynomial, at_degree_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:aea90736f6a57b604347543e9339416d1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#aea90736f6a57b604347543e9339416d1">unset_auto_truncate_degree</a> ()</td></tr>
<tr class="memdesc:aea90736f6a57b604347543e9339416d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable degree-based auto-truncation.  <a href="#aea90736f6a57b604347543e9339416d1">More...</a><br /></td></tr>
<tr class="separator:aea90736f6a57b604347543e9339416d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1448978bc7f49ee46d3099cd8580dd1a"><td class="memTemplParams" colspan="2">template&lt;typename T  = polynomial, at_degree_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1448978bc7f49ee46d3099cd8580dd1a"><td class="memTemplItemLeft" align="right" valign="top">static std::tuple&lt; int, degree_type&lt; T &gt;, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a1448978bc7f49ee46d3099cd8580dd1a">get_auto_truncate_degree</a> ()</td></tr>
<tr class="memdesc:a1448978bc7f49ee46d3099cd8580dd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the status of the degree-based auto-truncation mechanism.  <a href="#a1448978bc7f49ee46d3099cd8580dd1a">More...</a><br /></td></tr>
<tr class="separator:a1448978bc7f49ee46d3099cd8580dd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1279cde49e13efb7b78a8505a1f7ac"><td class="memTemplParams" colspan="2">template&lt;typename T  = polynomial, poly_div_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:abd1279cde49e13efb7b78a8505a1f7ac"><td class="memTemplItemLeft" align="right" valign="top">static std::pair&lt; <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#abd1279cde49e13efb7b78a8505a1f7ac">udivrem</a> (const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;n, const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;d)</td></tr>
<tr class="memdesc:abd1279cde49e13efb7b78a8505a1f7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Univariate polynomial division with remainder.  <a href="#abd1279cde49e13efb7b78a8505a1f7ac">More...</a><br /></td></tr>
<tr class="separator:abd1279cde49e13efb7b78a8505a1f7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab338ada519285dc179ef3f568d8525bd"><td class="memTemplParams" colspan="2">template&lt;typename T  = polynomial, uprem_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab338ada519285dc179ef3f568d8525bd"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#ab338ada519285dc179ef3f568d8525bd">uprem</a> (const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;n, const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;d)</td></tr>
<tr class="memdesc:ab338ada519285dc179ef3f568d8525bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Univariate pseudo-remainder.  <a href="#ab338ada519285dc179ef3f568d8525bd">More...</a><br /></td></tr>
<tr class="separator:ab338ada519285dc179ef3f568d8525bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8720b75662fd74c3b34dd17174729b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacepiranha.html#a10eca18731adffdf7043d601309e6866">polynomial_gcd_algorithm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a2f8720b75662fd74c3b34dd17174729b">get_default_gcd_algorithm</a> ()</td></tr>
<tr class="memdesc:a2f8720b75662fd74c3b34dd17174729b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default algorithm to be used for GCD computations.  <a href="#a2f8720b75662fd74c3b34dd17174729b">More...</a><br /></td></tr>
<tr class="separator:a2f8720b75662fd74c3b34dd17174729b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28eb727c18825f2303bb4bb9d2131094"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a28eb727c18825f2303bb4bb9d2131094">set_default_gcd_algorithm</a> (<a class="el" href="namespacepiranha.html#a10eca18731adffdf7043d601309e6866">polynomial_gcd_algorithm</a> algo)</td></tr>
<tr class="memdesc:a28eb727c18825f2303bb4bb9d2131094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default algorithm to be used for GCD computations.  <a href="#a28eb727c18825f2303bb4bb9d2131094">More...</a><br /></td></tr>
<tr class="separator:a28eb727c18825f2303bb4bb9d2131094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b830645f745f0a3a872e7e045070d7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a57b830645f745f0a3a872e7e045070d7">reset_default_gcd_algorithm</a> ()</td></tr>
<tr class="memdesc:a57b830645f745f0a3a872e7e045070d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the default algorithm to be used for GCD computations.  <a href="#a57b830645f745f0a3a872e7e045070d7">More...</a><br /></td></tr>
<tr class="separator:a57b830645f745f0a3a872e7e045070d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd3cf150972e0e3fe5a6524466f0f2d"><td class="memTemplParams" colspan="2">template&lt;typename T  = polynomial, gcd_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9dd3cf150972e0e3fe5a6524466f0f2d"><td class="memTemplItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a9dd3cf150972e0e3fe5a6524466f0f2d">gcd</a> (const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;a, const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;b, bool with_cofactors=false, <a class="el" href="namespacepiranha.html#a10eca18731adffdf7043d601309e6866">polynomial_gcd_algorithm</a> algo=<a class="el" href="classpiranha_1_1polynomial.html#a2f8720b75662fd74c3b34dd17174729b">get_default_gcd_algorithm</a>())</td></tr>
<tr class="memdesc:a9dd3cf150972e0e3fe5a6524466f0f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial GCD.  <a href="#a9dd3cf150972e0e3fe5a6524466f0f2d">More...</a><br /></td></tr>
<tr class="separator:a9dd3cf150972e0e3fe5a6524466f0f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21081b40280606724ea27daa12cc70a8"><td class="memTemplParams" colspan="2">template&lt;typename T  = polynomial, um_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a21081b40280606724ea27daa12cc70a8"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a21081b40280606724ea27daa12cc70a8">untruncated_multiplication</a> (const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;p1, const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;p2)</td></tr>
<tr class="memdesc:a21081b40280606724ea27daa12cc70a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Untruncated multiplication.  <a href="#a21081b40280606724ea27daa12cc70a8">More...</a><br /></td></tr>
<tr class="separator:a21081b40280606724ea27daa12cc70a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47978f79b8e7da4572cb459565ce6f5d"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T  = polynomial, tm_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a47978f79b8e7da4572cb459565ce6f5d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a47978f79b8e7da4572cb459565ce6f5d">truncated_multiplication</a> (const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;p1, const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;p2, const U &amp;max_degree)</td></tr>
<tr class="memdesc:a47978f79b8e7da4572cb459565ce6f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncated multiplication (total degree).  <a href="#a47978f79b8e7da4572cb459565ce6f5d">More...</a><br /></td></tr>
<tr class="separator:a47978f79b8e7da4572cb459565ce6f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5fda495bf7488930d5188d57908678"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T  = polynomial, tm_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2e5fda495bf7488930d5188d57908678"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a2e5fda495bf7488930d5188d57908678">truncated_multiplication</a> (const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;p1, const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;p2, const U &amp;max_degree, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:a2e5fda495bf7488930d5188d57908678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncated multiplication (partial degree).  <a href="#a2e5fda495bf7488930d5188d57908678">More...</a><br /></td></tr>
<tr class="separator:a2e5fda495bf7488930d5188d57908678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7da3b838cc92a235785ae4e339a1e97"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ae7da3b838cc92a235785ae4e339a1e97">clear_pow_cache</a> ()</td></tr>
<tr class="memdesc:ae7da3b838cc92a235785ae4e339a1e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the internal cache of natural powers.  <a href="#ae7da3b838cc92a235785ae4e339a1e97">More...</a><br /></td></tr>
<tr class="separator:ae7da3b838cc92a235785ae4e339a1e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e">register_custom_derivative</a> (const std::string &amp;name, F func)</td></tr>
<tr class="memdesc:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register custom partial derivative.  <a href="#a5ee2cef7972c1ed1a410351c9f3e175e">More...</a><br /></td></tr>
<tr class="separator:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041b2099313fa16a9b13d55ce7c0d930"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a041b2099313fa16a9b13d55ce7c0d930">unregister_custom_derivative</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a041b2099313fa16a9b13d55ce7c0d930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister custom partial derivative.  <a href="#a041b2099313fa16a9b13d55ce7c0d930">More...</a><br /></td></tr>
<tr class="separator:a041b2099313fa16a9b13d55ce7c0d930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40680bb3e8f2801b3754f0b03abb0633"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a40680bb3e8f2801b3754f0b03abb0633">unregister_all_custom_derivatives</a> ()</td></tr>
<tr class="memdesc:a40680bb3e8f2801b3754f0b03abb0633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister all custom partial derivatives.  <a href="#a40680bb3e8f2801b3754f0b03abb0633">More...</a><br /></td></tr>
<tr class="separator:a40680bb3e8f2801b3754f0b03abb0633"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ac17a849c8ad4558c158a6f04477ab44f"><td class="memItemLeft" align="right" valign="top"><a id="ac17a849c8ad4558c158a6f04477ab44f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ac17a849c8ad4558c158a6f04477ab44f">container_type</a> = <a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; <a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3">term_type</a>, detail::term_hasher&lt; <a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3">term_type</a> &gt; &gt;</td></tr>
<tr class="memdesc:ac17a849c8ad4558c158a6f04477ab44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for terms. <br /></td></tr>
<tr class="separator:ac17a849c8ad4558c158a6f04477ab44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="memItemLeft" align="right" valign="top"><a id="a4c1d33d3d9ed04b935e3024db2e46f04"></a>
<a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a4c1d33d3d9ed04b935e3024db2e46f04">m_symbol_set</a></td></tr>
<tr class="memdesc:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set. <br /></td></tr>
<tr class="separator:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ac93f383a79c3325197d6a951e9dd5"><td class="memItemLeft" align="right" valign="top"><a id="a68ac93f383a79c3325197d6a951e9dd5"></a>
<a class="el" href="classpiranha_1_1series.html#ac17a849c8ad4558c158a6f04477ab44f">container_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a68ac93f383a79c3325197d6a951e9dd5">m_container</a></td></tr>
<tr class="memdesc:a68ac93f383a79c3325197d6a951e9dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terms container. <br /></td></tr>
<tr class="separator:a68ac93f383a79c3325197d6a951e9dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8ca00ec285197651224f69911772f9b6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , poly_div_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8ca00ec285197651224f69911772f9b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#a8ca00ec285197651224f69911772f9b6">operator/</a> (T &amp;&amp;n, U &amp;&amp;d)</td></tr>
<tr class="memdesc:a8ca00ec285197651224f69911772f9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact polynomial division.  <a href="#a8ca00ec285197651224f69911772f9b6">More...</a><br /></td></tr>
<tr class="separator:a8ca00ec285197651224f69911772f9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5eceec0ae530b242e021142405ed804"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , poly_in_place_div_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae5eceec0ae530b242e021142405ed804"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html#ae5eceec0ae530b242e021142405ed804">operator/=</a> (T &amp;n, U &amp;&amp;d)</td></tr>
<tr class="memdesc:ae5eceec0ae530b242e021142405ed804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact in-place polynomial division.  <a href="#ae5eceec0ae530b242e021142405ed804">More...</a><br /></td></tr>
<tr class="separator:ae5eceec0ae530b242e021142405ed804"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Cf, typename Key&gt;<br />
class piranha::polynomial&lt; Cf, Key &gt;</h3>

<p>Polynomial class. </p>
<p>This class represents multivariate polynomials as collections of multivariate polynomial terms. <code>Cf</code> represents the ring over which the polynomial is defined, while <code>Key</code> represents the monomial type.</p>
<p>Polynomials support an automatic degree-based truncation mechanism, disabled by default, which comes into play during polynomial multiplication. It allows to discard automatically all those terms, generated during series multiplication, whose total or partial degree is greater than a specified limit. This mechanism can be configured via a set of thread-safe static methods, and it is enabled if:</p><ul>
<li>the total and partial degree of the series are represented by the same type <code>D</code>,</li>
<li>all the truncation-related requirements in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satsified,</li>
<li>the type <code>D</code> is equality-comparable, subtractable and the type resulting from the subtraction is still <code>D</code>.</li>
</ul>
<p>This class satisfies the <a class="el" href="classpiranha_1_1is__series.html" title="Type trait to detect series types. ">piranha::is_series</a> and <a class="el" href="classpiranha_1_1is__cf.html" title="Type trait to detect coefficient types. ">piranha::is_cf</a> type traits.</p>
<dl class="section warning"><dt>Warning</dt><dd>The division and GCD operations are known to have poor performance, especially with large operands. Performance will be improved in future versions.</dd></dl>
<h2>Type requirements</h2>
<p><code>Cf</code> must be suitable for use in <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a> as first template argument, <code>Key</code> must be an instance of either <a class="el" href="classpiranha_1_1monomial.html" title="Monomial class. ">piranha::monomial</a> or <a class="el" href="classpiranha_1_1kronecker__monomial.html" title="Kronecker monomial class. ">piranha::kronecker_monomial</a>.</p>
<h2>Exception safety guarantee</h2>
<p>This class provides the same guarantee as the base series type it derives from.</p>
<h2>Move semantics</h2>
<p>Move semantics is equivalent to the move semantics of the base series type it derives from. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l00668">668</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a35f4fc0e8a9566adbb560680df6d9084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f4fc0e8a9566adbb560680df6d9084">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::<a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a> =  const_iterator_impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const iterator. </p>
<p>Iterator type that can be used to iterate over the terms of the series. The object returned upon dereferentiation is an <code>std::pair</code> in which the first element is a copy of the coefficient of the term, the second element a single-term instance of <code>Derived</code> constructed from the term's key and a unitary coefficient.</p>
<p>This iterator is an input iterator which additionally offers the multi-pass guarantee.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a> and <a class="el" href="classpiranha_1_1series.html#a5c9963bb8ab72b8f7b2ffbd38cf286eb" title="End iterator. ">piranha::series::end()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02012">2012</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a06139c15c51191a979417513882cb02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06139c15c51191a979417513882cb02c">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::<a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a> =  typename <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">container_type::size_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size type. </p>
<p>Used to represent the number of terms in the series. Equivalent to <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee" title="Size type. ">piranha::hash_set::size_type</a>. </p>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l01999">1999</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0914f9af9b1ee5c488856270eda31347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0914f9af9b1ee5c488856270eda31347">&#9670;&nbsp;</a></span>polynomial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::<a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defaulted default constructor. </p>
<p>Will construct a polynomial with zero terms. </p>

</div>
</div>
<a id="a9ba66717c404103b97f68167c4a3b151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba66717c404103b97f68167c4a3b151">&#9670;&nbsp;</a></span>polynomial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename Str , str_enabler&lt; Str &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::<a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> </td>
          <td>(</td>
          <td class="paramtype">Str &amp;&amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from symbol name. </p>
<dl class="section note"><dt>Note</dt><dd>This template constructor is enabled only if the decay type of <code>Str</code> is a C or C++ string.</dd></dl>
<p>Will construct a univariate polynomial made of a single term with unitary coefficient and exponent, representing the symbolic variable <code>name</code>. The type of <code>name</code> must be a string type (either C or C++).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the symbolic variable that the polynomial will represent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1symbol__set.html#a13101abf79be11e045539f82be6f120f" title="Add symbol to the set. ">piranha::symbol_set::add()</a>,</li>
<li>the constructor of <a class="el" href="classpiranha_1_1symbol.html" title="Literal symbol class. ">piranha::symbol</a> from string,</li>
<li>the invoked constructor of the coefficient type,</li>
<li>the invoked constructor of the key type,</li>
<li>the constructor of the term type from coefficient and key,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01316">1316</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2af49084d17c39794e0b6802bcc1b530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af49084d17c39794e0b6802bcc1b530">&#9670;&nbsp;</a></span>_container() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#ac17a849c8ad4558c158a6f04477ab44f">container_type</a>&amp; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a mutable reference to the container of terms. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the internal container of terms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02897">2897</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aef3d05e9347eecb91b17db09689e32a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3d05e9347eecb91b17db09689e32a1">&#9670;&nbsp;</a></span>_container() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpiranha_1_1series.html#ac17a849c8ad4558c158a6f04477ab44f">container_type</a>&amp; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to the container of terms. </p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the internal container of terms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02905">2905</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ad98b21393d8659e1257f79dbca5a759a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98b21393d8659e1257f79dbca5a759a">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin iterator. </p>
<p>Return an iterator to the first term of the series. The returned iterator will provide, when dereferenced, an <code>std::pair</code> in which the first element is a copy of the coefficient of the term, whereas the second element is a single-term instance of <code>Derived</code> built from the term's key and a unitary coefficient.</p>
<p>Note that terms are stored unordered in the series, hence it is not defined which particular term will be returned by calling this method. The only guarantee is that the iterator can be used to transverse all the series' terms until <a class="el" href="classpiranha_1_1series.html#a5c9963bb8ab72b8f7b2ffbd38cf286eb" title="End iterator. ">piranha::series::end()</a> is eventually reached.</p>
<p>Calling any non-const method on the series will invalidate the iterators obtained via <a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a> and <a class="el" href="classpiranha_1_1series.html#a5c9963bb8ab72b8f7b2ffbd38cf286eb" title="End iterator. ">piranha::series::end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the first term of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>construction and assignment of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>construction of term, coefficient and key instances. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02522">2522</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ae7da3b838cc92a235785ae4e339a1e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7da3b838cc92a235785ae4e339a1e97">&#9670;&nbsp;</a></span>clear_pow_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::clear_pow_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the internal cache of natural powers. </p>
<p>This method can be used to clear the cache of natural powers of series maintained by <a class="el" href="classpiranha_1_1series.html#aae9f290579db86ff6c8da7ec926a6a4a" title="Exponentiation. ">piranha::series::pow()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by threading primitives. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02389">2389</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aaa7a5bed3df4141581eb77e1a85d7723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7a5bed3df4141581eb77e1a85d7723">&#9670;&nbsp;</a></span>content()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T  = polynomial, content_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Cf <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::content </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Content. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient type satisfies <a class="el" href="classpiranha_1_1has__gcd3.html" title="Detect piranha::math::gcd3(). ">piranha::has_gcd3</a>.</dd></dl>
<p>This method will return the GCD of the polynomial's coefficients. If the polynomial is empty, zero will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the content of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the polynomial constructor from <code>int</code> or by <a class="el" href="namespacepiranha_1_1math.html#aed326292eae1eeef5a46fd472a6e3165" title="Ternary GCD. ">piranha::math::gcd3()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01698">1698</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a5735ddbc2dd58808c625cbe652888f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5735ddbc2dd58808c625cbe652888f8b">&#9670;&nbsp;</a></span>degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">degree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt; &gt; , <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The degree of the series is the maximum degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the total degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="power__series_8hpp_source.html#l00397">397</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a1f206670c33151c3b8c3d715d2dfd4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f206670c33151c3b8c3d715d2dfd4d6">&#9670;&nbsp;</a></span>degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pdegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt; &gt; , <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::degree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The partial degree of the series is the maximum partial degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation of the degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the partial degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="power__series_8hpp_source.html#l00451">451</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a38eec0bf05c2275b7dfdbeb37f156dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38eec0bf05c2275b7dfdbeb37f156dd3">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty test. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classpiranha_1_1series.html#afa3d2e7f83e5f80f5e7535ab3c74ae54" title="Series size. ">size()</a> is nonzero, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02121">2121</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a5c9963bb8ab72b8f7b2ffbd38cf286eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9963bb8ab72b8f7b2ffbd38cf286eb">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End iterator. </p>
<p>Return an iterator one past the last term of the series. See the documentation of <a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a> on how the returned iterator can be used.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the end of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>construction and assignment of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>construction of term, coefficient and key instances. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02541">2541</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ae5c9ee4d3741bec3a93ec78bf0831f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c9ee4d3741bec3a93ec78bf0831f43">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">eval_type&lt;Series, T&gt; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; std::string, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dict</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if:<ul>
<li>both the coefficient and the key types are evaluable,</li>
<li>the evaluated types are suitable for use in <a class="el" href="namespacepiranha_1_1math.html#ad3b85fa643adb089c7980693221a566c" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>,</li>
<li>the return type is constructible from <code>int</code> and it satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</li>
</ul>
</dd></dl>
<p>Series evaluation starts with a zero-initialised instance of the return type, which is determined according to the evaluation types of coefficient and key. The return value accumulates the evaluation of all terms in the series via the product of the evaluations of the coefficient-key pairs in each term. The input dictionary <code>dict</code> specifies with which value each symbolic quantity will be evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>dictionary of that will be used for evaluation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>evaluation of the series according to the evaluation dictionary <code>dict</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>coefficient and key evaluation,</li>
<li>insertion operations on <code>std::unordered_map</code>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#ad3b85fa643adb089c7980693221a566c" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02641">2641</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aaafc56eba07220821ab4b7f026105bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafc56eba07220821ab4b7f026105bd9">&#9670;&nbsp;</a></span>extend_symbol_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::extend_symbol_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;&#160;</td>
          <td class="paramname"><em>new_ss</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend symbol set. </p>
<p>This method will return a series whose symbol set will be <code>new_ss</code> and whose terms will be the terms of <code>this</code> with new keys obtained from calling the existing keys' <code>merge_args()</code> method. That is, the new keys will be compatible with the new extended symbol set <code>new_ss</code>.</p>
<p><code>new_ss</code> must have a size equal to or greater than the size of the current symbol set of <code>this</code>, and all the symbols in the current symbol set must be present in <code>new_ss</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_ss</td><td>the new set of symbols.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>this</code> with <code>new_ss</code> as symbol set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>new_ss</code> is smaller than the current symbol set or if it does not include all the symbols of the current symbol set. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of coefficients, terms and keys,</li>
<li>the key's <code>merge_args()</code> method,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02876">2876</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a33216a696a195e177799649af9a6720c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33216a696a195e177799649af9a6720c">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Term filtering. </p>
<p>This method will apply the functor <code>func</code> to each term in the series, and produce a return series containing all terms in <code>this</code> for which <code>func</code> returns <code>true</code>. Terms are passed to <code>func</code> in the format resulting from dereferencing the iterators obtained via <a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>filtering functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>filtered series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the call operator of <code>func</code>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term, coefficient, key construction. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02565">2565</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a95670ce5893aae7e1e0954287a7026ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95670ce5893aae7e1e0954287a7026ba">&#9670;&nbsp;</a></span>find_cf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T , find_cf_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Cf <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::find_cf </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find coefficient. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if:<ul>
<li><code>T</code> satisfies <a class="el" href="classpiranha_1_1has__begin__end.html" title="Detect the availability of std::begin() and std::end(). ">piranha::has_begin_end</a>,</li>
<li><code>Key</code> can be constructed from the begin/end iterators of <code>c</code> and a <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>.</li>
</ul>
</dd></dl>
<p>This method will first construct a term with zero coefficient and key initialised from the begin/end iterators of <code>c</code> and the symbol set of <code>this</code>, and it will then try to locate the term inside <code>this</code>. If the term is found, its coefficient will be returned. Otherwise, a coefficient initialised from 0 will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container that will be used to construct the <code>Key</code> to be located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coefficient of the term whose <code>Key</code> corresponds to <code>c</code> if such term exists, zero otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>term, coefficient and key construction,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a7f52223f8638f91f56943168353e758a" title="Find element. ">piranha::hash_set::find()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01592">1592</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="afd863b2c626c0f80b1260559739171a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd863b2c626c0f80b1260559739171a0">&#9670;&nbsp;</a></span>find_cf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T , find_cf_init_list_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Cf <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::find_cf </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find coefficient. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <code>Key</code> can be constructed from the begin/end iterators of <code>l</code> and a <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>.</dd></dl>
<p>This method is identical to the other overload with the same name, and it is provided for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>the list that will be used to construct the <code>Key</code> to be located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coefficient of the term whose <code>Key</code> corresponds to <code>l</code> if such term exists, zero otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the other overload. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01612">1612</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a9dd3cf150972e0e3fe5a6524466f0f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd3cf150972e0e3fe5a6524466f0f2d">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T  = polynomial, gcd_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt;<a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&gt; <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::gcd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_cofactors</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepiranha.html#a10eca18731adffdf7043d601309e6866">polynomial_gcd_algorithm</a>&#160;</td>
          <td class="paramname"><em>algo</em> = <code><a class="el" href="classpiranha_1_1polynomial.html#a2f8720b75662fd74c3b34dd17174729b">get_default_gcd_algorithm</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polynomial GCD. </p>
<dl class="section note"><dt>Note</dt><dd>This static method is enabled only if the following conditions apply:<ul>
<li>the coefficient type has <a class="el" href="namespacepiranha_1_1math.html#a1c4d8d79c21d909f852c4678121bcad5" title="GCD. ">math::gcd()</a> and <a class="el" href="namespacepiranha_1_1math.html#aed326292eae1eeef5a46fd472a6e3165" title="Ternary GCD. ">math::gcd3()</a>, it is exponentiable to <code>unsigned</code> yielding the coefficient type, it is multipliable in-place and in binary form, yielding the coefficient type, it has <a class="el" href="namespacepiranha_1_1math.html#af4bcc0cdf1557f8e9db5b719fbeffbc0" title="Exact division. ">math::divexact()</a>, and it is copy-assignable,</li>
<li>the polynomial type has <a class="el" href="classpiranha_1_1polynomial.html#aaa7a5bed3df4141581eb77e1a85d7723" title="Content. ">piranha::polynomial::content()</a> and <a class="el" href="classpiranha_1_1polynomial.html#abd1279cde49e13efb7b78a8505a1f7ac" title="Univariate polynomial division with remainder. ">piranha::polynomial::udivrem()</a>.</li>
</ul>
</dd></dl>
<p>This method will compute the GCD of polynomials <code>a</code> and <code>b</code>. The algorithm that will be employed for the computation is selected by the <code>algo</code> flag. If <code>algo</code> is set to <a class="el" href="namespacepiranha.html#a10eca18731adffdf7043d601309e6866a2bd9c0ed00116be1258e0cc66617d7c8" title="Automatic selection. ">polynomial_gcd_algorithm::automatic</a> the heuristic GCD algorithm will be tried first, followed by the PRS SR algorithm in case of failures. If <code>algo</code> is set to any other value, the selected algorithm will be used. The heuristic GCD algorithm can be used only when the ceofficient type is an instance of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>. The default value for <code>algo</code> is the one returned by <a class="el" href="classpiranha_1_1polynomial.html#a2f8720b75662fd74c3b34dd17174729b" title="Get the default algorithm to be used for GCD computations. ">get_default_gcd_algorithm()</a>.</p>
<p>The <code>with_cofactors</code> flag signals whether the cofactors should be returned together with the GCD or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first argument. </td></tr>
    <tr><td class="paramname">b</td><td>second argument. </td></tr>
    <tr><td class="paramname">with_cofactors</td><td>flag to signal that cofactors must be returned as well. </td></tr>
    <tr><td class="paramname">algo</td><td>the GCD algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple containing the GCD <code>g</code> of <code>a</code> and <code>b</code>, and the cofactors (that is, <code>a / g</code> and <code>b / g</code>), if requested. If the cofactors are not requested, the content of the last two elements of the tuple is unspecified. If both input arguments are zero, the cofactors will be zero as well.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if a negative exponent is encountered in <code>a</code> or <code>b</code>. </td></tr>
    <tr><td class="paramname">std::overflow_error</td><td>in case of (unlikely) integral overflow errors. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>algo</code> is <a class="el" href="namespacepiranha.html#a10eca18731adffdf7043d601309e6866a4163cf922db5cac4b933c8e333ba09ef" title="Heuristic GCD. ">polynomial_gcd_algorithm::heuristic</a> and the execution of the algorithm fails or it the coefficient type is not an instance of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the public interface of <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>, <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>, <a class="el" href="classpiranha_1_1hash__set.html" title="Hash set. ">piranha::hash_set</a>,</li>
<li>construction of keys,</li>
<li>construction, arithmetics and other operations of coefficients and polynomials,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a1c4d8d79c21d909f852c4678121bcad5" title="GCD. ">math::gcd()</a>, <a class="el" href="namespacepiranha_1_1math.html#aed326292eae1eeef5a46fd472a6e3165" title="Ternary GCD. ">math::gcd3()</a>, <a class="el" href="namespacepiranha_1_1math.html#af4bcc0cdf1557f8e9db5b719fbeffbc0" title="Exact division. ">math::divexact()</a>, <a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">math::pow()</a>, <a class="el" href="namespacepiranha_1_1math.html#abd7b607dc1e19d28a2f8bd601e6916c7" title="Substitution. ">math::subs()</a>,</li>
<li><a class="el" href="classpiranha_1_1polynomial.html#abd1279cde49e13efb7b78a8505a1f7ac" title="Univariate polynomial division with remainder. ">piranha::polynomial::udivrem()</a>, <a class="el" href="classpiranha_1_1polynomial.html#aaa7a5bed3df4141581eb77e1a85d7723" title="Content. ">piranha::polynomial::content()</a>,</li>
<li>memory errors in standard containers,</li>
<li>the conversion of <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a> to <code>unsigned</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01972">1972</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a1448978bc7f49ee46d3099cd8580dd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1448978bc7f49ee46d3099cd8580dd1a">&#9670;&nbsp;</a></span>get_auto_truncate_degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T  = polynomial, at_degree_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt;int, degree_type&lt;T&gt;, std::vector&lt;std::string&gt; &gt; <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::get_auto_truncate_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the status of the degree-based auto-truncation mechanism. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> are satisfied.</dd></dl>
<p>This method will return a tuple of three elements describing the status of the degree-based auto-truncation mechanism. The elements of the tuple have the following meaning:</p><ul>
<li>truncation mode (0 if disabled, 1 for total-degree truncation and 2 for partial-degree truncation),</li>
<li>the maximum degree allowed,</li>
<li>the list of names to be considered for partial truncation.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a tuple representing the status of the degree-based auto-truncation mechanism.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by threading primitives or by the involved constructors. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01565">1565</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a2f8720b75662fd74c3b34dd17174729b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8720b75662fd74c3b34dd17174729b">&#9670;&nbsp;</a></span>get_default_gcd_algorithm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacepiranha.html#a10eca18731adffdf7043d601309e6866">polynomial_gcd_algorithm</a> <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::get_default_gcd_algorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default algorithm to be used for GCD computations. </p>
<p>The default value initialised on startup is <a class="el" href="namespacepiranha.html#a10eca18731adffdf7043d601309e6866a2bd9c0ed00116be1258e0cc66617d7c8" title="Automatic selection. ">polynomial_gcd_algorithm::automatic</a>. This method is thread-safe.</p>
<dl class="section return"><dt>Returns</dt><dd>the current default algorithm to be used for GCD computations. </dd></dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01904">1904</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a44128f48b629d89fcc0be3659affd0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44128f48b629d89fcc0be3659affd0e5">&#9670;&nbsp;</a></span>get_symbol_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a>&amp; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::get_symbol_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbol set getter. </p>
<dl class="section return"><dt>Returns</dt><dd>const reference to the <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a> associated to the series. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02837">2837</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a5650572085cb49da6c36ab4f12af12f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5650572085cb49da6c36ab4f12af12f4">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash value. </p>
<p>The hash value for a series is zero if the series is empty, otherwise it is computed by adding the hash values of all terms. This ensures that two identical series in which the terms are stored in different order still produce the same hash value.</p>
<p>Note, however, that the arguments of the series are not considered in the hash value and that, in general, two series that compare equal according to <a class="el" href="classpiranha_1_1series__operators.html#abd1db7fd12e8271bce100f8fbaf95d73" title="Equality operator involving piranha::series. ">operator==()</a> will <b>not</b> have the same hash value (as the equality operator merges the arguments of two series before actually performing the comparison). Instead of <a class="el" href="classpiranha_1_1series__operators.html#abd1db7fd12e8271bce100f8fbaf95d73" title="Equality operator involving piranha::series. ">operator==()</a>, <a class="el" href="classpiranha_1_1series.html#a3feab0d5ff5aa889f30caf9e1fb116ce" title="Check for identical series. ">is_identical()</a> should be used for storing series as keys in associative containers.</p>
<dl class="section return"><dt>Returns</dt><dd>a hash value for the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by computing the hash of a term. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02805">2805</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="af81e0fd771d7ebeeb97fca4a8656e16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81e0fd771d7ebeeb97fca4a8656e16d">&#9670;&nbsp;</a></span>height()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T  = polynomial&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">height_type&lt;T&gt; <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Height. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the following conditions hold:<ul>
<li>the coefficient type supports <a class="el" href="namespacepiranha_1_1math.html#a9fad3b6f8a6178867eeac66f69531397" title="Absolute value. ">piranha::math::abs()</a>, yielding the type <code>height_type&lt;T&gt;</code>,</li>
<li><code>height_type&lt;T&gt;</code> is constructible from <code>int</code>, less-than comparable, move-assignable and copy or move constructible.</li>
</ul>
</dd></dl>
<p>The height of a polynomial is defined as the maximum of the absolute values of the coefficients. If the polynomial is empty, zero will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the height of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the construction, assignment, comparison, and absolute value calculation of <code>height_type&lt;T&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l02046">2046</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="ac049565106ddee1881fedf6481de9458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac049565106ddee1881fedf6481de9458">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert term. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the decay type of <code>T</code> is <a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3" title="Alias for term type. ">piranha::series::term_type</a>.</dd></dl>
<p>This method will insert <code>term</code> into the series using internally <a class="el" href="classpiranha_1_1hash__set.html#a9025fd16a4fc8868c8b835c8614e1171" title="Insert element. ">piranha::hash_set::insert</a>.</p>
<p>The insertion algorithm proceeds as follows:</p><ul>
<li>if the term is not compatible for insertion, an <code>std::invalid_argument</code> exception is thrown;</li>
<li>if the term is ignorable, the method will return without performing any insertion;</li>
<li>if the term is already in the series, then:<ul>
<li>its coefficient is added (if <code>Sign</code> is <code>true</code>) or subtracted (if <code>Sign</code> is <code>false</code>) to the existing term's coefficient;</li>
<li>if, after the addition/subtraction the existing term is ignorable, it will be erased;</li>
</ul>
</li>
<li>else:<ul>
<li>the term is inserted into the term container and, if <code>Sign</code> is <code>false</code>, its coefficient is negated.</li>
</ul>
</li>
</ul>
<p>After any modification to an existing term in the series (e.g., via insertion with negative <code>Sign</code> or via in-place addition or subtraction of existing coefficients), the term will be checked again for compatibility and ignorability, and, in case the term has become incompatible or ignorable, it will be erased from the series.</p>
<p>The exception safety guarantee upon insertion is that the series will be left in an undefined but valid state. Such a guarantee relies on the fact that the addition/subtraction and negation methods of the coefficient type will leave the coefficient in a valid (possibly undefined) state in face of exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>term to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1hash__set.html#a9025fd16a4fc8868c8b835c8614e1171" title="Insert element. ">piranha::hash_set::insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a7f52223f8638f91f56943168353e758a" title="Find element. ">piranha::hash_set::find()</a>,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a42c0ef2f03b797b1f509044a6ec3b80d" title="Erase element. ">piranha::hash_set::erase()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a>, in-place addition/subtraction on coefficient types. </li>
</ul>
</td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>term</code> is incompatible. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02179">2179</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a2d1924707f1dbc3c82284e48bdaf87f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1924707f1dbc3c82284e48bdaf87f1">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert generic term with <code>Sign = true</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the decay type of <code>T</code> is <a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3" title="Alias for term type. ">piranha::series::term_type</a>.</dd></dl>
<p>Convenience wrapper for the generic <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a> method, with <code>Sign</code> set to <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>term to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by generic <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02195">2195</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aeff11306cd945d956dd8edb3c55c068d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff11306cd945d956dd8edb3c55c068d">&#9670;&nbsp;</a></span>integrate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T  = polynomial&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integrate_type&lt;T&gt; <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integration. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the algorithm described below is supported by all the involved types.</dd></dl>
<p>This method will attempt to compute the antiderivative of the polynomial term by term. If the term's coefficient does not depend on the integration variable, the result will be calculated via the integration of the corresponding monomial. Integration with respect to a variable appearing to the power of -1 will fail.</p>
<p>Otherwise, a strategy of integration by parts is attempted, its success depending on the integrability of the coefficient and on the value of the exponent of the integration variable. The integration will fail if the exponent is negative or non-integral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>integration variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the antiderivative of <code>this</code> with respect to <code>name</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the integration procedure fails. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1symbol.html" title="Literal symbol class. ">piranha::symbol</a> construction,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a>, <a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a>, <a class="el" href="namespacepiranha_1_1math.html#ad7f46a0b6a203a29e27aefd1a196edc6" title="Integration. ">piranha::math::integrate()</a>, <a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a> and <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a>,</li>
<li><a class="el" href="classpiranha_1_1symbol__set.html#a13101abf79be11e045539f82be6f120f" title="Add symbol to the set. ">piranha::symbol_set::add()</a>,</li>
<li>term construction,</li>
<li>coefficient construction, assignment and arithmetics,</li>
<li>integration, construction, assignment, differentiation and degree querying methods of the key type,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>series arithmetics. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01429">1429</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a1447ac4780d76075517d587661649759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1447ac4780d76075517d587661649759">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename Series  = polynomial&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inverse_type&lt;Series&gt; <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inversion. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <code><a class="el" href="classpiranha_1_1polynomial.html#ac5d60879cf510ec513ede92bc2c36367" title="Override default exponentiation method. ">piranha::polynomial::pow</a>(-1)</code> is a well-formed expression.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the calling polynomial raised to -1 using <a class="el" href="classpiranha_1_1polynomial.html#ac5d60879cf510ec513ede92bc2c36367" title="Override default exponentiation method. ">piranha::polynomial::pow()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1polynomial.html#ac5d60879cf510ec513ede92bc2c36367" title="Override default exponentiation method. ">piranha::polynomial::pow()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01394">1394</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a3b1b859da8985051abeb1fa01a8dbbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1b859da8985051abeb1fa01a8dbbd8">&#9670;&nbsp;</a></span>ipow_subs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipow_subs_type&lt;T&gt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">piranha::ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt; , <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::ipow_subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b">integer</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient and/or key types support integral power substitution, and if the types involved in the substitution support the necessary arithmetic operations to compute the result.</dd></dl>
<p>This method will return an object resulting from the substitution of the integral power of the symbol called <code>name</code> in <code>this</code> with the generic object <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">n</td><td>integral power of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">x</td><td>object used for the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from:<ul>
<li>the substitution routines for the coefficients and/or keys,</li>
<li>the computation of the return value,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipow__substitutable__series_8hpp_source.html#l00222">222</a> of file <a class="el" href="ipow__substitutable__series_8hpp_source.html">ipow_substitutable_series.hpp</a>.</p>

</div>
</div>
<a id="ac23d5585f793eeaa6c612eb0cfdcc357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23d5585f793eeaa6c612eb0cfdcc357">&#9670;&nbsp;</a></span>ipow_subs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipow_subs_type&lt;T&gt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">piranha::ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt; , <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::ipow_subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the other <a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a3b1b859da8985051abeb1fa01a8dbbd8" title="Substitution. ">ipow_subs()</a> overload is enabled, and <code>Int</code> is a C++ integral type.</dd></dl>
<p>This is a convenience method that will call the other <a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a3b1b859da8985051abeb1fa01a8dbbd8" title="Substitution. ">ipow_subs()</a> overload after converting <code>n</code> to <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">n</td><td>integral power of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">x</td><td>object used for the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from calling the other <a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a3b1b859da8985051abeb1fa01a8dbbd8" title="Substitution. ">ipow_subs()</a> overload, or by constructing a <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a> from a C++ integral type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipow__substitutable__series_8hpp_source.html#l00249">249</a> of file <a class="el" href="ipow__substitutable__series_8hpp_source.html">ipow_substitutable_series.hpp</a>.</p>

</div>
</div>
<a id="a3feab0d5ff5aa889f30caf9e1fb116ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3feab0d5ff5aa889f30caf9e1fb116ce">&#9670;&nbsp;</a></span>is_identical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::is_identical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for identical series. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <code>Derived</code> is equality-comparable.</dd></dl>
<p>This method will return <code>true</code> if the symbol sets of <code>this</code> and <code>other</code> are the same, and <code>other == *this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>argument for the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>this</code> and <code>other</code> are identical, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the comparison operator of <code>Derived</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02829">2829</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a0a826064332b8a234c2343d6975d2240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a826064332b8a234c2343d6975d2240">&#9670;&nbsp;</a></span>is_single_coefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::is_single_coefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for single-coefficient series. </p>
<p>A series is considered to be <em>single-coefficient</em> when it is symbolically equivalent to a coefficient. That is, the series is either empty (in which case it is considered to be equivalent to a coefficient constructed from zero) or consisting of a single term with unitary key (in which case the series is considered equivalent to its only coefficient).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> in case of single-coefficient series, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the <code>is_unitary()</code> method of the key type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02136">2136</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a73e990b9b3b2d6b2c009fa9ce676dc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e990b9b3b2d6b2c009fa9ce676dc45">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T  = polynomial, join_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Cf <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join polynomial. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient type <code>Cf</code> is a polynomial whose key type is <code>Key</code>, and which supports the expression <code>a += b * c</code> where <code>a</code>, <code>b</code> and <code>c</code> are all instances of <code>Cf</code>).</dd></dl>
<p>This method is the opposite of <a class="el" href="classpiranha_1_1polynomial.html#abe6f280141e3414f7369de6133329b5c" title="Split polynomial. ">piranha::polynomial::split()</a>: given a polynomial with polynomial coefficients, it will produce a multivariate polynomial in which the arguments of <code>this</code> and the arguments of the coefficients have been joined.</p>
<dl class="section return"><dt>Returns</dt><dd>the joined counterpart of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1series.html#ac3752460cc7a4c4cc0bea3330b31bcc9" title="Symbol set setter. ">piranha::series::set_symbol_set()</a> and <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>,</li>
<li>term construction,</li>
<li>arithmetic operations on the coefficient type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01670">1670</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a740700e20a5a450958c183d8eef33430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740700e20a5a450958c183d8eef33430">&#9670;&nbsp;</a></span>ldegree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt; &gt; , <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::ldegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The low degree of the series is the minimum low degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the total low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the low degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="power__series_8hpp_source.html#l00423">423</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a86b89d255d38827c62014bd47b6cf2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b89d255d38827c62014bd47b6cf2cd">&#9670;&nbsp;</a></span>ldegree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt; &gt; , <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::ldegree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The partial low degree of the series is the minimum partial low degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation of the low degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the partial low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the low degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="power__series_8hpp_source.html#l00481">481</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a3dce8005ee4919ce2f68b508e6292118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dce8005ee4919ce2f68b508e6292118">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negate series in-place. </p>
<p>This method will call <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">math::negate()</a> on the coefficients of all terms. In case of exceptions, the basic exception safety guarantee is provided.</p>
<p>If any term becomes ignorable or incompatible after negation, it will be erased from the series.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">math::negate()</a> on the coefficient type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02232">2232</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ad70cf84d7727f2ac0a449dddfc48e76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70cf84d7727f2ac0a449dddfc48e76c">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identity operator. </p>
<dl class="section return"><dt>Returns</dt><dd>copy of <code>this</code>, cast to <code>Derived</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02205">2205</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a60edb0a90a58e4750209fa0bf849a161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60edb0a90a58e4750209fa0bf849a161">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negation operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>this</code> on which <a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118" title="Negate series in-place. ">negate()</a> has been called.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118" title="Negate series in-place. ">negate()</a>,</li>
<li>the copy constructor of <code>Derived</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02217">2217</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a258b31100cdab8aa1bcaa9e000704c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258b31100cdab8aa1bcaa9e000704c78">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&amp; <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the assignment operator of the base class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b95d091bc0c79624201de1a8685c6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b95d091bc0c79624201de1a8685c6b4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&amp; <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>. </dd></dl>

</div>
</div>
<a id="adb0fc5df866edb13f058cc2ebdc741d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0fc5df866edb13f058cc2ebdc741d6">&#9670;&nbsp;</a></span>partial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">partial_type&lt;Series&gt; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::partial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient and key are differentiable (i.e., they satisfy the <a class="el" href="classpiranha_1_1is__differentiable.html" title="Type trait for differentiable types. ">piranha::is_differentiable</a> and <a class="el" href="classpiranha_1_1key__is__differentiable.html" title="Type trait to detect differentiable keys. ">piranha::key_is_differentiable</a> type traits), and if the arithmetic operations needed to compute the partial derivative are supported by all the involved types.</dd></dl>
<p>This method will return the partial derivative of <code>this</code> with respect to the variable called <code>name</code>. The method will construct the return value from the output of the differentiation methods of coefficient and key, and via arithmetic and/or term insertion operations.</p>
<p>Note that, contrary to the specialisation of <a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a> for series types, this method will not take into account custom derivatives registered via <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">piranha::series::register_custom_derivative()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the argument with respect to which the derivative will be calculated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial derivative of <code>this</code> with respect to the symbol named <code>name</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the differentiation methods of coefficient and key,</li>
<li>term construction and insertion,</li>
<li>arithmetic operations on the involved types,</li>
<li>construction of the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02423">2423</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ac5d60879cf510ec513ede92bc2c36367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d60879cf510ec513ede92bc2c36367">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pow_ret_type&lt;T&gt; <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override default exponentiation method. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#aae9f290579db86ff6c8da7ec926a6a4a" title="Exponentiation. ">piranha::series::pow()</a> can be called with exponent <code>x</code> and the key type can be raised to the power of <code>x</code> via its exponentiation method.</dd></dl>
<p>This exponentiation override will check if the polynomial consists of a single-term with non-unitary key. In that case, the return polynomial will consist of a single term with coefficient computed via <a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">piranha::math::pow()</a> and key computed via the monomial exponentiation method. Otherwise, the base (i.e., default) exponentiation method will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> to the power of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the <code>is_unitary()</code> and exponentiation methods of the key type,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">piranha::math::pow()</a>,</li>
<li>construction of coefficient, key and term,</li>
<li>the copy assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a> and <a class="el" href="classpiranha_1_1series.html#aae9f290579db86ff6c8da7ec926a6a4a" title="Exponentiation. ">piranha::series::pow()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01367">1367</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a55ed5d8e1fd5c9d0ff66546286b4e1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ed5d8e1fd5c9d0ff66546286b4e1f3">&#9670;&nbsp;</a></span>primitive_part()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T  = polynomial, pp_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::primitive_part </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Primitive part. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if:<ul>
<li>the method <a class="el" href="classpiranha_1_1polynomial.html#aaa7a5bed3df4141581eb77e1a85d7723" title="Content. ">piranha::polynomial::content()</a> is enabled,</li>
<li>the polynomial coefficient supports <a class="el" href="namespacepiranha_1_1math.html#af4bcc0cdf1557f8e9db5b719fbeffbc0" title="Exact division. ">math::divexact()</a>.</li>
</ul>
</dd></dl>
<p>This method will return <code>this</code> divided by its content.</p>
<dl class="section return"><dt>Returns</dt><dd>the primitive part of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1zero__division__error.html" title="Exception for signalling division by zero. ">piranha::zero_division_error</a></td><td>if the content is zero. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the division operation or by <a class="el" href="classpiranha_1_1polynomial.html#aaa7a5bed3df4141581eb77e1a85d7723" title="Content. ">piranha::polynomial::content()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01721">1721</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="aa1c22ff3703ce20884442a7cb3fbe0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c22ff3703ce20884442a7cb3fbe0bd">&#9670;&nbsp;</a></span>print_tex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::print_tex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print in TeX mode. </p>
<p>Print series to stream <code>os</code> in TeX mode. The representation is constructed in the same way as explained in <a class="el" href="classpiranha_1_1series.html#a9f4b6250352b1657f36a0f90e021b6ce" title="Overloaded stream operator for piranha::series. ">piranha::series::operator&lt;&lt;()</a>, but using <a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735" title="Print series coefficient in TeX mode. ">piranha::print_tex_coefficient()</a> and the key's TeX printing method instead of the plain printing functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>target stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735" title="Print series coefficient in TeX mode. ">piranha::print_tex_coefficient()</a>,</li>
<li>the TeX printing method of the key type,</li>
<li>memory allocation errors in standard containers,</li>
<li><a class="el" href="classpiranha_1_1settings__.html#a511786ba228e56986e36b1d2b85c48f7" title="Get max term output. ">piranha::settings::get_max_term_output()</a>,</li>
<li>streaming to <code>os</code> or to instances of <code>std::ostringstream</code>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpiranha_1_1series.html#a9f4b6250352b1657f36a0f90e021b6ce" title="Overloaded stream operator for piranha::series. ">operator&lt;&lt;()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02729">2729</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a5ee2cef7972c1ed1a410351c9f3e175e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee2cef7972c1ed1a410351c9f3e175e">&#9670;&nbsp;</a></span>register_custom_derivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::register_custom_derivative </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register custom partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#adb0fc5df866edb13f058cc2ebdc741d6" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>, and if <code>F</code> is a type that can be used to construct <code>std::function&lt;partial_type(const Derived &amp;)</code>, where <code>partial_type</code> is the type resulting from the partial derivative of <code>Derived</code>.</dd></dl>
<p>Register a copy of a callable <code>func</code> associated to the symbol called <code>name</code> for use by <a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a>. <code>func</code> will be used to compute the partial derivative of instances of type <code>Derived</code> with respect to <code>name</code> in place of the default partial differentiation algorithm.</p>
<p>It is safe to call this method from multiple threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>symbol for which the custom partial derivative function will be registered. </td></tr>
    <tr><td class="paramname">func</td><td>custom partial derivative function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>failure(s) in threading primitives,</li>
<li>lookup and insertion operations on <code>std::unordered_map</code>,</li>
<li>construction and move-assignment of <code>std::function</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02450">2450</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a57b830645f745f0a3a872e7e045070d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b830645f745f0a3a872e7e045070d7">&#9670;&nbsp;</a></span>reset_default_gcd_algorithm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::reset_default_gcd_algorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the default algorithm to be used for GCD computations. </p>
<p>This method will set the default algorithm to be used for GCD computations to <a class="el" href="namespacepiranha.html#a10eca18731adffdf7043d601309e6866a2bd9c0ed00116be1258e0cc66617d7c8" title="Automatic selection. ">polynomial_gcd_algorithm::automatic</a>. This method is thread-safe. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01924">1924</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a9e0d36ebf9f6415d0fca2b70476f1e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0d36ebf9f6415d0fca2b70476f1e02">&#9670;&nbsp;</a></span>set_auto_truncate_degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename T  = polynomial, at_degree_set_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::set_auto_truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set total-degree-based auto-truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> are satisfied and if <code>U</code> can be safely cast to the degree type.</dd></dl>
<p>Setup the degree-based auto-truncation mechanism to truncate according to the total maximum degree. If the new auto truncation settings are different from the currently active ones, the natural power cache defined in <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a> will be cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_degree</td><td>maximum total degree that will be retained during automatic truncation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>threading primitives,</li>
<li><a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>,</li>
<li>the constructor of the degree type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01475">1475</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a41229241399b211ec2cc929fb7624bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41229241399b211ec2cc929fb7624bc4">&#9670;&nbsp;</a></span>set_auto_truncate_degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename T  = polynomial, at_degree_set_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::set_auto_truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set partial-degree-based auto-truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> are satisfied and if <code>U</code> can be safely cast to the degree type.</dd></dl>
<p>Setup the degree-based auto-truncation mechanism to truncate according to the partial degree. If the new auto truncation settings are different from the currently active ones, the natural power cache defined in <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a> will be cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_degree</td><td>maximum partial degree that will be retained during automatic truncation. </td></tr>
    <tr><td class="paramname">names</td><td>names of the variables that will be considered during the computation of the partial degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>threading primitives,</li>
<li><a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>,</li>
<li>the constructor of the degree type,</li>
<li>memory allocation errors in standard containers. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01514">1514</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a28eb727c18825f2303bb4bb9d2131094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28eb727c18825f2303bb4bb9d2131094">&#9670;&nbsp;</a></span>set_default_gcd_algorithm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::set_default_gcd_algorithm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepiranha.html#a10eca18731adffdf7043d601309e6866">polynomial_gcd_algorithm</a>&#160;</td>
          <td class="paramname"><em>algo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the default algorithm to be used for GCD computations. </p>
<p>This method is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo</td><td>the desired default algorithm to be used for GCD computations. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01914">1914</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="ac3752460cc7a4c4cc0bea3330b31bcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3752460cc7a4c4cc0bea3330b31bcc9">&#9670;&nbsp;</a></span>set_symbol_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::set_symbol_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbol set setter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td><a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a> that will be associated to the series.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the series is not empty. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02848">2848</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="afa3d2e7f83e5f80f5e7535ab3c74ae54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3d2e7f83e5f80f5e7535ab3c74ae54">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Series size. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of terms in the series. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02113">2113</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="abe6f280141e3414f7369de6133329b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6f280141e3414f7369de6133329b5c">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt;<a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt;Cf, Key&gt;, Key&gt; <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::split </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split polynomial. </p>
<p>This method will split the first symbolic argument of the polynomial. That is, it will return a univariate representation of <code>this</code> in which the only symbolic argument is the first symbol in the symbol set of <code>this</code>, and the coefficients are multivariate polynomials in the remaining variables.</p>
<dl class="section return"><dt>Returns</dt><dd>a representation of <code>this</code> as a univariate polynomial with multivariate polynomial coefficients.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>this</code> does not have at least 2 symbolic arguments. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the <code><a class="el" href="classpiranha_1_1polynomial.html#abe6f280141e3414f7369de6133329b5c" title="Split polynomial. ">split()</a></code> method of the monomial,</li>
<li>the construction of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac3752460cc7a4c4cc0bea3330b31bcc9" title="Symbol set setter. ">piranha::series::set_symbol_set()</a>,</li>
<li>the construction of terms, coefficients and keys,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01632">1632</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a83de874d3264155ff92521be46dc57f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83de874d3264155ff92521be46dc57f6">&#9670;&nbsp;</a></span>subs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subs_type&lt;T&gt; <a class="el" href="classpiranha_1_1substitutable__series.html">piranha::substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt; , <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient and/or key types support substitution, and if the types involved in the substitution support the necessary arithmetic operations to compute the result. Also, the return type must satisfy piranha::is_constructible.</dd></dl>
<p>This method will return an object resulting from the substitution of the symbol called <code>name</code> in <code>this</code> with the generic object <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">x</td><td>object used for the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from:<ul>
<li>the substitution routines for the coefficients and/or keys,</li>
<li>the computation of the return value,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="substitutable__series_8hpp_source.html#l00220">220</a> of file <a class="el" href="substitutable__series_8hpp_source.html">substitutable_series.hpp</a>.</p>

</div>
</div>
<a id="ae055ad2a53547134d4bac1759221c871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae055ad2a53547134d4bac1759221c871">&#9670;&nbsp;</a></span>t_degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_degree_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;  &gt;::t_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the degree of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00216">216</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="a566e79c1366a8219d9128a28dbebed59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566e79c1366a8219d9128a28dbebed59">&#9670;&nbsp;</a></span>t_degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pt_degree_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;  &gt;::t_degree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the degree of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00238">238</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="a6a0018c0b7cfe05ab3ebb7452095efa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0018c0b7cfe05ab3ebb7452095efa4">&#9670;&nbsp;</a></span>t_ldegree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_ldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;  &gt;::t_ldegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the degree of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00260">260</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="ac799485b3eadf858158b0278943913c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac799485b3eadf858158b0278943913c3">&#9670;&nbsp;</a></span>t_ldegree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pt_ldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;  &gt;::t_ldegree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the degree of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00282">282</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="adb13ea6366fc63fb613316784833373b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb13ea6366fc63fb613316784833373b">&#9670;&nbsp;</a></span>t_lorder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_lorder_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;  &gt;::t_lorder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric low order. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric low order of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the order of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00349">349</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="ae3f4e0d251557e578c43ae01ccb8640b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f4e0d251557e578c43ae01ccb8640b">&#9670;&nbsp;</a></span>t_lorder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pt_lorder_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;  &gt;::t_lorder </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric low order. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric low order of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the order of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00371">371</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="ad1bc03df227a3a3db5f2c4eb41d871b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bc03df227a3a3db5f2c4eb41d871b3">&#9670;&nbsp;</a></span>t_order() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_order_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;  &gt;::t_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric order. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric order of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the order of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00305">305</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="aba924a5f7c4a8131c57d97e030281bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba924a5f7c4a8131c57d97e030281bcf">&#9670;&nbsp;</a></span>t_order() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pt_order_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;  &gt;::t_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric order. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric order of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the order of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00327">327</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="a75c3c5fe0e03df2581ff107412dd1607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c3c5fe0e03df2581ff107412dd1607">&#9670;&nbsp;</a></span>t_subs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_subs_type&lt;T, U&gt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">piranha::t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt; , <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::t_subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requirements outlined in <a class="el" href="classpiranha_1_1t__substitutable__series.html" title="Toolbox for series that support trigonometric substitution. ">piranha::t_substitutable_series</a> are satisfied.</dd></dl>
<p>Trigonometric substitution is the substitution of the cosine and sine of <code>name</code> for <code>c</code> and <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the symbol that will be subject to substitution. </td></tr>
    <tr><td class="paramname">c</td><td>cosine of <code>name</code>. </td></tr>
    <tr><td class="paramname">s</td><td>sine of <code>name</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the trigonometric substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from:<ul>
<li>construction of the return type,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term construction,</li>
<li>arithmetics on the intermediary values needed to compute the return value,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>,</li>
<li>the substitution methods of coefficient and key. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="t__substitutable__series_8hpp_source.html#l00218">218</a> of file <a class="el" href="t__substitutable__series_8hpp_source.html">t_substitutable_series.hpp</a>.</p>

</div>
</div>
<a id="a456359928f9f7134aaf23488d3e47928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456359928f9f7134aaf23488d3e47928">&#9670;&nbsp;</a></span>table_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::table_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table bucket count. </p>
<dl class="section return"><dt>Returns</dt><dd>the bucket count of the internal container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02281">2281</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a05cb3fb9005133515123a3c0a4d7a28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cb3fb9005133515123a3c0a4d7a28f">&#9670;&nbsp;</a></span>table_load_factor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::table_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table load factor. </p>
<p>Will call <a class="el" href="classpiranha_1_1hash__set.html#a669a2807083e38a90b3a0fc0ef467e3f" title="Load factor. ">piranha::hash_set::load_factor()</a> on the internal terms container and return the result.</p>
<dl class="section return"><dt>Returns</dt><dd>the load factor of the internal container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02273">2273</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a9fd2a6b0508e72ba3e3b0012a6eb4cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd2a6b0508e72ba3e3b0012a6eb4cce">&#9670;&nbsp;</a></span>table_sparsity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparsity_info_type <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::table_sparsity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table sparsity. </p>
<p>Will call <a class="el" href="classpiranha_1_1hash__set.html#a525256d52ac552b9a81e9978654f1d36" title="Get information on the sparsity of the set. ">piranha::hash_set::evaluate_sparsity()</a> on the internal terms container and return the result.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classpiranha_1_1hash__set.html#a525256d52ac552b9a81e9978654f1d36" title="Get information on the sparsity of the set. ">piranha::hash_set::evaluate_sparsity()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1hash__set.html#a525256d52ac552b9a81e9978654f1d36" title="Get information on the sparsity of the set. ">piranha::hash_set::evaluate_sparsity()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02262">2262</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aea750c31fed6a17346955d34f119aa74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea750c31fed6a17346955d34f119aa74">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Term transformation. </p>
<p>This method will apply the functor <code>func</code> to each term in the series, and will use the return value of the functor to construct a new series. Terms are passed to <code>func</code> in the same format resulting from dereferencing the iterators obtained via <a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a>, and <code>func</code> is expected to produce a return value of the same type.</p>
<p>The return series is first initialised as an empty series. For each input term <code>t</code>, the return value of <code>func</code> is used to construct a new temporary series from the multiplication of <code>t.first</code> and <code>t.second</code>. Each temporary series is then added to the return value series.</p>
<p>This method requires the coefficient type to be multipliable by <code>Derived</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>transforming functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformed series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the call operator of <code>func</code>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term, coefficient, key construction,</li>
<li>series multiplication and addition. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02603">2603</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="abc4d59b09e4496548b895a4c1212545d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4d59b09e4496548b895a4c1212545d">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim. </p>
<p>This method will return a series mathematically equivalent to <code>this</code> in which discardable arguments have been removed from the internal set of symbols. Which symbols are removed depends on the trimming method <code>trim_identify()</code> of the key type (e.g., in a polynomial a symbol can be discarded if its exponent is zero in all monomials).</p>
<p>If the coefficient type is an instance of <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>, <a class="el" href="classpiranha_1_1series.html#abc4d59b09e4496548b895a4c1212545d" title="Trim. ">trim()</a> will be called recursively on the coefficients while building the return value.</p>
<dl class="section return"><dt>Returns</dt><dd>trimmed version of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>operations on <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>the trimming methods of coefficient and/or key,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>term, coefficient and key type construction. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02695">2695</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a105b7fa2770982a071e2452af0fd94f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105b7fa2770982a071e2452af0fd94f4">&#9670;&nbsp;</a></span>truncate_degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt; &gt; , <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total degree truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>This method can be used to eliminate the parts of a series whose degree is greater than <code>max_degree</code>. This includes the elimination of whole terms, but also the recursive truncation of coefficients via the <a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a> function, if supported by the coefficient. It must be noted that, in general, this method is not guaranteed to eliminate all the parts whose degree is greater than <code>max_degree</code> (in particular, in the current implementation there is no truncation implemented for keys - a key is kept as-is or completely eliminated).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_degree</td><td>maximum allowed total degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a>, if used,</li>
<li>the constructor of the term type,</li>
<li>the computation and comparison of degree types,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="power__series_8hpp_source.html#l00516">516</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="ac308a9c055ae2d5af5dac621268d3e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac308a9c055ae2d5af5dac621268d3e43">&#9670;&nbsp;</a></span>truncate_degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &gt; &gt; , <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial degree truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>This method is equivalent to the other overload, the only difference being that the partial degree is considered in the computation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_degree</td><td>maximum allowed partial degree. </td></tr>
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation of the partial degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a>, if used,</li>
<li>the constructor of the term type,</li>
<li>the computation and comparison of degree types,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="power__series_8hpp_source.html#l00549">549</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a47978f79b8e7da4572cb459565ce6f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47978f79b8e7da4572cb459565ce6f5d">&#9670;&nbsp;</a></span>truncated_multiplication() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename T  = polynomial, tm_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::truncated_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncated multiplication (total degree). </p>
<dl class="section note"><dt>Note</dt><dd>This function template is enabled only if the following conditions hold:<ul>
<li>the calling <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> satisfies <a class="el" href="classpiranha_1_1is__multipliable.html" title="Multipliable type trait. ">piranha::is_multipliable</a>, returning the calling <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> as return type,</li>
<li>the requirements for truncated multiplication outlined in <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> are satisfied,</li>
<li><code>U</code> can be safely cast to the degree type of the calling <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a>.</li>
</ul>
</dd></dl>
<p>This function will return the product of <code>p1</code> and <code>p2</code>, truncated to the maximum total degree of <code>max_degree</code> (regardless of the current automatic truncation settings). Note that this function is available only if the operands are of the same type and no type promotions affect the coefficient types during multiplication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>the first operand. </td></tr>
    <tr><td class="paramname">p2</td><td>the second operand. </td></tr>
    <tr><td class="paramname">max_degree</td><td>the maximum total degree in the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated product of <code>p1</code> and <code>p2</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the public interface of the specialisation of <a class="el" href="classpiranha_1_1series__multiplier.html" title="Series multiplier. ">piranha::series_multiplier</a> for <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a>,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>,</li>
<li><a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l02114">2114</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a2e5fda495bf7488930d5188d57908678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5fda495bf7488930d5188d57908678">&#9670;&nbsp;</a></span>truncated_multiplication() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename T  = polynomial, tm_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::truncated_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncated multiplication (partial degree). </p>
<dl class="section note"><dt>Note</dt><dd>This function template is enabled only if the following conditions hold:<ul>
<li>the calling <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> satisfies <a class="el" href="classpiranha_1_1is__multipliable.html" title="Multipliable type trait. ">piranha::is_multipliable</a>, returning the calling <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> as return type,</li>
<li>the requirements for truncated multiplication outlined in <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> are satisfied,</li>
<li><code>U</code> can be safely cast to the degree type of the calling <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a>.</li>
</ul>
</dd></dl>
<p>This function will return the product of <code>p1</code> and <code>p2</code>, truncated to the maximum partial degree of <code>max_degree</code> (regardless of the current automatic truncation settings). Note that this function is available only if the operands are of the same type and no type promotions affect the coefficient types during multiplication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>the first operand. </td></tr>
    <tr><td class="paramname">p2</td><td>the second operand. </td></tr>
    <tr><td class="paramname">max_degree</td><td>the maximum total degree in the result. </td></tr>
    <tr><td class="paramname">names</td><td>names of the variables that will be considered in the computation of the degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated product of <code>p1</code> and <code>p2</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the public interface of the specialisation of <a class="el" href="classpiranha_1_1series__multiplier.html" title="Series multiplier. ">piranha::series_multiplier</a> for <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a>,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>,</li>
<li><a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l02152">2152</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="abd1279cde49e13efb7b78a8505a1f7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1279cde49e13efb7b78a8505a1f7ac">&#9670;&nbsp;</a></span>udivrem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T  = polynomial, poly_div_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;<a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&gt; <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::udivrem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Univariate polynomial division with remainder. </p>
<dl class="section note"><dt>Note</dt><dd>This static method is enabled only if:<ul>
<li>the polynomial coefficient type <code>Cf</code> is multipliable yielding the same type <code>Cf</code>, it is multipliable in-place and divisible exactly, and it has exact ring operations,</li>
<li>the polynomial type is subtractable in-place,</li>
<li>the exponent type of the monomial is a C++ integral type or an instance of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>.</li>
</ul>
</dd></dl>
<p>This method will return a pair representing the quotient and the remainder of the division of the univariate polynomials <code>n</code> and <code>d</code>. The input polynomials must be univariate in the same variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the numerator. </td></tr>
    <tr><td class="paramname">d</td><td>the denominator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quotient and remainder of the division of <code>n</code> by <code>d</code>, represented as a standard pair.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if:<ul>
<li>the input polynomials are not univariate or univariate in different variables, or</li>
<li>the low degree of the input polynomials is less than zero. </li>
</ul>
</td></tr>
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1zero__division__error.html" title="Exception for signalling division by zero. ">piranha::zero_division_error</a></td><td>if <code>d</code> is empty. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the public interface of <a class="el" href="classpiranha_1_1hash__set.html" title="Hash set. ">piranha::hash_set</a> and <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>,</li>
<li>the monomial multiplication and division methods,</li>
<li>arithmetic operations on the coefficients and on polynomials,</li>
<li>construction of coefficients, monomials, terms and polynomials. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01761">1761</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a40680bb3e8f2801b3754f0b03abb0633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40680bb3e8f2801b3754f0b03abb0633">&#9670;&nbsp;</a></span>unregister_all_custom_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::unregister_all_custom_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister all custom partial derivatives. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#adb0fc5df866edb13f058cc2ebdc741d6" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>.</dd></dl>
<p>Will unregister all custom derivatives currently registered via <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">register_custom_derivative()</a>. It is safe to call this method from multiple threads.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by failure(s) in threading primitives. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02496">2496</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a041b2099313fa16a9b13d55ce7c0d930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041b2099313fa16a9b13d55ce7c0d930">&#9670;&nbsp;</a></span>unregister_custom_derivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt;  &gt;::unregister_custom_derivative </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister custom partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#adb0fc5df866edb13f058cc2ebdc741d6" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>.</dd></dl>
<p>Unregister the custom partial derivative function associated to the symbol called <code>name</code>. If no custom partial derivative was previously registered using <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">register_custom_derivative()</a>, calling this function will be a no-op.</p>
<p>It is safe to call this method from multiple threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>symbol for which the custom partial derivative function will be unregistered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>failure(s) in threading primitives,</li>
<li>lookup and erase operations on <code>std::unordered_map</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02477">2477</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aea90736f6a57b604347543e9339416d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea90736f6a57b604347543e9339416d1">&#9670;&nbsp;</a></span>unset_auto_truncate_degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T  = polynomial, at_degree_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::unset_auto_truncate_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable degree-based auto-truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> are satisfied.</dd></dl>
<p>Disable the degree-based auto-truncation mechanism.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>threading primitives,</li>
<li>the constructor of the degree type,</li>
<li>memory allocation errors in standard containers. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01539">1539</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a21081b40280606724ea27daa12cc70a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21081b40280606724ea27daa12cc70a8">&#9670;&nbsp;</a></span>untruncated_multiplication()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T  = polynomial, um_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::untruncated_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Untruncated multiplication. </p>
<dl class="section note"><dt>Note</dt><dd>This function template is enabled only if the calling <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> satisfies <a class="el" href="classpiranha_1_1is__multipliable.html" title="Multipliable type trait. ">piranha::is_multipliable</a>, returning the calling <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> as return type.</dd></dl>
<p>This function will return the product of <code>p1</code> and <code>p2</code>, computed without truncation (regardless of the current automatic truncation settings). Note that this function is available only if the operands are of the same type and no type promotions affect the coefficient types during multiplication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>the first operand. </td></tr>
    <tr><td class="paramname">p2</td><td>the second operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of <code>p1</code> and <code>p2</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the public interface of the specialisation of <a class="el" href="classpiranha_1_1series__multiplier.html" title="Series multiplier. ">piranha::series_multiplier</a> for <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a>,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l02079">2079</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="ab338ada519285dc179ef3f568d8525bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab338ada519285dc179ef3f568d8525bd">&#9670;&nbsp;</a></span>uprem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T  = polynomial, uprem_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> <a class="el" href="classpiranha_1_1polynomial.html">piranha::polynomial</a>&lt; Cf, Key &gt;::uprem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Univariate pseudo-remainder. </p>
<dl class="section note"><dt>Note</dt><dd>This static method is enabled only if polynomial division is enabled, and the polynomial coefficient type is exponentiable to <code>unsigned</code>, yielding the coefficient type as a result.</dd></dl>
<p>The pseudo-remainder is defined as: </p><p class="formulaDsp">
\[ \mathrm{rem}\left(\mathrm{lc}\left( d \right)^{a-b+1} n,d \right), \]
</p>
<p> where \(\mathrm{lc}\) denotes the leading coefficient (that is, the coefficient of the term with the highest univariate degree), and \(a\) and \(b\) are the degrees of <code>n</code> and <code>d</code> respectively.</p>
<p>This method works only on univariate polyomials in the same variable and it requires the univariate degree of <code>n</code> to be not less than the univariate degree of <code>d</code>. If <code>n</code> is zero, an empty polynomial will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the numerator. </td></tr>
    <tr><td class="paramname">d</td><td>the denominator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pseudo-remainder of <code>n / d</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the polynomials are not univariate in the same variable, or if the univariate degree of <code>d</code> is greater than the univariate degree of <code>n</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1zero__division__error.html" title="Exception for signalling division by zero. ">piranha::zero_division_error</a></td><td>if <code>d</code> is zero. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1polynomial.html#abd1279cde49e13efb7b78a8505a1f7ac" title="Univariate polynomial division with remainder. ">piranha::polynomial::udivrem()</a>,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series()</a>,</li>
<li>copy construction of polynomials,</li>
<li>exponentiation and multiplication of coefficients,</li>
<li>the conversion of <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a> to <code>unsigned</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01798">1798</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a8ca00ec285197651224f69911772f9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca00ec285197651224f69911772f9b6">&#9670;&nbsp;</a></span>operator/</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , poly_div_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exact polynomial division. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is enabled only if the decay types of <code>T</code> and <code>U</code> are the same type <code>Td</code> and <a class="el" href="classpiranha_1_1polynomial.html#abd1279cde49e13efb7b78a8505a1f7ac" title="Univariate polynomial division with remainder. ">polynomial::udivrem()</a> is enabled for <code>Td</code>.</dd></dl>
<p>This operator will compute the exact result of <code>n / d</code>. If <code>d</code> does not divide <code>n</code> exactly, an error will be produced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the numerator. </td></tr>
    <tr><td class="paramname">d</td><td>the denominator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quotient <code>n / d</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1zero__division__error.html" title="Exception for signalling division by zero. ">piranha::zero_division_error</a></td><td>if <code>d</code> is zero. </td></tr>
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1math_1_1inexact__division.html" title="Exception to signal an inexact division. ">piranha::math::inexact_division</a></td><td>if the division is not exact. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if a negative exponent is encountered. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1polynomial.html#abd1279cde49e13efb7b78a8505a1f7ac" title="Univariate polynomial division with remainder. ">piranha::polynomial::udivrem()</a>,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1hash__set.html" title="Hash set. ">piranha::hash_set</a>, <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>, <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>the monomial's <code>extract_exponents()</code> methods,</li>
<li>construction of coefficients, monomials, terms and polynomials,</li>
<li>arithmetic operations on the coefficients and on polynomials,</li>
<li>memory errors in standard containers,</li>
<li>conversion of <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a> to C++ integral types,</li>
<li><a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01856">1856</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="ae5eceec0ae530b242e021142405ed804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5eceec0ae530b242e021142405ed804">&#9670;&nbsp;</a></span>operator/=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , poly_in_place_div_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a>&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exact in-place polynomial division. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is enabled only if <a class="el" href="classpiranha_1_1polynomial.html#a8ca00ec285197651224f69911772f9b6" title="Exact polynomial division. ">operator/()</a> is enabled for the input types and <code>T</code> is not const.</dd></dl>
<p>This operator is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> n = n / d;</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the numerator. </td></tr>
    <tr><td class="paramname">d</td><td>the denominator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>n</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the binary operator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01893">1893</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
