<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>piranha: piranha::poisson_series&lt; Cf &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepiranha.html">piranha</a></li><li class="navelem"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpiranha_1_1poisson__series-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">piranha::poisson_series&lt; Cf &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Poisson series class.  
 <a href="classpiranha_1_1poisson__series.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="poisson__series_8hpp_source.html">poisson_series.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for piranha::poisson_series&lt; Cf &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpiranha_1_1poisson__series__inherit__graph.png" border="0" usemap="#piranha_1_1poisson__series_3_01_cf_01_4_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for piranha::poisson_series&lt; Cf &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpiranha_1_1poisson__series__coll__graph.png" border="0" usemap="#piranha_1_1poisson__series_3_01_cf_01_4_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abace7da8a87c85cd5fcab30bfc6b4aa3"><td class="memTemplParams" colspan="2"><a id="abace7da8a87c85cd5fcab30bfc6b4aa3"></a>
template&lt;typename Cf2 &gt; </td></tr>
<tr class="memitem:abace7da8a87c85cd5fcab30bfc6b4aa3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#abace7da8a87c85cd5fcab30bfc6b4aa3">rebind</a> = <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf2 &gt;</td></tr>
<tr class="memdesc:abace7da8a87c85cd5fcab30bfc6b4aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series rebind alias. <br /></td></tr>
<tr class="separator:abace7da8a87c85cd5fcab30bfc6b4aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10de1584bd47b244c1b17dd9ce85ec3"><td class="memItemLeft" align="right" valign="top"><a id="ad10de1584bd47b244c1b17dd9ce85ec3"></a>
typedef <a class="el" href="classpiranha_1_1term.html">term</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3">term_type</a></td></tr>
<tr class="memdesc:ad10de1584bd47b244c1b17dd9ce85ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for term type. <br /></td></tr>
<tr class="separator:ad10de1584bd47b244c1b17dd9ce85ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06139c15c51191a979417513882cb02c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a> = typename <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">container_type::size_type</a></td></tr>
<tr class="memdesc:a06139c15c51191a979417513882cb02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type.  <a href="#a06139c15c51191a979417513882cb02c">More...</a><br /></td></tr>
<tr class="separator:a06139c15c51191a979417513882cb02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f4fc0e8a9566adbb560680df6d9084"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a> = const_iterator_impl</td></tr>
<tr class="memdesc:a35f4fc0e8a9566adbb560680df6d9084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator.  <a href="#a35f4fc0e8a9566adbb560680df6d9084">More...</a><br /></td></tr>
<tr class="separator:a35f4fc0e8a9566adbb560680df6d9084"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6414c786f3c31e9d7e656b3bc45559bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a6414c786f3c31e9d7e656b3bc45559bf">poisson_series</a> ()=default</td></tr>
<tr class="memdesc:a6414c786f3c31e9d7e656b3bc45559bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted default constructor.  <a href="#a6414c786f3c31e9d7e656b3bc45559bf">More...</a><br /></td></tr>
<tr class="separator:a6414c786f3c31e9d7e656b3bc45559bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bc881f00e4ff06743e2f853e5c95d4"><td class="memItemLeft" align="right" valign="top"><a id="a73bc881f00e4ff06743e2f853e5c95d4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a73bc881f00e4ff06743e2f853e5c95d4">poisson_series</a> (const <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> &amp;)=default</td></tr>
<tr class="memdesc:a73bc881f00e4ff06743e2f853e5c95d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor. <br /></td></tr>
<tr class="separator:a73bc881f00e4ff06743e2f853e5c95d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662d18434011db46e6eadfe122ba6a95"><td class="memItemLeft" align="right" valign="top"><a id="a662d18434011db46e6eadfe122ba6a95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a662d18434011db46e6eadfe122ba6a95">poisson_series</a> (<a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a662d18434011db46e6eadfe122ba6a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move constructor. <br /></td></tr>
<tr class="separator:a662d18434011db46e6eadfe122ba6a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5d9694f2ed8d158be2dfa26b30e24e"><td class="memItemLeft" align="right" valign="top"><a id="add5d9694f2ed8d158be2dfa26b30e24e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#add5d9694f2ed8d158be2dfa26b30e24e">~poisson_series</a> ()</td></tr>
<tr class="memdesc:add5d9694f2ed8d158be2dfa26b30e24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial destructor. <br /></td></tr>
<tr class="separator:add5d9694f2ed8d158be2dfa26b30e24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fc947ac8baa391c68ae6f120e551bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a36fc947ac8baa391c68ae6f120e551bc">operator=</a> (const <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> &amp;other)=default</td></tr>
<tr class="memdesc:a36fc947ac8baa391c68ae6f120e551bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a36fc947ac8baa391c68ae6f120e551bc">More...</a><br /></td></tr>
<tr class="separator:a36fc947ac8baa391c68ae6f120e551bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6377d37dde9cc6cc1ee1b37a6aef2842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a6377d37dde9cc6cc1ee1b37a6aef2842">operator=</a> (<a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:a6377d37dde9cc6cc1ee1b37a6aef2842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a6377d37dde9cc6cc1ee1b37a6aef2842">More...</a><br /></td></tr>
<tr class="separator:a6377d37dde9cc6cc1ee1b37a6aef2842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434c207c659be0d12767933f971f3017"><td class="memTemplParams" colspan="2">template&lt;typename T  = poisson_series&gt; </td></tr>
<tr class="memitem:a434c207c659be0d12767933f971f3017"><td class="memTemplItemLeft" align="right" valign="top">sin_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a434c207c659be0d12767933f971f3017">sin</a> () const</td></tr>
<tr class="memdesc:a434c207c659be0d12767933f971f3017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sine.  <a href="#a434c207c659be0d12767933f971f3017">More...</a><br /></td></tr>
<tr class="separator:a434c207c659be0d12767933f971f3017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1e14623a1a425e1741f11c46678b70"><td class="memTemplParams" colspan="2">template&lt;typename T  = poisson_series&gt; </td></tr>
<tr class="memitem:afd1e14623a1a425e1741f11c46678b70"><td class="memTemplItemLeft" align="right" valign="top">cos_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#afd1e14623a1a425e1741f11c46678b70">cos</a> () const</td></tr>
<tr class="memdesc:afd1e14623a1a425e1741f11c46678b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cosine.  <a href="#afd1e14623a1a425e1741f11c46678b70">More...</a><br /></td></tr>
<tr class="separator:afd1e14623a1a425e1741f11c46678b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731a0478d61af3a948be2a56ef3136fe"><td class="memTemplParams" colspan="2">template&lt;typename T  = poisson_series&gt; </td></tr>
<tr class="memitem:a731a0478d61af3a948be2a56ef3136fe"><td class="memTemplItemLeft" align="right" valign="top">integrate_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a731a0478d61af3a948be2a56ef3136fe">integrate</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a731a0478d61af3a948be2a56ef3136fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integration.  <a href="#a731a0478d61af3a948be2a56ef3136fe">More...</a><br /></td></tr>
<tr class="separator:a731a0478d61af3a948be2a56ef3136fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e203d94c66e5a5636a21b923c891d4"><td class="memTemplParams" colspan="2">template&lt;typename T  = poisson_series&gt; </td></tr>
<tr class="memitem:ab2e203d94c66e5a5636a21b923c891d4"><td class="memTemplItemLeft" align="right" valign="top">ti_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#ab2e203d94c66e5a5636a21b923c891d4">t_integrate</a> () const</td></tr>
<tr class="memdesc:ab2e203d94c66e5a5636a21b923c891d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time integration.  <a href="#ab2e203d94c66e5a5636a21b923c891d4">More...</a><br /></td></tr>
<tr class="separator:ab2e203d94c66e5a5636a21b923c891d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924b017f7854acce1063c310b219c087"><td class="memTemplParams" colspan="2">template&lt;typename T  = poisson_series&gt; </td></tr>
<tr class="memitem:a924b017f7854acce1063c310b219c087"><td class="memTemplItemLeft" align="right" valign="top">ti_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a924b017f7854acce1063c310b219c087">t_integrate</a> (std::vector&lt; std::string &gt; names) const</td></tr>
<tr class="memdesc:a924b017f7854acce1063c310b219c087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time integration (alternative overload).  <a href="#a924b017f7854acce1063c310b219c087">More...</a><br /></td></tr>
<tr class="separator:a924b017f7854acce1063c310b219c087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5735ddbc2dd58808c625cbe652888f8b"><td class="memItemLeft" align="right" valign="top">degree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a5735ddbc2dd58808c625cbe652888f8b">degree</a> () const</td></tr>
<tr class="memdesc:a5735ddbc2dd58808c625cbe652888f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total degree.  <a href="#a5735ddbc2dd58808c625cbe652888f8b">More...</a><br /></td></tr>
<tr class="separator:a5735ddbc2dd58808c625cbe652888f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f206670c33151c3b8c3d715d2dfd4d6"><td class="memItemLeft" align="right" valign="top">pdegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a1f206670c33151c3b8c3d715d2dfd4d6">degree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:a1f206670c33151c3b8c3d715d2dfd4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial degree.  <a href="#a1f206670c33151c3b8c3d715d2dfd4d6">More...</a><br /></td></tr>
<tr class="separator:a1f206670c33151c3b8c3d715d2dfd4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740700e20a5a450958c183d8eef33430"><td class="memItemLeft" align="right" valign="top">ldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a740700e20a5a450958c183d8eef33430">ldegree</a> () const</td></tr>
<tr class="memdesc:a740700e20a5a450958c183d8eef33430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total low degree.  <a href="#a740700e20a5a450958c183d8eef33430">More...</a><br /></td></tr>
<tr class="separator:a740700e20a5a450958c183d8eef33430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b89d255d38827c62014bd47b6cf2cd"><td class="memItemLeft" align="right" valign="top">pldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a86b89d255d38827c62014bd47b6cf2cd">ldegree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:a86b89d255d38827c62014bd47b6cf2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial low degree.  <a href="#a86b89d255d38827c62014bd47b6cf2cd">More...</a><br /></td></tr>
<tr class="separator:a86b89d255d38827c62014bd47b6cf2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105b7fa2770982a071e2452af0fd94f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a105b7fa2770982a071e2452af0fd94f4">truncate_degree</a> (const T &amp;max_degree) const</td></tr>
<tr class="memdesc:a105b7fa2770982a071e2452af0fd94f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total degree truncation.  <a href="#a105b7fa2770982a071e2452af0fd94f4">More...</a><br /></td></tr>
<tr class="separator:a105b7fa2770982a071e2452af0fd94f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac308a9c055ae2d5af5dac621268d3e43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#ac308a9c055ae2d5af5dac621268d3e43">truncate_degree</a> (const T &amp;max_degree, const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:ac308a9c055ae2d5af5dac621268d3e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial degree truncation.  <a href="#ac308a9c055ae2d5af5dac621268d3e43">More...</a><br /></td></tr>
<tr class="separator:ac308a9c055ae2d5af5dac621268d3e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1b859da8985051abeb1fa01a8dbbd8"><td class="memItemLeft" align="right" valign="top">ipow_subs_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a3b1b859da8985051abeb1fa01a8dbbd8">ipow_subs</a> (const std::string &amp;name, const <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b">integer</a> &amp;n, const T &amp;x) const</td></tr>
<tr class="memdesc:a3b1b859da8985051abeb1fa01a8dbbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#a3b1b859da8985051abeb1fa01a8dbbd8">More...</a><br /></td></tr>
<tr class="separator:a3b1b859da8985051abeb1fa01a8dbbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23d5585f793eeaa6c612eb0cfdcc357"><td class="memItemLeft" align="right" valign="top">ipow_subs_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1ipow__substitutable__series.html#ac23d5585f793eeaa6c612eb0cfdcc357">ipow_subs</a> (const std::string &amp;name, const Int &amp;n, const T &amp;x) const</td></tr>
<tr class="memdesc:ac23d5585f793eeaa6c612eb0cfdcc357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#ac23d5585f793eeaa6c612eb0cfdcc357">More...</a><br /></td></tr>
<tr class="separator:ac23d5585f793eeaa6c612eb0cfdcc357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83de874d3264155ff92521be46dc57f6"><td class="memItemLeft" align="right" valign="top">subs_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1substitutable__series.html#a83de874d3264155ff92521be46dc57f6">subs</a> (const std::string &amp;name, const T &amp;x) const</td></tr>
<tr class="memdesc:a83de874d3264155ff92521be46dc57f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#a83de874d3264155ff92521be46dc57f6">More...</a><br /></td></tr>
<tr class="separator:a83de874d3264155ff92521be46dc57f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c3c5fe0e03df2581ff107412dd1607"><td class="memItemLeft" align="right" valign="top">t_subs_type&lt; T, U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1t__substitutable__series.html#a75c3c5fe0e03df2581ff107412dd1607">t_subs</a> (const std::string &amp;name, const T &amp;c, const U &amp;s) const</td></tr>
<tr class="memdesc:a75c3c5fe0e03df2581ff107412dd1607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric substitution.  <a href="#a75c3c5fe0e03df2581ff107412dd1607">More...</a><br /></td></tr>
<tr class="separator:a75c3c5fe0e03df2581ff107412dd1607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae055ad2a53547134d4bac1759221c871"><td class="memItemLeft" align="right" valign="top">t_degree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#ae055ad2a53547134d4bac1759221c871">t_degree</a> () const</td></tr>
<tr class="memdesc:ae055ad2a53547134d4bac1759221c871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric degree.  <a href="#ae055ad2a53547134d4bac1759221c871">More...</a><br /></td></tr>
<tr class="separator:ae055ad2a53547134d4bac1759221c871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566e79c1366a8219d9128a28dbebed59"><td class="memItemLeft" align="right" valign="top">pt_degree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#a566e79c1366a8219d9128a28dbebed59">t_degree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:a566e79c1366a8219d9128a28dbebed59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric degree.  <a href="#a566e79c1366a8219d9128a28dbebed59">More...</a><br /></td></tr>
<tr class="separator:a566e79c1366a8219d9128a28dbebed59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0018c0b7cfe05ab3ebb7452095efa4"><td class="memItemLeft" align="right" valign="top">t_ldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#a6a0018c0b7cfe05ab3ebb7452095efa4">t_ldegree</a> () const</td></tr>
<tr class="memdesc:a6a0018c0b7cfe05ab3ebb7452095efa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric low degree.  <a href="#a6a0018c0b7cfe05ab3ebb7452095efa4">More...</a><br /></td></tr>
<tr class="separator:a6a0018c0b7cfe05ab3ebb7452095efa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac799485b3eadf858158b0278943913c3"><td class="memItemLeft" align="right" valign="top">pt_ldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#ac799485b3eadf858158b0278943913c3">t_ldegree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:ac799485b3eadf858158b0278943913c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric low degree.  <a href="#ac799485b3eadf858158b0278943913c3">More...</a><br /></td></tr>
<tr class="separator:ac799485b3eadf858158b0278943913c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bc03df227a3a3db5f2c4eb41d871b3"><td class="memItemLeft" align="right" valign="top">t_order_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#ad1bc03df227a3a3db5f2c4eb41d871b3">t_order</a> () const</td></tr>
<tr class="memdesc:ad1bc03df227a3a3db5f2c4eb41d871b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric order.  <a href="#ad1bc03df227a3a3db5f2c4eb41d871b3">More...</a><br /></td></tr>
<tr class="separator:ad1bc03df227a3a3db5f2c4eb41d871b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba924a5f7c4a8131c57d97e030281bcf"><td class="memItemLeft" align="right" valign="top">pt_order_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#aba924a5f7c4a8131c57d97e030281bcf">t_order</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:aba924a5f7c4a8131c57d97e030281bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric order.  <a href="#aba924a5f7c4a8131c57d97e030281bcf">More...</a><br /></td></tr>
<tr class="separator:aba924a5f7c4a8131c57d97e030281bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb13ea6366fc63fb613316784833373b"><td class="memItemLeft" align="right" valign="top">t_lorder_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#adb13ea6366fc63fb613316784833373b">t_lorder</a> () const</td></tr>
<tr class="memdesc:adb13ea6366fc63fb613316784833373b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric low order.  <a href="#adb13ea6366fc63fb613316784833373b">More...</a><br /></td></tr>
<tr class="separator:adb13ea6366fc63fb613316784833373b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f4e0d251557e578c43ae01ccb8640b"><td class="memItemLeft" align="right" valign="top">pt_lorder_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#ae3f4e0d251557e578c43ae01ccb8640b">t_lorder</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:ae3f4e0d251557e578c43ae01ccb8640b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric low order.  <a href="#ae3f4e0d251557e578c43ae01ccb8640b">More...</a><br /></td></tr>
<tr class="separator:ae3f4e0d251557e578c43ae01ccb8640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3d2e7f83e5f80f5e7535ab3c74ae54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#afa3d2e7f83e5f80f5e7535ab3c74ae54">size</a> () const</td></tr>
<tr class="memdesc:afa3d2e7f83e5f80f5e7535ab3c74ae54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series size.  <a href="#afa3d2e7f83e5f80f5e7535ab3c74ae54">More...</a><br /></td></tr>
<tr class="separator:afa3d2e7f83e5f80f5e7535ab3c74ae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38eec0bf05c2275b7dfdbeb37f156dd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a38eec0bf05c2275b7dfdbeb37f156dd3">empty</a> () const</td></tr>
<tr class="memdesc:a38eec0bf05c2275b7dfdbeb37f156dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty test.  <a href="#a38eec0bf05c2275b7dfdbeb37f156dd3">More...</a><br /></td></tr>
<tr class="separator:a38eec0bf05c2275b7dfdbeb37f156dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a826064332b8a234c2343d6975d2240"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a0a826064332b8a234c2343d6975d2240">is_single_coefficient</a> () const</td></tr>
<tr class="memdesc:a0a826064332b8a234c2343d6975d2240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for single-coefficient series.  <a href="#a0a826064332b8a234c2343d6975d2240">More...</a><br /></td></tr>
<tr class="separator:a0a826064332b8a234c2343d6975d2240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac049565106ddee1881fedf6481de9458"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458">insert</a> (T &amp;&amp;<a class="el" href="classpiranha_1_1term.html">term</a>)</td></tr>
<tr class="memdesc:ac049565106ddee1881fedf6481de9458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert term.  <a href="#ac049565106ddee1881fedf6481de9458">More...</a><br /></td></tr>
<tr class="separator:ac049565106ddee1881fedf6481de9458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a2d1924707f1dbc3c82284e48bdaf87f1">insert</a> (T &amp;&amp;<a class="el" href="classpiranha_1_1term.html">term</a>)</td></tr>
<tr class="memdesc:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert generic term with <code>Sign = true</code>.  <a href="#a2d1924707f1dbc3c82284e48bdaf87f1">More...</a><br /></td></tr>
<tr class="separator:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70cf84d7727f2ac0a449dddfc48e76c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad70cf84d7727f2ac0a449dddfc48e76c">operator+</a> () const</td></tr>
<tr class="memdesc:ad70cf84d7727f2ac0a449dddfc48e76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity operator.  <a href="#ad70cf84d7727f2ac0a449dddfc48e76c">More...</a><br /></td></tr>
<tr class="separator:ad70cf84d7727f2ac0a449dddfc48e76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60edb0a90a58e4750209fa0bf849a161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a60edb0a90a58e4750209fa0bf849a161">operator-</a> () const</td></tr>
<tr class="memdesc:a60edb0a90a58e4750209fa0bf849a161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation operator.  <a href="#a60edb0a90a58e4750209fa0bf849a161">More...</a><br /></td></tr>
<tr class="separator:a60edb0a90a58e4750209fa0bf849a161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dce8005ee4919ce2f68b508e6292118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118">negate</a> ()</td></tr>
<tr class="memdesc:a3dce8005ee4919ce2f68b508e6292118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate series in-place.  <a href="#a3dce8005ee4919ce2f68b508e6292118">More...</a><br /></td></tr>
<tr class="separator:a3dce8005ee4919ce2f68b508e6292118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9f290579db86ff6c8da7ec926a6a4a"><td class="memItemLeft" align="right" valign="top">pow_ret_type&lt; T, U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aae9f290579db86ff6c8da7ec926a6a4a">pow</a> (const T &amp;x) const</td></tr>
<tr class="memdesc:aae9f290579db86ff6c8da7ec926a6a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponentiation.  <a href="#aae9f290579db86ff6c8da7ec926a6a4a">More...</a><br /></td></tr>
<tr class="separator:aae9f290579db86ff6c8da7ec926a6a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0fc5df866edb13f058cc2ebdc741d6"><td class="memItemLeft" align="right" valign="top">partial_type&lt; Series &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#adb0fc5df866edb13f058cc2ebdc741d6">partial</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:adb0fc5df866edb13f058cc2ebdc741d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial derivative.  <a href="#adb0fc5df866edb13f058cc2ebdc741d6">More...</a><br /></td></tr>
<tr class="separator:adb0fc5df866edb13f058cc2ebdc741d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98b21393d8659e1257f79dbca5a759a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a">begin</a> () const</td></tr>
<tr class="memdesc:ad98b21393d8659e1257f79dbca5a759a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator.  <a href="#ad98b21393d8659e1257f79dbca5a759a">More...</a><br /></td></tr>
<tr class="separator:ad98b21393d8659e1257f79dbca5a759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9963bb8ab72b8f7b2ffbd38cf286eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a5c9963bb8ab72b8f7b2ffbd38cf286eb">end</a> () const</td></tr>
<tr class="memdesc:a5c9963bb8ab72b8f7b2ffbd38cf286eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator.  <a href="#a5c9963bb8ab72b8f7b2ffbd38cf286eb">More...</a><br /></td></tr>
<tr class="separator:a5c9963bb8ab72b8f7b2ffbd38cf286eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33216a696a195e177799649af9a6720c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a33216a696a195e177799649af9a6720c">filter</a> (std::function&lt; bool(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &amp;)&gt; func) const</td></tr>
<tr class="memdesc:a33216a696a195e177799649af9a6720c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Term filtering.  <a href="#a33216a696a195e177799649af9a6720c">More...</a><br /></td></tr>
<tr class="separator:a33216a696a195e177799649af9a6720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea750c31fed6a17346955d34f119aa74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aea750c31fed6a17346955d34f119aa74">transform</a> (std::function&lt; std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &amp;)&gt; func) const</td></tr>
<tr class="memdesc:aea750c31fed6a17346955d34f119aa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Term transformation.  <a href="#aea750c31fed6a17346955d34f119aa74">More...</a><br /></td></tr>
<tr class="separator:aea750c31fed6a17346955d34f119aa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c9ee4d3741bec3a93ec78bf0831f43"><td class="memItemLeft" align="right" valign="top">eval_type&lt; Series, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ae5c9ee4d3741bec3a93ec78bf0831f43">evaluate</a> (const std::unordered_map&lt; std::string, T &gt; &amp;dict) const</td></tr>
<tr class="memdesc:ae5c9ee4d3741bec3a93ec78bf0831f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation.  <a href="#ae5c9ee4d3741bec3a93ec78bf0831f43">More...</a><br /></td></tr>
<tr class="separator:ae5c9ee4d3741bec3a93ec78bf0831f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4d59b09e4496548b895a4c1212545d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#abc4d59b09e4496548b895a4c1212545d">trim</a> () const</td></tr>
<tr class="memdesc:abc4d59b09e4496548b895a4c1212545d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim.  <a href="#abc4d59b09e4496548b895a4c1212545d">More...</a><br /></td></tr>
<tr class="separator:abc4d59b09e4496548b895a4c1212545d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c22ff3703ce20884442a7cb3fbe0bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aa1c22ff3703ce20884442a7cb3fbe0bd">print_tex</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:aa1c22ff3703ce20884442a7cb3fbe0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print in TeX mode.  <a href="#aa1c22ff3703ce20884442a7cb3fbe0bd">More...</a><br /></td></tr>
<tr class="separator:aa1c22ff3703ce20884442a7cb3fbe0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5650572085cb49da6c36ab4f12af12f4"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a5650572085cb49da6c36ab4f12af12f4">hash</a> () const</td></tr>
<tr class="memdesc:a5650572085cb49da6c36ab4f12af12f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash value.  <a href="#a5650572085cb49da6c36ab4f12af12f4">More...</a><br /></td></tr>
<tr class="separator:a5650572085cb49da6c36ab4f12af12f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feab0d5ff5aa889f30caf9e1fb116ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3feab0d5ff5aa889f30caf9e1fb116ce">is_identical</a> (const <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &amp;other) const</td></tr>
<tr class="memdesc:a3feab0d5ff5aa889f30caf9e1fb116ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for identical series.  <a href="#a3feab0d5ff5aa889f30caf9e1fb116ce">More...</a><br /></td></tr>
<tr class="separator:a3feab0d5ff5aa889f30caf9e1fb116ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44128f48b629d89fcc0be3659affd0e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a44128f48b629d89fcc0be3659affd0e5">get_symbol_set</a> () const</td></tr>
<tr class="memdesc:a44128f48b629d89fcc0be3659affd0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set getter.  <a href="#a44128f48b629d89fcc0be3659affd0e5">More...</a><br /></td></tr>
<tr class="separator:a44128f48b629d89fcc0be3659affd0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ac3752460cc7a4c4cc0bea3330b31bcc9">set_symbol_set</a> (const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;args)</td></tr>
<tr class="memdesc:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set setter.  <a href="#ac3752460cc7a4c4cc0bea3330b31bcc9">More...</a><br /></td></tr>
<tr class="separator:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafc56eba07220821ab4b7f026105bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aaafc56eba07220821ab4b7f026105bd9">extend_symbol_set</a> (const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;new_ss) const</td></tr>
<tr class="memdesc:aaafc56eba07220821ab4b7f026105bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend symbol set.  <a href="#aaafc56eba07220821ab4b7f026105bd9">More...</a><br /></td></tr>
<tr class="separator:aaafc56eba07220821ab4b7f026105bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Table-querying methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods to query the properties of the internal container used to store the terms. </p>
</div></td></tr>
<tr class="memitem:a9fd2a6b0508e72ba3e3b0012a6eb4cce"><td class="memItemLeft" align="right" valign="top">sparsity_info_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a9fd2a6b0508e72ba3e3b0012a6eb4cce">table_sparsity</a> () const</td></tr>
<tr class="memdesc:a9fd2a6b0508e72ba3e3b0012a6eb4cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table sparsity.  <a href="#a9fd2a6b0508e72ba3e3b0012a6eb4cce">More...</a><br /></td></tr>
<tr class="separator:a9fd2a6b0508e72ba3e3b0012a6eb4cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cb3fb9005133515123a3c0a4d7a28f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a05cb3fb9005133515123a3c0a4d7a28f">table_load_factor</a> () const</td></tr>
<tr class="memdesc:a05cb3fb9005133515123a3c0a4d7a28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table load factor.  <a href="#a05cb3fb9005133515123a3c0a4d7a28f">More...</a><br /></td></tr>
<tr class="separator:a05cb3fb9005133515123a3c0a4d7a28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456359928f9f7134aaf23488d3e47928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a456359928f9f7134aaf23488d3e47928">table_bucket_count</a> () const</td></tr>
<tr class="memdesc:a456359928f9f7134aaf23488d3e47928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table bucket count.  <a href="#a456359928f9f7134aaf23488d3e47928">More...</a><br /></td></tr>
<tr class="separator:a456359928f9f7134aaf23488d3e47928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low-level interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Low-level methods. </p>
</div></td></tr>
<tr class="memitem:a2af49084d17c39794e0b6802bcc1b530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#ac17a849c8ad4558c158a6f04477ab44f">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a2af49084d17c39794e0b6802bcc1b530">_container</a> ()</td></tr>
<tr class="memdesc:a2af49084d17c39794e0b6802bcc1b530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable reference to the container of terms.  <a href="#a2af49084d17c39794e0b6802bcc1b530">More...</a><br /></td></tr>
<tr class="separator:a2af49084d17c39794e0b6802bcc1b530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3d05e9347eecb91b17db09689e32a1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpiranha_1_1series.html#ac17a849c8ad4558c158a6f04477ab44f">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aef3d05e9347eecb91b17db09689e32a1">_container</a> () const</td></tr>
<tr class="memdesc:aef3d05e9347eecb91b17db09689e32a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the container of terms.  <a href="#aef3d05e9347eecb91b17db09689e32a1">More...</a><br /></td></tr>
<tr class="separator:aef3d05e9347eecb91b17db09689e32a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae7da3b838cc92a235785ae4e339a1e97"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ae7da3b838cc92a235785ae4e339a1e97">clear_pow_cache</a> ()</td></tr>
<tr class="memdesc:ae7da3b838cc92a235785ae4e339a1e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the internal cache of natural powers.  <a href="#ae7da3b838cc92a235785ae4e339a1e97">More...</a><br /></td></tr>
<tr class="separator:ae7da3b838cc92a235785ae4e339a1e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e">register_custom_derivative</a> (const std::string &amp;name, F func)</td></tr>
<tr class="memdesc:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register custom partial derivative.  <a href="#a5ee2cef7972c1ed1a410351c9f3e175e">More...</a><br /></td></tr>
<tr class="separator:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041b2099313fa16a9b13d55ce7c0d930"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a041b2099313fa16a9b13d55ce7c0d930">unregister_custom_derivative</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a041b2099313fa16a9b13d55ce7c0d930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister custom partial derivative.  <a href="#a041b2099313fa16a9b13d55ce7c0d930">More...</a><br /></td></tr>
<tr class="separator:a041b2099313fa16a9b13d55ce7c0d930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40680bb3e8f2801b3754f0b03abb0633"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a40680bb3e8f2801b3754f0b03abb0633">unregister_all_custom_derivatives</a> ()</td></tr>
<tr class="memdesc:a40680bb3e8f2801b3754f0b03abb0633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister all custom partial derivatives.  <a href="#a40680bb3e8f2801b3754f0b03abb0633">More...</a><br /></td></tr>
<tr class="separator:a40680bb3e8f2801b3754f0b03abb0633"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ac17a849c8ad4558c158a6f04477ab44f"><td class="memItemLeft" align="right" valign="top"><a id="ac17a849c8ad4558c158a6f04477ab44f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ac17a849c8ad4558c158a6f04477ab44f">container_type</a> = <a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; <a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3">term_type</a>, detail::term_hasher&lt; <a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3">term_type</a> &gt; &gt;</td></tr>
<tr class="memdesc:ac17a849c8ad4558c158a6f04477ab44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for terms. <br /></td></tr>
<tr class="separator:ac17a849c8ad4558c158a6f04477ab44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="memItemLeft" align="right" valign="top"><a id="a4c1d33d3d9ed04b935e3024db2e46f04"></a>
<a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a4c1d33d3d9ed04b935e3024db2e46f04">m_symbol_set</a></td></tr>
<tr class="memdesc:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set. <br /></td></tr>
<tr class="separator:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ac93f383a79c3325197d6a951e9dd5"><td class="memItemLeft" align="right" valign="top"><a id="a68ac93f383a79c3325197d6a951e9dd5"></a>
<a class="el" href="classpiranha_1_1series.html#ac17a849c8ad4558c158a6f04477ab44f">container_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a68ac93f383a79c3325197d6a951e9dd5">m_container</a></td></tr>
<tr class="memdesc:a68ac93f383a79c3325197d6a951e9dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terms container. <br /></td></tr>
<tr class="separator:a68ac93f383a79c3325197d6a951e9dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Cf&gt;<br />
class piranha::poisson_series&lt; Cf &gt;</h3>

<p>Poisson series class. </p>
<p>This class represents multivariate Poisson series as collections of multivariate Poisson series terms, in which the trigonometric monomials are represented by <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805" title="Alias for piranha::real_trigonometric_kronecker_monomial with default type. ">piranha::rtk_monomial</a>. <code>Cf</code> represents the ring over which the Poisson series is defined.</p>
<p>This class satisfies the <a class="el" href="classpiranha_1_1is__series.html" title="Type trait to detect series types. ">piranha::is_series</a> type trait.</p>
<h2>Type requirements</h2>
<p><code>Cf</code> must be suitable for use in <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a> as first template argument.</p>
<h2>Exception safety guarantee</h2>
<p>This class provides the same guarantee as the base series type it derives from.</p>
<h2>Move semantics</h2>
<p>Move semantics is equivalent to the move semantics of the base series type it derives from. </p>

<p class="definition">Definition at line <a class="el" href="poisson__series__fwd_8hpp_source.html#l00044">44</a> of file <a class="el" href="poisson__series__fwd_8hpp_source.html">poisson_series_fwd.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a35f4fc0e8a9566adbb560680df6d9084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f4fc0e8a9566adbb560680df6d9084">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::<a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a> =  const_iterator_impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const iterator. </p>
<p>Iterator type that can be used to iterate over the terms of the series. The object returned upon dereferentiation is an <code>std::pair</code> in which the first element is a copy of the coefficient of the term, the second element a single-term instance of <code>Derived</code> constructed from the term's key and a unitary coefficient.</p>
<p>This iterator is an input iterator which additionally offers the multi-pass guarantee.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a> and <a class="el" href="classpiranha_1_1series.html#a5c9963bb8ab72b8f7b2ffbd38cf286eb" title="End iterator. ">piranha::series::end()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02012">2012</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a06139c15c51191a979417513882cb02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06139c15c51191a979417513882cb02c">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::<a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a> =  typename <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">container_type::size_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size type. </p>
<p>Used to represent the number of terms in the series. Equivalent to <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee" title="Size type. ">piranha::hash_set::size_type</a>. </p>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l01999">1999</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6414c786f3c31e9d7e656b3bc45559bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6414c786f3c31e9d7e656b3bc45559bf">&#9670;&nbsp;</a></span>poisson_series()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">piranha::poisson_series</a>&lt; Cf &gt;::<a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defaulted default constructor. </p>
<p>Will construct a Poisson series with zero terms. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2af49084d17c39794e0b6802bcc1b530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af49084d17c39794e0b6802bcc1b530">&#9670;&nbsp;</a></span>_container() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#ac17a849c8ad4558c158a6f04477ab44f">container_type</a>&amp; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a mutable reference to the container of terms. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the internal container of terms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02897">2897</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aef3d05e9347eecb91b17db09689e32a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3d05e9347eecb91b17db09689e32a1">&#9670;&nbsp;</a></span>_container() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpiranha_1_1series.html#ac17a849c8ad4558c158a6f04477ab44f">container_type</a>&amp; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to the container of terms. </p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the internal container of terms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02905">2905</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ad98b21393d8659e1257f79dbca5a759a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98b21393d8659e1257f79dbca5a759a">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin iterator. </p>
<p>Return an iterator to the first term of the series. The returned iterator will provide, when dereferenced, an <code>std::pair</code> in which the first element is a copy of the coefficient of the term, whereas the second element is a single-term instance of <code>Derived</code> built from the term's key and a unitary coefficient.</p>
<p>Note that terms are stored unordered in the series, hence it is not defined which particular term will be returned by calling this method. The only guarantee is that the iterator can be used to transverse all the series' terms until <a class="el" href="classpiranha_1_1series.html#a5c9963bb8ab72b8f7b2ffbd38cf286eb" title="End iterator. ">piranha::series::end()</a> is eventually reached.</p>
<p>Calling any non-const method on the series will invalidate the iterators obtained via <a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a> and <a class="el" href="classpiranha_1_1series.html#a5c9963bb8ab72b8f7b2ffbd38cf286eb" title="End iterator. ">piranha::series::end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the first term of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>construction and assignment of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>construction of term, coefficient and key instances. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02522">2522</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ae7da3b838cc92a235785ae4e339a1e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7da3b838cc92a235785ae4e339a1e97">&#9670;&nbsp;</a></span>clear_pow_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::clear_pow_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the internal cache of natural powers. </p>
<p>This method can be used to clear the cache of natural powers of series maintained by <a class="el" href="classpiranha_1_1series.html#aae9f290579db86ff6c8da7ec926a6a4a" title="Exponentiation. ">piranha::series::pow()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by threading primitives. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02389">2389</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="afd1e14623a1a425e1741f11c46678b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1e14623a1a425e1741f11c46678b70">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf &gt; </div>
<div class="memtemplate">
template&lt;typename T  = poisson_series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cos_type&lt;T&gt; <a class="el" href="classpiranha_1_1poisson__series.html">piranha::poisson_series</a>&lt; Cf &gt;::cos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cosine. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1poisson__series.html#a434c207c659be0d12767933f971f3017" title="Sine. ">piranha::poisson_series::sin()</a> is enabled.</dd></dl>
<p>This method works in the same way as <a class="el" href="classpiranha_1_1poisson__series.html#a434c207c659be0d12767933f971f3017" title="Sine. ">piranha::poisson_series::sin()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the cosine of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1poisson__series.html#a434c207c659be0d12767933f971f3017" title="Sine. ">piranha::poisson_series::sin()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="poisson__series_8hpp_source.html#l00684">684</a> of file <a class="el" href="poisson__series_8hpp_source.html">poisson_series.hpp</a>.</p>

</div>
</div>
<a id="a5735ddbc2dd58808c625cbe652888f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5735ddbc2dd58808c625cbe652888f8b">&#9670;&nbsp;</a></span>degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">degree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The degree of the series is the maximum degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the total degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="power__series_8hpp_source.html#l00397">397</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a1f206670c33151c3b8c3d715d2dfd4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f206670c33151c3b8c3d715d2dfd4d6">&#9670;&nbsp;</a></span>degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pdegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::degree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The partial degree of the series is the maximum partial degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation of the degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the partial degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="power__series_8hpp_source.html#l00451">451</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a38eec0bf05c2275b7dfdbeb37f156dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38eec0bf05c2275b7dfdbeb37f156dd3">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty test. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classpiranha_1_1series.html#afa3d2e7f83e5f80f5e7535ab3c74ae54" title="Series size. ">size()</a> is nonzero, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02121">2121</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a5c9963bb8ab72b8f7b2ffbd38cf286eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9963bb8ab72b8f7b2ffbd38cf286eb">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End iterator. </p>
<p>Return an iterator one past the last term of the series. See the documentation of <a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a> on how the returned iterator can be used.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the end of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>construction and assignment of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>construction of term, coefficient and key instances. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02541">2541</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ae5c9ee4d3741bec3a93ec78bf0831f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c9ee4d3741bec3a93ec78bf0831f43">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">eval_type&lt;Series, T&gt; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; std::string, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dict</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if:<ul>
<li>both the coefficient and the key types are evaluable,</li>
<li>the evaluated types are suitable for use in <a class="el" href="namespacepiranha_1_1math.html#ad3b85fa643adb089c7980693221a566c" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>,</li>
<li>the return type is constructible from <code>int</code> and it satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</li>
</ul>
</dd></dl>
<p>Series evaluation starts with a zero-initialised instance of the return type, which is determined according to the evaluation types of coefficient and key. The return value accumulates the evaluation of all terms in the series via the product of the evaluations of the coefficient-key pairs in each term. The input dictionary <code>dict</code> specifies with which value each symbolic quantity will be evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>dictionary of that will be used for evaluation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>evaluation of the series according to the evaluation dictionary <code>dict</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>coefficient and key evaluation,</li>
<li>insertion operations on <code>std::unordered_map</code>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#ad3b85fa643adb089c7980693221a566c" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02641">2641</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aaafc56eba07220821ab4b7f026105bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafc56eba07220821ab4b7f026105bd9">&#9670;&nbsp;</a></span>extend_symbol_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::extend_symbol_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;&#160;</td>
          <td class="paramname"><em>new_ss</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend symbol set. </p>
<p>This method will return a series whose symbol set will be <code>new_ss</code> and whose terms will be the terms of <code>this</code> with new keys obtained from calling the existing keys' <code>merge_args()</code> method. That is, the new keys will be compatible with the new extended symbol set <code>new_ss</code>.</p>
<p><code>new_ss</code> must have a size equal to or greater than the size of the current symbol set of <code>this</code>, and all the symbols in the current symbol set must be present in <code>new_ss</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_ss</td><td>the new set of symbols.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>this</code> with <code>new_ss</code> as symbol set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>new_ss</code> is smaller than the current symbol set or if it does not include all the symbols of the current symbol set. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of coefficients, terms and keys,</li>
<li>the key's <code>merge_args()</code> method,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02876">2876</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a33216a696a195e177799649af9a6720c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33216a696a195e177799649af9a6720c">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Term filtering. </p>
<p>This method will apply the functor <code>func</code> to each term in the series, and produce a return series containing all terms in <code>this</code> for which <code>func</code> returns <code>true</code>. Terms are passed to <code>func</code> in the format resulting from dereferencing the iterators obtained via <a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>filtering functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>filtered series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the call operator of <code>func</code>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term, coefficient, key construction. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02565">2565</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a44128f48b629d89fcc0be3659affd0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44128f48b629d89fcc0be3659affd0e5">&#9670;&nbsp;</a></span>get_symbol_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a>&amp; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::get_symbol_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbol set getter. </p>
<dl class="section return"><dt>Returns</dt><dd>const reference to the <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a> associated to the series. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02837">2837</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a5650572085cb49da6c36ab4f12af12f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5650572085cb49da6c36ab4f12af12f4">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash value. </p>
<p>The hash value for a series is zero if the series is empty, otherwise it is computed by adding the hash values of all terms. This ensures that two identical series in which the terms are stored in different order still produce the same hash value.</p>
<p>Note, however, that the arguments of the series are not considered in the hash value and that, in general, two series that compare equal according to <a class="el" href="classpiranha_1_1series__operators.html#abd1db7fd12e8271bce100f8fbaf95d73" title="Equality operator involving piranha::series. ">operator==()</a> will <b>not</b> have the same hash value (as the equality operator merges the arguments of two series before actually performing the comparison). Instead of <a class="el" href="classpiranha_1_1series__operators.html#abd1db7fd12e8271bce100f8fbaf95d73" title="Equality operator involving piranha::series. ">operator==()</a>, <a class="el" href="classpiranha_1_1series.html#a3feab0d5ff5aa889f30caf9e1fb116ce" title="Check for identical series. ">is_identical()</a> should be used for storing series as keys in associative containers.</p>
<dl class="section return"><dt>Returns</dt><dd>a hash value for the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by computing the hash of a term. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02805">2805</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ac049565106ddee1881fedf6481de9458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac049565106ddee1881fedf6481de9458">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert term. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the decay type of <code>T</code> is <a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3" title="Alias for term type. ">piranha::series::term_type</a>.</dd></dl>
<p>This method will insert <code>term</code> into the series using internally <a class="el" href="classpiranha_1_1hash__set.html#a9025fd16a4fc8868c8b835c8614e1171" title="Insert element. ">piranha::hash_set::insert</a>.</p>
<p>The insertion algorithm proceeds as follows:</p><ul>
<li>if the term is not compatible for insertion, an <code>std::invalid_argument</code> exception is thrown;</li>
<li>if the term is ignorable, the method will return without performing any insertion;</li>
<li>if the term is already in the series, then:<ul>
<li>its coefficient is added (if <code>Sign</code> is <code>true</code>) or subtracted (if <code>Sign</code> is <code>false</code>) to the existing term's coefficient;</li>
<li>if, after the addition/subtraction the existing term is ignorable, it will be erased;</li>
</ul>
</li>
<li>else:<ul>
<li>the term is inserted into the term container and, if <code>Sign</code> is <code>false</code>, its coefficient is negated.</li>
</ul>
</li>
</ul>
<p>After any modification to an existing term in the series (e.g., via insertion with negative <code>Sign</code> or via in-place addition or subtraction of existing coefficients), the term will be checked again for compatibility and ignorability, and, in case the term has become incompatible or ignorable, it will be erased from the series.</p>
<p>The exception safety guarantee upon insertion is that the series will be left in an undefined but valid state. Such a guarantee relies on the fact that the addition/subtraction and negation methods of the coefficient type will leave the coefficient in a valid (possibly undefined) state in face of exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>term to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1hash__set.html#a9025fd16a4fc8868c8b835c8614e1171" title="Insert element. ">piranha::hash_set::insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a7f52223f8638f91f56943168353e758a" title="Find element. ">piranha::hash_set::find()</a>,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a42c0ef2f03b797b1f509044a6ec3b80d" title="Erase element. ">piranha::hash_set::erase()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a>, in-place addition/subtraction on coefficient types. </li>
</ul>
</td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>term</code> is incompatible. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02179">2179</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a2d1924707f1dbc3c82284e48bdaf87f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1924707f1dbc3c82284e48bdaf87f1">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert generic term with <code>Sign = true</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the decay type of <code>T</code> is <a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3" title="Alias for term type. ">piranha::series::term_type</a>.</dd></dl>
<p>Convenience wrapper for the generic <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a> method, with <code>Sign</code> set to <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>term to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by generic <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02195">2195</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a731a0478d61af3a948be2a56ef3136fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731a0478d61af3a948be2a56ef3136fe">&#9670;&nbsp;</a></span>integrate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf &gt; </div>
<div class="memtemplate">
template&lt;typename T  = poisson_series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integrate_type&lt;T&gt; <a class="el" href="classpiranha_1_1poisson__series.html">piranha::poisson_series</a>&lt; Cf &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integration. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the algorithm described below is supported by all the involved types.</dd></dl>
<p>This method will attempt to compute the antiderivative of the Poisson series term by term using the following procedure:</p><ul>
<li>if the term's monomial does not depend on the integration variable, the integration will be deferred to the coefficient;</li>
<li>otherwise:<ul>
<li>if the coefficient does not depend on the integration variable, the monomial is integrated;</li>
<li>if the coefficient is a polynomial, a strategy of integration by parts is attempted, its success depending on whether the degree of the polynomial is a non-negative integral value;</li>
<li>otherwise, an error will be produced.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>integration variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the antiderivative of <code>this</code> with respect to <code>name</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the integration procedure fails. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1symbol.html" title="Literal symbol class. ">piranha::symbol</a> construction,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a>, <a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a>, <a class="el" href="namespacepiranha_1_1math.html#ad7f46a0b6a203a29e27aefd1a196edc6" title="Integration. ">piranha::math::integrate()</a>, <a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a> and <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a>,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term construction,</li>
<li>coefficient construction, assignment and arithmetics,</li>
<li>integration, construction and assignment of the key type,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1power__series.html#a5735ddbc2dd58808c625cbe652888f8b" title="Total degree. ">piranha::polynomial::degree()</a>,</li>
<li>series arithmetics. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="poisson__series_8hpp_source.html#l00721">721</a> of file <a class="el" href="poisson__series_8hpp_source.html">poisson_series.hpp</a>.</p>

</div>
</div>
<a id="a3b1b859da8985051abeb1fa01a8dbbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1b859da8985051abeb1fa01a8dbbd8">&#9670;&nbsp;</a></span>ipow_subs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipow_subs_type&lt;T&gt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">piranha::ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::ipow_subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b">integer</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient and/or key types support integral power substitution, and if the types involved in the substitution support the necessary arithmetic operations to compute the result.</dd></dl>
<p>This method will return an object resulting from the substitution of the integral power of the symbol called <code>name</code> in <code>this</code> with the generic object <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">n</td><td>integral power of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">x</td><td>object used for the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from:<ul>
<li>the substitution routines for the coefficients and/or keys,</li>
<li>the computation of the return value,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipow__substitutable__series_8hpp_source.html#l00222">222</a> of file <a class="el" href="ipow__substitutable__series_8hpp_source.html">ipow_substitutable_series.hpp</a>.</p>

</div>
</div>
<a id="ac23d5585f793eeaa6c612eb0cfdcc357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23d5585f793eeaa6c612eb0cfdcc357">&#9670;&nbsp;</a></span>ipow_subs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipow_subs_type&lt;T&gt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">piranha::ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::ipow_subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the other <a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a3b1b859da8985051abeb1fa01a8dbbd8" title="Substitution. ">ipow_subs()</a> overload is enabled, and <code>Int</code> is a C++ integral type.</dd></dl>
<p>This is a convenience method that will call the other <a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a3b1b859da8985051abeb1fa01a8dbbd8" title="Substitution. ">ipow_subs()</a> overload after converting <code>n</code> to <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">n</td><td>integral power of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">x</td><td>object used for the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from calling the other <a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a3b1b859da8985051abeb1fa01a8dbbd8" title="Substitution. ">ipow_subs()</a> overload, or by constructing a <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a> from a C++ integral type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipow__substitutable__series_8hpp_source.html#l00249">249</a> of file <a class="el" href="ipow__substitutable__series_8hpp_source.html">ipow_substitutable_series.hpp</a>.</p>

</div>
</div>
<a id="a3feab0d5ff5aa889f30caf9e1fb116ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3feab0d5ff5aa889f30caf9e1fb116ce">&#9670;&nbsp;</a></span>is_identical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::is_identical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for identical series. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <code>Derived</code> is equality-comparable.</dd></dl>
<p>This method will return <code>true</code> if the symbol sets of <code>this</code> and <code>other</code> are the same, and <code>other == *this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>argument for the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>this</code> and <code>other</code> are identical, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the comparison operator of <code>Derived</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02829">2829</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a0a826064332b8a234c2343d6975d2240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a826064332b8a234c2343d6975d2240">&#9670;&nbsp;</a></span>is_single_coefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::is_single_coefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for single-coefficient series. </p>
<p>A series is considered to be <em>single-coefficient</em> when it is symbolically equivalent to a coefficient. That is, the series is either empty (in which case it is considered to be equivalent to a coefficient constructed from zero) or consisting of a single term with unitary key (in which case the series is considered equivalent to its only coefficient).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> in case of single-coefficient series, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the <code>is_unitary()</code> method of the key type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02136">2136</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a740700e20a5a450958c183d8eef33430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740700e20a5a450958c183d8eef33430">&#9670;&nbsp;</a></span>ldegree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::ldegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The low degree of the series is the minimum low degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the total low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the low degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="power__series_8hpp_source.html#l00423">423</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a86b89d255d38827c62014bd47b6cf2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b89d255d38827c62014bd47b6cf2cd">&#9670;&nbsp;</a></span>ldegree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::ldegree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The partial low degree of the series is the minimum partial low degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation of the low degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the partial low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the low degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="power__series_8hpp_source.html#l00481">481</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a3dce8005ee4919ce2f68b508e6292118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dce8005ee4919ce2f68b508e6292118">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negate series in-place. </p>
<p>This method will call <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">math::negate()</a> on the coefficients of all terms. In case of exceptions, the basic exception safety guarantee is provided.</p>
<p>If any term becomes ignorable or incompatible after negation, it will be erased from the series.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">math::negate()</a> on the coefficient type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02232">2232</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ad70cf84d7727f2ac0a449dddfc48e76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70cf84d7727f2ac0a449dddfc48e76c">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identity operator. </p>
<dl class="section return"><dt>Returns</dt><dd>copy of <code>this</code>, cast to <code>Derived</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02205">2205</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a60edb0a90a58e4750209fa0bf849a161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60edb0a90a58e4750209fa0bf849a161">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negation operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>this</code> on which <a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118" title="Negate series in-place. ">negate()</a> has been called.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118" title="Negate series in-place. ">negate()</a>,</li>
<li>the copy constructor of <code>Derived</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02217">2217</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a36fc947ac8baa391c68ae6f120e551bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fc947ac8baa391c68ae6f120e551bc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&amp; <a class="el" href="classpiranha_1_1poisson__series.html">piranha::poisson_series</a>&lt; Cf &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the assignment operator of the base class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6377d37dde9cc6cc1ee1b37a6aef2842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6377d37dde9cc6cc1ee1b37a6aef2842">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&amp; <a class="el" href="classpiranha_1_1poisson__series.html">piranha::poisson_series</a>&lt; Cf &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>. </dd></dl>

</div>
</div>
<a id="adb0fc5df866edb13f058cc2ebdc741d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0fc5df866edb13f058cc2ebdc741d6">&#9670;&nbsp;</a></span>partial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">partial_type&lt;Series&gt; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::partial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient and key are differentiable (i.e., they satisfy the <a class="el" href="classpiranha_1_1is__differentiable.html" title="Type trait for differentiable types. ">piranha::is_differentiable</a> and <a class="el" href="classpiranha_1_1key__is__differentiable.html" title="Type trait to detect differentiable keys. ">piranha::key_is_differentiable</a> type traits), and if the arithmetic operations needed to compute the partial derivative are supported by all the involved types.</dd></dl>
<p>This method will return the partial derivative of <code>this</code> with respect to the variable called <code>name</code>. The method will construct the return value from the output of the differentiation methods of coefficient and key, and via arithmetic and/or term insertion operations.</p>
<p>Note that, contrary to the specialisation of <a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a> for series types, this method will not take into account custom derivatives registered via <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">piranha::series::register_custom_derivative()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the argument with respect to which the derivative will be calculated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial derivative of <code>this</code> with respect to the symbol named <code>name</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the differentiation methods of coefficient and key,</li>
<li>term construction and insertion,</li>
<li>arithmetic operations on the involved types,</li>
<li>construction of the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02423">2423</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aae9f290579db86ff6c8da7ec926a6a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9f290579db86ff6c8da7ec926a6a4a">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pow_ret_type&lt;T, U&gt; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exponentiation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the algorithm outlined here is supported by the involved types.</dd></dl>
<p>Return <code>this</code> raised to the <code>x</code>-th power. The type of the result is either the calling series type, or the calling series type rebound to the type resulting from the exponentiation of the coefficient of the calling type to the power of <code>x</code>. The exponentiation algorithm proceeds as follows:</p><ul>
<li>if the series is single-coefficient, the result is a single-coefficient series in which the coefficient is the original coefficient (or zero, if the calling series is empty) raised to the power of <code>x</code>;</li>
<li>if <code>x</code> is zero (as established by <a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a>), a series with a single term with unitary key and coefficient constructed from the integer numeral "1" is returned (i.e., any series raised to the power of zero is 1 - including empty series);</li>
<li>if <code>x</code> represents a non-negative integral value, the return value is constructed via repeated multiplications;</li>
<li>otherwise, an exception will be raised.</li>
</ul>
<p>An internal thread-safe cache of natural powers of series is maintained in order to improve performance during, e.g., substitution operations. This cache can be cleared with <a class="el" href="classpiranha_1_1series.html#ae7da3b838cc92a235785ae4e339a1e97" title="Clear the internal cache of natural powers. ">clear_pow_cache()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> raised to the power of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if exponentiation is computed via repeated series multiplications and <code>x</code> does not represent a non-negative integer. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>series, term, coefficient and key construction,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#a0a826064332b8a234c2343d6975d2240" title="Test for single-coefficient series. ">is_single_coefficient()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">piranha::math::pow()</a>, <a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a> and <a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>,</li>
<li>series multiplication,</li>
<li>memory errors in standard containers,</li>
<li>threading primitives,</li>
<li><a class="el" href="classpiranha_1_1series.html#a5650572085cb49da6c36ab4f12af12f4" title="Hash value. ">hash()</a> or <a class="el" href="classpiranha_1_1series.html#a3feab0d5ff5aa889f30caf9e1fb116ce" title="Check for identical series. ">is_identical()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02322">2322</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aa1c22ff3703ce20884442a7cb3fbe0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c22ff3703ce20884442a7cb3fbe0bd">&#9670;&nbsp;</a></span>print_tex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::print_tex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print in TeX mode. </p>
<p>Print series to stream <code>os</code> in TeX mode. The representation is constructed in the same way as explained in <a class="el" href="classpiranha_1_1series.html#a9f4b6250352b1657f36a0f90e021b6ce" title="Overloaded stream operator for piranha::series. ">piranha::series::operator&lt;&lt;()</a>, but using <a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735" title="Print series coefficient in TeX mode. ">piranha::print_tex_coefficient()</a> and the key's TeX printing method instead of the plain printing functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>target stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735" title="Print series coefficient in TeX mode. ">piranha::print_tex_coefficient()</a>,</li>
<li>the TeX printing method of the key type,</li>
<li>memory allocation errors in standard containers,</li>
<li><a class="el" href="classpiranha_1_1settings__.html#a511786ba228e56986e36b1d2b85c48f7" title="Get max term output. ">piranha::settings::get_max_term_output()</a>,</li>
<li>streaming to <code>os</code> or to instances of <code>std::ostringstream</code>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpiranha_1_1series.html#a9f4b6250352b1657f36a0f90e021b6ce" title="Overloaded stream operator for piranha::series. ">operator&lt;&lt;()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02729">2729</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a5ee2cef7972c1ed1a410351c9f3e175e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee2cef7972c1ed1a410351c9f3e175e">&#9670;&nbsp;</a></span>register_custom_derivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::register_custom_derivative </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register custom partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#adb0fc5df866edb13f058cc2ebdc741d6" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>, and if <code>F</code> is a type that can be used to construct <code>std::function&lt;partial_type(const Derived &amp;)</code>, where <code>partial_type</code> is the type resulting from the partial derivative of <code>Derived</code>.</dd></dl>
<p>Register a copy of a callable <code>func</code> associated to the symbol called <code>name</code> for use by <a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a>. <code>func</code> will be used to compute the partial derivative of instances of type <code>Derived</code> with respect to <code>name</code> in place of the default partial differentiation algorithm.</p>
<p>It is safe to call this method from multiple threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>symbol for which the custom partial derivative function will be registered. </td></tr>
    <tr><td class="paramname">func</td><td>custom partial derivative function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>failure(s) in threading primitives,</li>
<li>lookup and insertion operations on <code>std::unordered_map</code>,</li>
<li>construction and move-assignment of <code>std::function</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02450">2450</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ac3752460cc7a4c4cc0bea3330b31bcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3752460cc7a4c4cc0bea3330b31bcc9">&#9670;&nbsp;</a></span>set_symbol_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::set_symbol_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbol set setter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td><a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a> that will be associated to the series.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the series is not empty. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02848">2848</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a434c207c659be0d12767933f971f3017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434c207c659be0d12767933f971f3017">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf &gt; </div>
<div class="memtemplate">
template&lt;typename T  = poisson_series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sin_type&lt;T&gt; <a class="el" href="classpiranha_1_1poisson__series.html">piranha::poisson_series</a>&lt; Cf &gt;::sin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sine. </p>
<dl class="section note"><dt>Note</dt><dd>This template method is enabled only if <a class="el" href="namespacepiranha_1_1math.html#a8c98a78b13de3619ba578d2afe606209" title="Sine. ">math::sin()</a> can be called on the class from which <a class="el" href="classpiranha_1_1poisson__series.html" title="Poisson series class. ">piranha::poisson_series</a> derives (i.e., only if the default <a class="el" href="namespacepiranha_1_1math.html#a8c98a78b13de3619ba578d2afe606209" title="Sine. ">math::sin()</a> implementation for series is appropriate).</dd></dl>
<p>In general, this method behaves exactly like the default implementation of <a class="el" href="namespacepiranha_1_1math.html#a8c98a78b13de3619ba578d2afe606209" title="Sine. ">piranha::math::sin()</a> for series types. If, however, a polynomial appears in the hierarchy of coefficients, or the coefficient type is an instance of <a class="el" href="classpiranha_1_1rational__function.html" title="Rational function. ">piranha::rational_function</a>, then this method will attempt to extract an integral linear combination of symbolic arguments and use it to construct a Poisson series with a single term, unitary coefficient and the trigonometric key built from the linear combination.</p>
<p>For instance, if the calling Poisson series is </p><p class="formulaDsp">
\[ -2x + y, \]
</p>
<p> then calling this method will produce the Poisson series </p><p class="formulaDsp">
\[ -\sin \left( 2x - y \right). \]
</p>
<p>If for any reason it is not possible to extract the linear integral combination, then this method will forward the call to the default implementation of <a class="el" href="namespacepiranha_1_1math.html#a8c98a78b13de3619ba578d2afe606209" title="Sine. ">piranha::math::sin()</a> for series types.</p>
<dl class="section return"><dt>Returns</dt><dd>the sine of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1series.html#a0a826064332b8a234c2343d6975d2240" title="Test for single-coefficient series. ">piranha::series::is_single_coefficient()</a>, <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1symbol__set.html#a13101abf79be11e045539f82be6f120f" title="Add symbol to the set. ">piranha::symbol_set::add()</a>,</li>
<li>memory allocation errors in standard containers,</li>
<li>the constructors of coefficient, key and term types,</li>
<li>the cast operator of <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a8c98a78b13de3619ba578d2afe606209" title="Sine. ">piranha::math::sin()</a>,</li>
<li>the extraction of a linear combination of integral arguments from the polynomial coefficient. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="poisson__series_8hpp_source.html#l00668">668</a> of file <a class="el" href="poisson__series_8hpp_source.html">poisson_series.hpp</a>.</p>

</div>
</div>
<a id="afa3d2e7f83e5f80f5e7535ab3c74ae54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3d2e7f83e5f80f5e7535ab3c74ae54">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Series size. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of terms in the series. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02113">2113</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a83de874d3264155ff92521be46dc57f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83de874d3264155ff92521be46dc57f6">&#9670;&nbsp;</a></span>subs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subs_type&lt;T&gt; <a class="el" href="classpiranha_1_1substitutable__series.html">piranha::substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient and/or key types support substitution, and if the types involved in the substitution support the necessary arithmetic operations to compute the result. Also, the return type must satisfy piranha::is_constructible.</dd></dl>
<p>This method will return an object resulting from the substitution of the symbol called <code>name</code> in <code>this</code> with the generic object <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">x</td><td>object used for the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from:<ul>
<li>the substitution routines for the coefficients and/or keys,</li>
<li>the computation of the return value,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="substitutable__series_8hpp_source.html#l00220">220</a> of file <a class="el" href="substitutable__series_8hpp_source.html">substitutable_series.hpp</a>.</p>

</div>
</div>
<a id="ae055ad2a53547134d4bac1759221c871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae055ad2a53547134d4bac1759221c871">&#9670;&nbsp;</a></span>t_degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_degree_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the degree of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00216">216</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="a566e79c1366a8219d9128a28dbebed59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566e79c1366a8219d9128a28dbebed59">&#9670;&nbsp;</a></span>t_degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pt_degree_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_degree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the degree of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00238">238</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="ab2e203d94c66e5a5636a21b923c891d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e203d94c66e5a5636a21b923c891d4">&#9670;&nbsp;</a></span>t_integrate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf &gt; </div>
<div class="memtemplate">
template&lt;typename T  = poisson_series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ti_type&lt;T&gt; <a class="el" href="classpiranha_1_1poisson__series.html">piranha::poisson_series</a>&lt; Cf &gt;::t_integrate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Time integration. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if:<ul>
<li>the coefficient type is an instance of <a class="el" href="classpiranha_1_1divisor__series.html" title="Divisor series. ">piranha::divisor_series</a> or <a class="el" href="classpiranha_1_1rational__function.html" title="Rational function. ">piranha::rational_function</a>, and</li>
<li>the operations required by the computation of the time integration are supported by all the involved types.</li>
</ul>
</dd></dl>
<p>This is a special type of integration in which the trigonometric arguments are considered as linear functions of time, and in which the integration variable is time itself. For instance, if the input series is </p><p class="formulaDsp">
\[ \frac{1}{5}z\cos\left( x - y \right), \]
</p>
<p> the result of the time integration is </p><p class="formulaDsp">
\[ \frac{1}{5}{z}\frac{1}{\left(\nu_{x}-\nu_{y}\right)}\sin{\left({x}-{y}\right)}, \]
</p>
<p> where \( \nu_{x} \) and \( \nu_{y} \) are the frequencies associated to \( x \) and \( y \) (that is, it is understood that \( x = \nu_{x}t \) and \( x = \nu_{y}t \)).</p>
<p>This method will throw an error if any term of the calling series has a unitary key (e.g., in the Poisson series \( \frac{1}{5}z \) the only trigonometric key is \( \cos\left( 0 \right) \) and would thus result in a division by zero during a time integration).</p>
<dl class="section return"><dt>Returns</dt><dd>the result of the time integration.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the calling series has a unitary key. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>memory errors in standard containers,</li>
<li>the public interfaces of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>, <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a> and <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a>, <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a>,</li>
<li>the mathematical operations needed to compute the result,</li>
<li><a class="el" href="classpiranha_1_1divisor.html#a47a871f636bf0838da1bcd7d8aa5dfac" title="Create and insert a term from range and exponent. ">piranha::divisor::insert()</a>,</li>
<li>construction of the involved types. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="poisson__series_8hpp_source.html#l00791">791</a> of file <a class="el" href="poisson__series_8hpp_source.html">poisson_series.hpp</a>.</p>

</div>
</div>
<a id="a924b017f7854acce1063c310b219c087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924b017f7854acce1063c310b219c087">&#9670;&nbsp;</a></span>t_integrate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf &gt; </div>
<div class="memtemplate">
template&lt;typename T  = poisson_series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ti_type&lt;T&gt; <a class="el" href="classpiranha_1_1poisson__series.html">piranha::poisson_series</a>&lt; Cf &gt;::t_integrate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Time integration (alternative overload). </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the other overload of <a class="el" href="classpiranha_1_1poisson__series.html#ab2e203d94c66e5a5636a21b923c891d4" title="Time integration. ">piranha::poisson_series::t_integrate()</a> is enabled.</dd></dl>
<p>This method operates exactly like the other overload of <a class="el" href="classpiranha_1_1poisson__series.html#ab2e203d94c66e5a5636a21b923c891d4" title="Time integration. ">piranha::poisson_series::t_integrate()</a>, with the difference that the names of the symbols used to represent the frequencies are passed as the <code>names</code> argument, rather than automatically deduced. The <code>names</code> argument must be sorted lexicographically, otherwise an error will be produced. Duplicate entries in <code>names</code> will be removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>the names of the symbols used to represent the frequencies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the time integration.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the size of <code>names</code> is not equal to the size of the symbol set of <code>this</code> (after the removal of duplicate entries), or if <code>names</code> is not sorted lexicographically. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the other overload. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="poisson__series_8hpp_source.html#l00819">819</a> of file <a class="el" href="poisson__series_8hpp_source.html">poisson_series.hpp</a>.</p>

</div>
</div>
<a id="a6a0018c0b7cfe05ab3ebb7452095efa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0018c0b7cfe05ab3ebb7452095efa4">&#9670;&nbsp;</a></span>t_ldegree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_ldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_ldegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the degree of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00260">260</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="ac799485b3eadf858158b0278943913c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac799485b3eadf858158b0278943913c3">&#9670;&nbsp;</a></span>t_ldegree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pt_ldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_ldegree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the degree of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00282">282</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="adb13ea6366fc63fb613316784833373b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb13ea6366fc63fb613316784833373b">&#9670;&nbsp;</a></span>t_lorder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_lorder_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_lorder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric low order. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric low order of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the order of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00349">349</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="ae3f4e0d251557e578c43ae01ccb8640b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f4e0d251557e578c43ae01ccb8640b">&#9670;&nbsp;</a></span>t_lorder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pt_lorder_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_lorder </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric low order. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric low order of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the order of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00371">371</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="ad1bc03df227a3a3db5f2c4eb41d871b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bc03df227a3a3db5f2c4eb41d871b3">&#9670;&nbsp;</a></span>t_order() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_order_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric order. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric order of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the order of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00305">305</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="aba924a5f7c4a8131c57d97e030281bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba924a5f7c4a8131c57d97e030281bcf">&#9670;&nbsp;</a></span>t_order() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pt_order_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric order. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric order of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the order of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00327">327</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a id="a75c3c5fe0e03df2581ff107412dd1607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c3c5fe0e03df2581ff107412dd1607">&#9670;&nbsp;</a></span>t_subs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_subs_type&lt;T, U&gt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">piranha::t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::t_subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requirements outlined in <a class="el" href="classpiranha_1_1t__substitutable__series.html" title="Toolbox for series that support trigonometric substitution. ">piranha::t_substitutable_series</a> are satisfied.</dd></dl>
<p>Trigonometric substitution is the substitution of the cosine and sine of <code>name</code> for <code>c</code> and <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the symbol that will be subject to substitution. </td></tr>
    <tr><td class="paramname">c</td><td>cosine of <code>name</code>. </td></tr>
    <tr><td class="paramname">s</td><td>sine of <code>name</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the trigonometric substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from:<ul>
<li>construction of the return type,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term construction,</li>
<li>arithmetics on the intermediary values needed to compute the return value,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>,</li>
<li>the substitution methods of coefficient and key. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="t__substitutable__series_8hpp_source.html#l00218">218</a> of file <a class="el" href="t__substitutable__series_8hpp_source.html">t_substitutable_series.hpp</a>.</p>

</div>
</div>
<a id="a456359928f9f7134aaf23488d3e47928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456359928f9f7134aaf23488d3e47928">&#9670;&nbsp;</a></span>table_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::table_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table bucket count. </p>
<dl class="section return"><dt>Returns</dt><dd>the bucket count of the internal container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02281">2281</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a05cb3fb9005133515123a3c0a4d7a28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cb3fb9005133515123a3c0a4d7a28f">&#9670;&nbsp;</a></span>table_load_factor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::table_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table load factor. </p>
<p>Will call <a class="el" href="classpiranha_1_1hash__set.html#a669a2807083e38a90b3a0fc0ef467e3f" title="Load factor. ">piranha::hash_set::load_factor()</a> on the internal terms container and return the result.</p>
<dl class="section return"><dt>Returns</dt><dd>the load factor of the internal container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02273">2273</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a9fd2a6b0508e72ba3e3b0012a6eb4cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd2a6b0508e72ba3e3b0012a6eb4cce">&#9670;&nbsp;</a></span>table_sparsity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparsity_info_type <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::table_sparsity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table sparsity. </p>
<p>Will call <a class="el" href="classpiranha_1_1hash__set.html#a525256d52ac552b9a81e9978654f1d36" title="Get information on the sparsity of the set. ">piranha::hash_set::evaluate_sparsity()</a> on the internal terms container and return the result.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classpiranha_1_1hash__set.html#a525256d52ac552b9a81e9978654f1d36" title="Get information on the sparsity of the set. ">piranha::hash_set::evaluate_sparsity()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1hash__set.html#a525256d52ac552b9a81e9978654f1d36" title="Get information on the sparsity of the set. ">piranha::hash_set::evaluate_sparsity()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02262">2262</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aea750c31fed6a17346955d34f119aa74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea750c31fed6a17346955d34f119aa74">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Term transformation. </p>
<p>This method will apply the functor <code>func</code> to each term in the series, and will use the return value of the functor to construct a new series. Terms are passed to <code>func</code> in the same format resulting from dereferencing the iterators obtained via <a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a>, and <code>func</code> is expected to produce a return value of the same type.</p>
<p>The return series is first initialised as an empty series. For each input term <code>t</code>, the return value of <code>func</code> is used to construct a new temporary series from the multiplication of <code>t.first</code> and <code>t.second</code>. Each temporary series is then added to the return value series.</p>
<p>This method requires the coefficient type to be multipliable by <code>Derived</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>transforming functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformed series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the call operator of <code>func</code>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term, coefficient, key construction,</li>
<li>series multiplication and addition. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02603">2603</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="abc4d59b09e4496548b895a4c1212545d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4d59b09e4496548b895a4c1212545d">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim. </p>
<p>This method will return a series mathematically equivalent to <code>this</code> in which discardable arguments have been removed from the internal set of symbols. Which symbols are removed depends on the trimming method <code>trim_identify()</code> of the key type (e.g., in a polynomial a symbol can be discarded if its exponent is zero in all monomials).</p>
<p>If the coefficient type is an instance of <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>, <a class="el" href="classpiranha_1_1series.html#abc4d59b09e4496548b895a4c1212545d" title="Trim. ">trim()</a> will be called recursively on the coefficients while building the return value.</p>
<dl class="section return"><dt>Returns</dt><dd>trimmed version of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>operations on <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>the trimming methods of coefficient and/or key,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>term, coefficient and key type construction. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02695">2695</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a105b7fa2770982a071e2452af0fd94f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105b7fa2770982a071e2452af0fd94f4">&#9670;&nbsp;</a></span>truncate_degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total degree truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>This method can be used to eliminate the parts of a series whose degree is greater than <code>max_degree</code>. This includes the elimination of whole terms, but also the recursive truncation of coefficients via the <a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a> function, if supported by the coefficient. It must be noted that, in general, this method is not guaranteed to eliminate all the parts whose degree is greater than <code>max_degree</code> (in particular, in the current implementation there is no truncation implemented for keys - a key is kept as-is or completely eliminated).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_degree</td><td>maximum allowed total degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a>, if used,</li>
<li>the constructor of the term type,</li>
<li>the computation and comparison of degree types,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="power__series_8hpp_source.html#l00516">516</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="ac308a9c055ae2d5af5dac621268d3e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac308a9c055ae2d5af5dac621268d3e43">&#9670;&nbsp;</a></span>truncate_degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial degree truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>This method is equivalent to the other overload, the only difference being that the partial degree is considered in the computation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_degree</td><td>maximum allowed partial degree. </td></tr>
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation of the partial degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a>, if used,</li>
<li>the constructor of the term type,</li>
<li>the computation and comparison of degree types,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="power__series_8hpp_source.html#l00549">549</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a40680bb3e8f2801b3754f0b03abb0633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40680bb3e8f2801b3754f0b03abb0633">&#9670;&nbsp;</a></span>unregister_all_custom_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::unregister_all_custom_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister all custom partial derivatives. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#adb0fc5df866edb13f058cc2ebdc741d6" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>.</dd></dl>
<p>Will unregister all custom derivatives currently registered via <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">register_custom_derivative()</a>. It is safe to call this method from multiple threads.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by failure(s) in threading primitives. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02496">2496</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a041b2099313fa16a9b13d55ce7c0d930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041b2099313fa16a9b13d55ce7c0d930">&#9670;&nbsp;</a></span>unregister_custom_derivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::unregister_custom_derivative </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister custom partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#adb0fc5df866edb13f058cc2ebdc741d6" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>.</dd></dl>
<p>Unregister the custom partial derivative function associated to the symbol called <code>name</code>. If no custom partial derivative was previously registered using <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">register_custom_derivative()</a>, calling this function will be a no-op.</p>
<p>It is safe to call this method from multiple threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>symbol for which the custom partial derivative function will be unregistered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>failure(s) in threading primitives,</li>
<li>lookup and erase operations on <code>std::unordered_map</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="series_8hpp_source.html#l02477">2477</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="poisson__series__fwd_8hpp_source.html">poisson_series_fwd.hpp</a></li>
<li><a class="el" href="poisson__series_8hpp_source.html">poisson_series.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
