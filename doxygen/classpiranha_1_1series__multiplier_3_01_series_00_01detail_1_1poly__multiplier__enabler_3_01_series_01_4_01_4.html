<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>piranha: piranha::series_multiplier&lt; Series, detail::poly_multiplier_enabler&lt; Series &gt; &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepiranha.html">piranha</a></li><li class="navelem"><a class="el" href="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4.html">series_multiplier&lt; Series, detail::poly_multiplier_enabler&lt; Series &gt; &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">piranha::series_multiplier&lt; Series, detail::poly_multiplier_enabler&lt; Series &gt; &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Specialisation of <a class="el" href="classpiranha_1_1series__multiplier.html" title="Series multiplier. ">piranha::series_multiplier</a> for <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a>.  
 <a href="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="polynomial_8hpp_source.html">piranha/polynomial.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for piranha::series_multiplier&lt; Series, detail::poly_multiplier_enabler&lt; Series &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4__inherit__graph.png" border="0" usemap="#piranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="piranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4_inherit__map" id="piranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4_inherit__map">
<area shape="rect" id="node2" href="classpiranha_1_1base__series__multiplier.html" title="Base series multiplier. " alt="" coords="34,6,176,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for piranha::series_multiplier&lt; Series, detail::poly_multiplier_enabler&lt; Series &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4__coll__graph.png" border="0" usemap="#piranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="piranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4_coll__map" id="piranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4_coll__map">
<area shape="rect" id="node2" href="classpiranha_1_1base__series__multiplier.html" title="Base series multiplier. " alt="" coords="34,97,176,138"/>
<area shape="rect" id="node3" href="classpiranha_1_1symbol__set.html" title="Symbol set. " alt="" coords="36,5,175,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a788fe1bc8ad41199c3272f4f1233d6f7"><td class="memItemLeft" align="right" valign="top"><a id="a788fe1bc8ad41199c3272f4f1233d6f7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#a788fe1bc8ad41199c3272f4f1233d6f7">v_ptr</a> = std::vector&lt; typename Series::term_type const * &gt;</td></tr>
<tr class="memdesc:a788fe1bc8ad41199c3272f4f1233d6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a vector of const pointers to series terms. <br /></td></tr>
<tr class="separator:a788fe1bc8ad41199c3272f4f1233d6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0c9276a36bdcbfe91ec70aa1929c40"><td class="memItemLeft" align="right" valign="top"><a id="a7a0c9276a36bdcbfe91ec70aa1929c40"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">size_type</a> = typename v_ptr::size_type</td></tr>
<tr class="memdesc:a7a0c9276a36bdcbfe91ec70aa1929c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size type of <a class="el" href="classpiranha_1_1base__series__multiplier.html#a788fe1bc8ad41199c3272f4f1233d6f7" title="Alias for a vector of const pointers to series terms. ">base_series_multiplier::v_ptr</a>. <br /></td></tr>
<tr class="separator:a7a0c9276a36bdcbfe91ec70aa1929c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c675eb2cbe3887a15eb06f5f6b70dd"><td class="memItemLeft" align="right" valign="top"><a id="af6c675eb2cbe3887a15eb06f5f6b70dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#af6c675eb2cbe3887a15eb06f5f6b70dd">bucket_size_type</a> = typename Series::size_type</td></tr>
<tr class="memdesc:af6c675eb2cbe3887a15eb06f5f6b70dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size type of <code>Series</code>. <br /></td></tr>
<tr class="separator:af6c675eb2cbe3887a15eb06f5f6b70dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a84d6a7a6aec422b96bcfafc491e5953f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4.html#a84d6a7a6aec422b96bcfafc491e5953f">series_multiplier</a> (const Series &amp;s1, const Series &amp;s2)</td></tr>
<tr class="memdesc:a84d6a7a6aec422b96bcfafc491e5953f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a84d6a7a6aec422b96bcfafc491e5953f">More...</a><br /></td></tr>
<tr class="separator:a84d6a7a6aec422b96bcfafc491e5953f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35a7dff662bcd9a680ce5f5d30d44ff"><td class="memTemplParams" colspan="2">template&lt;typename T  = Series, call_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:af35a7dff662bcd9a680ce5f5d30d44ff"><td class="memTemplItemLeft" align="right" valign="top">Series&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4.html#af35a7dff662bcd9a680ce5f5d30d44ff">operator()</a> () const</td></tr>
<tr class="memdesc:af35a7dff662bcd9a680ce5f5d30d44ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform multiplication.  <a href="#af35a7dff662bcd9a680ce5f5d30d44ff">More...</a><br /></td></tr>
<tr class="separator:af35a7dff662bcd9a680ce5f5d30d44ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low-level interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Low-level methods, on top of which the call operator is implemented. </p>
</div></td></tr>
<tr class="memitem:ab13965f514f57df6122786778ec4b147"><td class="memItemLeft" align="right" valign="top">Series&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4.html#ab13965f514f57df6122786778ec4b147">_untruncated_multiplication</a> () const</td></tr>
<tr class="memdesc:ab13965f514f57df6122786778ec4b147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Untruncated multiplication.  <a href="#ab13965f514f57df6122786778ec4b147">More...</a><br /></td></tr>
<tr class="separator:ab13965f514f57df6122786778ec4b147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848f7a75427b391729387cf8bcb91fd8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a848f7a75427b391729387cf8bcb91fd8"><td class="memTemplItemLeft" align="right" valign="top">Series&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4.html#a848f7a75427b391729387cf8bcb91fd8">_truncated_multiplication</a> (const T &amp;max_degree, const Args &amp;... args) const</td></tr>
<tr class="memdesc:a848f7a75427b391729387cf8bcb91fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncated multiplication.  <a href="#a848f7a75427b391729387cf8bcb91fd8">More...</a><br /></td></tr>
<tr class="separator:a848f7a75427b391729387cf8bcb91fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa546b5d216c1e34d83493ab88ecd6e2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa546b5d216c1e34d83493ab88ecd6e2e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">base::size_type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4.html#aa546b5d216c1e34d83493ab88ecd6e2e">_get_skip_limits</a> (const std::vector&lt; T &gt; &amp;v_d1, const std::vector&lt; T &gt; &amp;v_d2, const T &amp;max_degree) const</td></tr>
<tr class="memdesc:aa546b5d216c1e34d83493ab88ecd6e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish skip limits for truncated multiplication.  <a href="#aa546b5d216c1e34d83493ab88ecd6e2e">More...</a><br /></td></tr>
<tr class="separator:aa546b5d216c1e34d83493ab88ecd6e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a449c755e0923553efc310154ea83c25b"><td class="memTemplParams" colspan="2">template&lt;typename MultFunctor , typename LimitFunctor &gt; </td></tr>
<tr class="memitem:a449c755e0923553efc310154ea83c25b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#a449c755e0923553efc310154ea83c25b">blocked_multiplication</a> (const MultFunctor &amp;mf, const <a class="el" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">size_type</a> &amp;start1, const <a class="el" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">size_type</a> &amp;end1, const LimitFunctor &amp;lf) const</td></tr>
<tr class="memdesc:a449c755e0923553efc310154ea83c25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocked multiplication.  <a href="#a449c755e0923553efc310154ea83c25b">More...</a><br /></td></tr>
<tr class="separator:a449c755e0923553efc310154ea83c25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1a4dcb2793bab109351d6e67c85812"><td class="memTemplParams" colspan="2">template&lt;typename MultFunctor &gt; </td></tr>
<tr class="memitem:a2b1a4dcb2793bab109351d6e67c85812"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#a2b1a4dcb2793bab109351d6e67c85812">blocked_multiplication</a> (const MultFunctor &amp;mf, const <a class="el" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">size_type</a> &amp;start1, const <a class="el" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">size_type</a> &amp;end1) const</td></tr>
<tr class="memdesc:a2b1a4dcb2793bab109351d6e67c85812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocked multiplication (convenience overload).  <a href="#a2b1a4dcb2793bab109351d6e67c85812">More...</a><br /></td></tr>
<tr class="separator:a2b1a4dcb2793bab109351d6e67c85812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff9799081d495f98f3c3568d6a1ce4e"><td class="memTemplParams" colspan="2">template&lt;std::size_t MultArity, typename MultFunctor , typename LimitFunctor &gt; </td></tr>
<tr class="memitem:a9ff9799081d495f98f3c3568d6a1ce4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1base__series__multiplier.html#af6c675eb2cbe3887a15eb06f5f6b70dd">bucket_size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#a9ff9799081d495f98f3c3568d6a1ce4e">estimate_final_series_size</a> (const LimitFunctor &amp;lf) const</td></tr>
<tr class="memdesc:a9ff9799081d495f98f3c3568d6a1ce4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate size of series multiplication.  <a href="#a9ff9799081d495f98f3c3568d6a1ce4e">More...</a><br /></td></tr>
<tr class="separator:a9ff9799081d495f98f3c3568d6a1ce4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab48207cb0998d3ae08baadd0f63100e"><td class="memTemplParams" colspan="2">template&lt;std::size_t MultArity, typename MultFunctor &gt; </td></tr>
<tr class="memitem:aab48207cb0998d3ae08baadd0f63100e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1base__series__multiplier.html#af6c675eb2cbe3887a15eb06f5f6b70dd">bucket_size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#aab48207cb0998d3ae08baadd0f63100e">estimate_final_series_size</a> () const</td></tr>
<tr class="memdesc:aab48207cb0998d3ae08baadd0f63100e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate size of series multiplication (convenience overload)  <a href="#aab48207cb0998d3ae08baadd0f63100e">More...</a><br /></td></tr>
<tr class="separator:aab48207cb0998d3ae08baadd0f63100e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb17023864005423955671f8181dd2a5"><td class="memTemplParams" colspan="2">template&lt;typename LimitFunctor &gt; </td></tr>
<tr class="memitem:acb17023864005423955671f8181dd2a5"><td class="memTemplItemLeft" align="right" valign="top">Series&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#acb17023864005423955671f8181dd2a5">plain_multiplication</a> (const LimitFunctor &amp;lf) const</td></tr>
<tr class="memdesc:acb17023864005423955671f8181dd2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A plain series multiplication routine.  <a href="#acb17023864005423955671f8181dd2a5">More...</a><br /></td></tr>
<tr class="separator:acb17023864005423955671f8181dd2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bedadeb03868439565053d51d6e78f6"><td class="memItemLeft" align="right" valign="top">Series&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#a6bedadeb03868439565053d51d6e78f6">plain_multiplication</a> () const</td></tr>
<tr class="memdesc:a6bedadeb03868439565053d51d6e78f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A plain series multiplication routine (convenience overload).  <a href="#a6bedadeb03868439565053d51d6e78f6">More...</a><br /></td></tr>
<tr class="separator:a6bedadeb03868439565053d51d6e78f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84b5cdc51fc0a7451973dbb2944c763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#ac84b5cdc51fc0a7451973dbb2944c763">finalise_series</a> (Series &amp;s) const</td></tr>
<tr class="memdesc:ac84b5cdc51fc0a7451973dbb2944c763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise series.  <a href="#ac84b5cdc51fc0a7451973dbb2944c763">More...</a><br /></td></tr>
<tr class="separator:ac84b5cdc51fc0a7451973dbb2944c763"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a97a2a9458cf1f78bc0fe33b70b867367"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#a97a2a9458cf1f78bc0fe33b70b867367">sanitise_series</a> (Series &amp;retval, unsigned n_threads)</td></tr>
<tr class="memdesc:a97a2a9458cf1f78bc0fe33b70b867367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sanitise series.  <a href="#a97a2a9458cf1f78bc0fe33b70b867367">More...</a><br /></td></tr>
<tr class="separator:a97a2a9458cf1f78bc0fe33b70b867367"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab0a3e37b54cb6c111229924666756de0"><td class="memItemLeft" align="right" valign="top"><a id="ab0a3e37b54cb6c111229924666756de0"></a>
<a class="el" href="classpiranha_1_1base__series__multiplier.html#a788fe1bc8ad41199c3272f4f1233d6f7">v_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#ab0a3e37b54cb6c111229924666756de0">m_v1</a></td></tr>
<tr class="memdesc:ab0a3e37b54cb6c111229924666756de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of const pointers to the terms in the larger series. <br /></td></tr>
<tr class="separator:ab0a3e37b54cb6c111229924666756de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed07a1857607d4b72c237f7b88d4568"><td class="memItemLeft" align="right" valign="top"><a id="a2ed07a1857607d4b72c237f7b88d4568"></a>
<a class="el" href="classpiranha_1_1base__series__multiplier.html#a788fe1bc8ad41199c3272f4f1233d6f7">v_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#a2ed07a1857607d4b72c237f7b88d4568">m_v2</a></td></tr>
<tr class="memdesc:a2ed07a1857607d4b72c237f7b88d4568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of const pointers to the terms in the smaller series. <br /></td></tr>
<tr class="separator:a2ed07a1857607d4b72c237f7b88d4568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37b7711dd0636239a78c96d215ccf95"><td class="memItemLeft" align="right" valign="top"><a id="af37b7711dd0636239a78c96d215ccf95"></a>
const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#af37b7711dd0636239a78c96d215ccf95">m_ss</a></td></tr>
<tr class="memdesc:af37b7711dd0636239a78c96d215ccf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The symbol set of the series used during construction. <br /></td></tr>
<tr class="separator:af37b7711dd0636239a78c96d215ccf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03da0589cc878e131ee8325176e346c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__series__multiplier.html#ab03da0589cc878e131ee8325176e346c">m_n_threads</a></td></tr>
<tr class="memdesc:ab03da0589cc878e131ee8325176e346c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads.  <a href="#ab03da0589cc878e131ee8325176e346c">More...</a><br /></td></tr>
<tr class="separator:ab03da0589cc878e131ee8325176e346c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Series&gt;<br />
class piranha::series_multiplier&lt; Series, detail::poly_multiplier_enabler&lt; Series &gt; &gt;</h3>

<p>Specialisation of <a class="el" href="classpiranha_1_1series__multiplier.html" title="Series multiplier. ">piranha::series_multiplier</a> for <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a>. </p>
<p>This specialisation of <a class="el" href="classpiranha_1_1series__multiplier.html" title="Series multiplier. ">piranha::series_multiplier</a> is enabled when <code>Series</code> is an instance of <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a>.</p>
<h2>Type requirements</h2>
<p><code>Series</code> must be suitable for use in <a class="el" href="classpiranha_1_1base__series__multiplier.html" title="Base series multiplier. ">piranha::base_series_multiplier</a>.</p>
<h2>Exception safety guarantee</h2>
<p>This class provides the same guarantee as <a class="el" href="classpiranha_1_1base__series__multiplier.html" title="Base series multiplier. ">piranha::base_series_multiplier</a>.</p>
<h2>Move semantics</h2>
<p>Move semantics is equivalent to <a class="el" href="classpiranha_1_1base__series__multiplier.html" title="Base series multiplier. ">piranha::base_series_multiplier</a>'s move semantics. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01014">1014</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a84d6a7a6aec422b96bcfafc491e5953f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d6a7a6aec422b96bcfafc491e5953f">&#9670;&nbsp;</a></span>series_multiplier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series__multiplier.html">piranha::series_multiplier</a>&lt; Series, detail::poly_multiplier_enabler&lt; Series &gt; &gt;::<a class="el" href="classpiranha_1_1series__multiplier.html">series_multiplier</a> </td>
          <td>(</td>
          <td class="paramtype">const Series &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Series &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>The constructor will call the base constructor and run these additional checks:</p><ul>
<li>if the key is a <a class="el" href="classpiranha_1_1kronecker__monomial.html" title="Kronecker monomial class. ">piranha::kronecker_monomial</a>, it will be checked that the result of the multiplication does not overflow the representation limits of <a class="el" href="classpiranha_1_1kronecker__monomial.html" title="Kronecker monomial class. ">piranha::kronecker_monomial</a>;</li>
<li>if the key is a <a class="el" href="classpiranha_1_1monomial.html" title="Monomial class. ">piranha::monomial</a> of a C++ integral type, it will be checked that the result of the multiplication does not overflow the limits of the integral type.</li>
</ul>
<p>If any check fails, a runtime error will be produced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>first series operand. </td></tr>
    <tr><td class="paramname">s2</td><td>second series operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if a bounds check, as described above, fails. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the base constructor,</li>
<li>standard threading primitives,</li>
<li>memory errors in standard containers,</li>
<li><a class="el" href="classpiranha_1_1thread__pool__.html#ab9d1fe61963e14532c7f18254c703b45" title="Enqueue task. ">thread_pool::enqueue()</a>,</li>
<li><a class="el" href="classpiranha_1_1future__list.html#a52161ce8fcc55a22299c9164a2ca4bd3" title="Move-insert a future. ">future_list::push_back()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01316">1316</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa546b5d216c1e34d83493ab88ecd6e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa546b5d216c1e34d83493ab88ecd6e2e">&#9670;&nbsp;</a></span>_get_skip_limits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">base::size_type</a>&gt; <a class="el" href="classpiranha_1_1series__multiplier.html">piranha::series_multiplier</a>&lt; Series, detail::poly_multiplier_enabler&lt; Series &gt; &gt;::_get_skip_limits </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establish skip limits for truncated multiplication. </p>
<dl class="section note"><dt>Note</dt><dd>This method can be called only if <code>Series</code> supports truncated multiplication (as explained in <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a>) and <code>T</code> is the same type as the degree type.</dd></dl>
<p>This method assumes that <code>v_d1</code> and <code>v_d2</code> are vectors containing the degrees of each term in the first and second series respectively, and that <code>v_d2</code> is sorted in ascending order. It will return a vector <code>v</code> of indices in the second series such that, given an index <code>i</code> in the first series, the term of index <code>v[i]</code> in the second series is the first term such that the term-by-term multiplication with the <code>i</code>-th term in the first series produces a term of degree greater than <code>max_degree</code>. That is, terms of index equal to or greater than <code>v[i]</code> in the second series will produce terms with degree greater than <code>max_degree</code> when multiplied by the <code>i</code>-th term in the first series.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v_d1</td><td>a vector containing the degrees of the terms in the first series. </td></tr>
    <tr><td class="paramname">v_d2</td><td>a sorted vector containing the degrees of the terms in the second series. </td></tr>
    <tr><td class="paramname">max_degree</td><td>the truncation degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector of skip limits, as explained above.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>memory errors in standard containers,</li>
<li><a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>,</li>
<li>operations on the degree type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01502">1502</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a848f7a75427b391729387cf8bcb91fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848f7a75427b391729387cf8bcb91fd8">&#9670;&nbsp;</a></span>_truncated_multiplication()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Series <a class="el" href="classpiranha_1_1series__multiplier.html">piranha::series_multiplier</a>&lt; Series, detail::poly_multiplier_enabler&lt; Series &gt; &gt;::_truncated_multiplication </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncated multiplication. </p>
<dl class="section note"><dt>Note</dt><dd>This method can be used only if the following conditions apply:<ul>
<li>the conditions for truncated multiplication outlined in <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> are satisfied,</li>
<li>the type <code>T</code> is the same as the degree type of the polynomial,</li>
<li>the number and types of <code>Args</code> is as specified below,</li>
<li><a class="el" href="classpiranha_1_1base__series__multiplier.html#acb17023864005423955671f8181dd2a5" title="A plain series multiplication routine. ">piranha::base_series_multiplier::plain_multiplication()</a> and <a class="el" href="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4.html#aa546b5d216c1e34d83493ab88ecd6e2e" title="Establish skip limits for truncated multiplication. ">_get_skip_limits()</a> can be called.</li>
</ul>
</dd></dl>
<p>This method will perform the truncated multiplication of the series operands passed to the constructor. The truncation degree is set to <code>max_degree</code>, and it is either:</p><ul>
<li>the total maximum degree, if the number of <code>Args</code> is zero, or</li>
<li>the partial degree, if the number of <code>Args</code> is two.</li>
</ul>
<p>In the latter case, the two arguments must be:</p><ul>
<li>an <code>std::vector</code> of <code>std::string</code> representing the names of the variables which will be taken into account when computing the partial degree,</li>
<li>a <a class="el" href="classpiranha_1_1symbol__set_1_1positions.html" title="Positions class. ">piranha::symbol_set::positions</a> referring to the positions of the variables of the first argument in the merged symbol set of the two operands.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_degree</td><td>the maximum degree of the result of the multiplication. </td></tr>
    <tr><td class="paramname">args</td><td>either an empty argument, or a pair of arguments as described above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the truncated multiplication of the operands used for construction.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>memory errors in standard containers,</li>
<li><a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>,</li>
<li>arithmetic and other operations on the degree type,</li>
<li><a class="el" href="classpiranha_1_1base__series__multiplier.html#acb17023864005423955671f8181dd2a5" title="A plain series multiplication routine. ">base_series_multiplier::plain_multiplication()</a>,</li>
<li><a class="el" href="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4.html#aa546b5d216c1e34d83493ab88ecd6e2e" title="Establish skip limits for truncated multiplication. ">_get_skip_limits()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01428">1428</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="ab13965f514f57df6122786778ec4b147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13965f514f57df6122786778ec4b147">&#9670;&nbsp;</a></span>_untruncated_multiplication()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Series <a class="el" href="classpiranha_1_1series__multiplier.html">piranha::series_multiplier</a>&lt; Series, detail::poly_multiplier_enabler&lt; Series &gt; &gt;::_untruncated_multiplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Untruncated multiplication. </p>
<dl class="section note"><dt>Note</dt><dd>This method can be used only if <a class="el" href="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4.html#af35a7dff662bcd9a680ce5f5d30d44ff" title="Perform multiplication. ">operator()()</a> can be called.</dd></dl>
<p>This method will return the result of multiplying the two polynomials used as input arguments in the class' constructor. The multiplication will be untruncated, regardless of the current global truncation settings.</p>
<dl class="section return"><dt>Returns</dt><dd>the result of the untruncated multiplication of the two operands used in the construction of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1base__series__multiplier.html#acb17023864005423955671f8181dd2a5" title="A plain series multiplication routine. ">piranha::base_series_multiplier::plain_multiplication()</a>,</li>
<li><a class="el" href="classpiranha_1_1base__series__multiplier.html#a9ff9799081d495f98f3c3568d6a1ce4e" title="Estimate size of series multiplication. ">piranha::base_series_multiplier::estimate_final_series_size()</a>,</li>
<li><a class="el" href="classpiranha_1_1base__series__multiplier.html#a97a2a9458cf1f78bc0fe33b70b867367" title="Sanitise series. ">piranha::base_series_multiplier::sanitise_series()</a>,</li>
<li><a class="el" href="classpiranha_1_1base__series__multiplier.html#ac84b5cdc51fc0a7451973dbb2944c763" title="Finalise series. ">piranha::base_series_multiplier::finalise_series()</a>,</li>
<li><code>boost::numeric_cast()</code>,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1hash__set.html" title="Hash set. ">piranha::hash_set</a>,</li>
<li><a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>,</li>
<li>memory errors in standard containers,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a4e861376c8a922cae01bcd27ee757d39" title="Ternary multiplication. ">piranha::math::mul3()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#ad3b85fa643adb089c7980693221a566c" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>,</li>
<li><a class="el" href="classpiranha_1_1thread__pool__.html#ab9d1fe61963e14532c7f18254c703b45" title="Enqueue task. ">thread_pool::enqueue()</a>,</li>
<li><a class="el" href="classpiranha_1_1future__list.html#a52161ce8fcc55a22299c9164a2ca4bd3" title="Move-insert a future. ">future_list::push_back()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01391">1391</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="a449c755e0923553efc310154ea83c25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449c755e0923553efc310154ea83c25b">&#9670;&nbsp;</a></span>blocked_multiplication() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<div class="memtemplate">
template&lt;typename MultFunctor , typename LimitFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1base__series__multiplier.html">piranha::base_series_multiplier</a>&lt; Series &gt;::blocked_multiplication </td>
          <td>(</td>
          <td class="paramtype">const MultFunctor &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LimitFunctor &amp;&#160;</td>
          <td class="paramname"><em>lf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocked multiplication. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>MultFunctor</code> or <code>LimitFunctor</code> do not satisfy the requirements outlined below, a compile-time error will be produced.</dd></dl>
<p>This method is logically equivalent to the following double loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">size_type</a> i = start1; i &lt; end1; ++i) {</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">size_type</a> limit = std::min(lf(i),<a class="code" href="classpiranha_1_1base__series__multiplier.html#a2ed07a1857607d4b72c237f7b88d4568">m_v2</a>.size());</div><div class="line"> <span class="keywordflow">for</span> (<a class="code" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">size_type</a> j = 0; j &lt; limit; ++j) {</div><div class="line">        mf(i,j);</div><div class="line"> }</div><div class="line">}</div></div><!-- fragment --><p><code>mf</code> must be a function object with a call operator accepting two instances of <a class="el" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40" title="The size type of base_series_multiplier::v_ptr. ">base_series_multiplier::size_type</a> and returning <code>void</code>. <code>lf</code> must be a function object with a call operator accepting and returning a <a class="el" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40" title="The size type of base_series_multiplier::v_ptr. ">base_series_multiplier::size_type</a>.</p>
<p>Internally, the double loops is decomposed in blocks of size <a class="el" href="classpiranha_1_1tuning.html#ab18605a560b5b816de8eb508ca922b49" title="Get the multiplication block size. ">tuning::get_multiplication_block_size()</a> in an attempt to optimise cache memory access patterns.</p>
<p>This method is meant to be used for series multiplication. <code>mf</code> is intended to be a function object that multiplies the <code>i</code>-th term of the first series by the <code>j</code>-th term of the second series. <code>lf</code> is intended to be a functor that establishes how many terms in the second series have to be multiplied by the <code>i</code>-th term of the first series.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mf</td><td>the multiplication functor. </td></tr>
    <tr><td class="paramname">start1</td><td>start index in the first series. </td></tr>
    <tr><td class="paramname">end1</td><td>end index in the first series. </td></tr>
    <tr><td class="paramname">lf</td><td>the limit functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>start1</code> is greater than <code>end1</code> or greater than the size of <a class="el" href="classpiranha_1_1base__series__multiplier.html#ab0a3e37b54cb6c111229924666756de0" title="Vector of const pointers to the terms in the larger series. ">base_series_multiplier::m_v1</a>, or if <code>end1</code> is greater than the size of <a class="el" href="classpiranha_1_1base__series__multiplier.html#ab0a3e37b54cb6c111229924666756de0" title="Vector of const pointers to the terms in the larger series. ">base_series_multiplier::m_v1</a>. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <code>mf</code> or <code>sf</code>, or <a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="base__series__multiplier_8hpp_source.html#l00444">444</a> of file <a class="el" href="base__series__multiplier_8hpp_source.html">base_series_multiplier.hpp</a>.</p>

</div>
</div>
<a id="a2b1a4dcb2793bab109351d6e67c85812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1a4dcb2793bab109351d6e67c85812">&#9670;&nbsp;</a></span>blocked_multiplication() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<div class="memtemplate">
template&lt;typename MultFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1base__series__multiplier.html">piranha::base_series_multiplier</a>&lt; Series &gt;::blocked_multiplication </td>
          <td>(</td>
          <td class="paramtype">const MultFunctor &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1base__series__multiplier.html#a7a0c9276a36bdcbfe91ec70aa1929c40">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>end1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocked multiplication (convenience overload). </p>
<p>This method is equivalent to the other overload with a limit functor that will unconditionally always return the size of the second series.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mf</td><td>the multiplication functor. </td></tr>
    <tr><td class="paramname">start1</td><td>start index in the first series. </td></tr>
    <tr><td class="paramname">end1</td><td>end index in the first series.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the other overload. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="base__series__multiplier_8hpp_source.html#l00511">511</a> of file <a class="el" href="base__series__multiplier_8hpp_source.html">base_series_multiplier.hpp</a>.</p>

</div>
</div>
<a id="a9ff9799081d495f98f3c3568d6a1ce4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff9799081d495f98f3c3568d6a1ce4e">&#9670;&nbsp;</a></span>estimate_final_series_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<div class="memtemplate">
template&lt;std::size_t MultArity, typename MultFunctor , typename LimitFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1base__series__multiplier.html#af6c675eb2cbe3887a15eb06f5f6b70dd">bucket_size_type</a> <a class="el" href="classpiranha_1_1base__series__multiplier.html">piranha::base_series_multiplier</a>&lt; Series &gt;::estimate_final_series_size </td>
          <td>(</td>
          <td class="paramtype">const LimitFunctor &amp;&#160;</td>
          <td class="paramname"><em>lf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimate size of series multiplication. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>MultArity</code>, <code>MultFunctor</code> or <code>LimitFunctor</code> do not satisfy the requirements outlined below, a compile-time error will be produced.</dd></dl>
<p>This method expects a <code>MultFunctor</code> type exposing the same inteface as explained in <a class="el" href="classpiranha_1_1base__series__multiplier.html#a449c755e0923553efc310154ea83c25b" title="Blocked multiplication. ">blocked_multiplication()</a>. Additionally, <code>MultFunctor</code> must be constructible from a const reference to <a class="el" href="classpiranha_1_1base__series__multiplier.html" title="Base series multiplier. ">piranha::base_series_multiplier</a> and a mutable reference to <code>Series</code>. <code>MultFunctor</code> objects will be constructed internally by this method, passing <code>this</code> and a temporary local <code>Series</code> object as construction parameters. It will be assumed that a call <code>mf(i,j)</code> multiplies the <code>i</code>-th term of the first series by the <code>j</code>-th term of the second series, accumulating the result into the <code>Series</code> passed as second parameter for construction.</p>
<p>This method will apply a statistical approach to estimate the final size of the result of the multiplication of the first series by the second. It will perform random term-by-term multiplications and deduce the estimate from the number of term multiplications performed before finding the first duplicate term. The <code>MultArity</code> parameter represents the arity of term multiplications - that is, the number of terms generated by a single term-by-term multiplication. It must be strictly positive.</p>
<p>The <code>lf</code> parameter must be a function object exposing the same inteface as explained in <a class="el" href="classpiranha_1_1base__series__multiplier.html#a449c755e0923553efc310154ea83c25b" title="Blocked multiplication. ">blocked_multiplication()</a>. This functor establishes how many terms in the second series must be multiplied by the <code>i</code>-th term of the first series.</p>
<p>The number returned by this function is always at least 1. Multiple threads might be used by this method: in such a case, different instances of <code>MultFunctor</code> are constructed in different threads, but <code>lf</code> is shared among all threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lf</td><td>the limit functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the estimated size of the multiplication of the first series by the second, always at least 1.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>in case of (unlikely) overflows in integral arithmetics. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>overflow errors in the conversion of <a class="el" href="namespacepiranha.html#a5b983cfca428401f011389e30157b362" title="Alias for piranha::mp_integer with 1 limb of static storage. ">piranha::integer</a> to integral types,</li>
<li>the call operator of <code>mf</code> or <code>lf</code>, and the constructor of <code>mf</code>,</li>
<li>memory errors in standard containers,</li>
<li>the conversion operator of <a class="el" href="namespacepiranha.html#a5b983cfca428401f011389e30157b362" title="Alias for piranha::mp_integer with 1 limb of static storage. ">piranha::integer</a>,</li>
<li>standard threading primitives,</li>
<li><a class="el" href="classpiranha_1_1thread__pool__.html#ab9d1fe61963e14532c7f18254c703b45" title="Enqueue task. ">thread_pool::enqueue()</a>,</li>
<li><a class="el" href="classpiranha_1_1future__list.html#a52161ce8fcc55a22299c9164a2ca4bd3" title="Move-insert a future. ">future_list::push_back()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="base__series__multiplier_8hpp_source.html#l00558">558</a> of file <a class="el" href="base__series__multiplier_8hpp_source.html">base_series_multiplier.hpp</a>.</p>

</div>
</div>
<a id="aab48207cb0998d3ae08baadd0f63100e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab48207cb0998d3ae08baadd0f63100e">&#9670;&nbsp;</a></span>estimate_final_series_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<div class="memtemplate">
template&lt;std::size_t MultArity, typename MultFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1base__series__multiplier.html#af6c675eb2cbe3887a15eb06f5f6b70dd">bucket_size_type</a> <a class="el" href="classpiranha_1_1base__series__multiplier.html">piranha::base_series_multiplier</a>&lt; Series &gt;::estimate_final_series_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimate size of series multiplication (convenience overload) </p>
<dl class="section return"><dt>Returns</dt><dd>the output of the other overload of <a class="el" href="classpiranha_1_1base__series__multiplier.html#a9ff9799081d495f98f3c3568d6a1ce4e" title="Estimate size of series multiplication. ">estimate_final_series_size()</a>, with a limit functor whose call operator will always return the size of the second series unconditionally.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the other overload of <a class="el" href="classpiranha_1_1base__series__multiplier.html#a9ff9799081d495f98f3c3568d6a1ce4e" title="Estimate size of series multiplication. ">estimate_final_series_size()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="base__series__multiplier_8hpp_source.html#l00722">722</a> of file <a class="el" href="base__series__multiplier_8hpp_source.html">base_series_multiplier.hpp</a>.</p>

</div>
</div>
<a id="ac84b5cdc51fc0a7451973dbb2944c763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84b5cdc51fc0a7451973dbb2944c763">&#9670;&nbsp;</a></span>finalise_series()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1base__series__multiplier.html">piranha::base_series_multiplier</a>&lt; Series &gt;::finalise_series </td>
          <td>(</td>
          <td class="paramtype">Series &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalise series. </p>
<p>This method will finalise the output <code>s</code> of a series multiplication undertaken via <a class="el" href="classpiranha_1_1base__series__multiplier.html" title="Base series multiplier. ">piranha::base_series_multiplier</a>. Currently, this method will not do anything unless the coefficient type of <code>Series</code> is an instance of <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. In this case, the coefficients of <code>s</code> will be normalised with respect to the least common multiplier computed in the constructor of <a class="el" href="classpiranha_1_1base__series__multiplier.html" title="Base series multiplier. ">piranha::base_series_multiplier</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the <code>Series</code> to be finalised.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1thread__pool__.html#ab9d1fe61963e14532c7f18254c703b45" title="Enqueue task. ">thread_pool::enqueue()</a>,</li>
<li><a class="el" href="classpiranha_1_1future__list.html#a52161ce8fcc55a22299c9164a2ca4bd3" title="Move-insert a future. ">future_list::push_back()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="base__series__multiplier_8hpp_source.html#l01126">1126</a> of file <a class="el" href="base__series__multiplier_8hpp_source.html">base_series_multiplier.hpp</a>.</p>

</div>
</div>
<a id="af35a7dff662bcd9a680ce5f5d30d44ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35a7dff662bcd9a680ce5f5d30d44ff">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<div class="memtemplate">
template&lt;typename T  = Series, call_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Series <a class="el" href="classpiranha_1_1series__multiplier.html">piranha::series_multiplier</a>&lt; Series, detail::poly_multiplier_enabler&lt; Series &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform multiplication. </p>
<dl class="section note"><dt>Note</dt><dd>This template operator is enabled only if:<ul>
<li>the coefficient and key type of <code>Series</code> satisfy <a class="el" href="classpiranha_1_1key__is__multipliable.html" title="Type trait for multipliable key. ">piranha::key_is_multipliable</a>,</li>
<li>the coefficient type of <code>Series</code> supports <a class="el" href="namespacepiranha_1_1math.html#a4e861376c8a922cae01bcd27ee757d39" title="Ternary multiplication. ">piranha::math::mul3()</a> and <a class="el" href="namespacepiranha_1_1math.html#ad3b85fa643adb089c7980693221a566c" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>.</li>
</ul>
</dd></dl>
<p>This method will perform the multiplication of the series operands passed to the constructor. Depending on the key type of <code>Series</code>, the implementation will use either <a class="el" href="classpiranha_1_1base__series__multiplier.html#acb17023864005423955671f8181dd2a5" title="A plain series multiplication routine. ">base_series_multiplier::plain_multiplication()</a> with <a class="el" href="classpiranha_1_1base__series__multiplier_1_1plain__multiplier.html" title="A plain multiplier functor. ">base_series_multiplier::plain_multiplier</a> or a different algorithm.</p>
<p>If a polynomial truncation threshold is defined and the degree type of the polynomial is a C++ integral type, the integral arithmetic operations involved in the truncation logic will be checked for overflow.</p>
<dl class="section return"><dt>Returns</dt><dd>the result of the multiplication of the input series operands.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>in case of overflow errors. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1base__series__multiplier.html#acb17023864005423955671f8181dd2a5" title="A plain series multiplication routine. ">piranha::base_series_multiplier::plain_multiplication()</a>,</li>
<li><a class="el" href="classpiranha_1_1base__series__multiplier.html#a9ff9799081d495f98f3c3568d6a1ce4e" title="Estimate size of series multiplication. ">piranha::base_series_multiplier::estimate_final_series_size()</a>,</li>
<li><a class="el" href="classpiranha_1_1base__series__multiplier.html#a97a2a9458cf1f78bc0fe33b70b867367" title="Sanitise series. ">piranha::base_series_multiplier::sanitise_series()</a>,</li>
<li><a class="el" href="classpiranha_1_1base__series__multiplier.html#ac84b5cdc51fc0a7451973dbb2944c763" title="Finalise series. ">piranha::base_series_multiplier::finalise_series()</a>,</li>
<li><code>boost::numeric_cast()</code>,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1hash__set.html" title="Hash set. ">piranha::hash_set</a>,</li>
<li><a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>,</li>
<li>memory errors in standard containers,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a4e861376c8a922cae01bcd27ee757d39" title="Ternary multiplication. ">piranha::math::mul3()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#ad3b85fa643adb089c7980693221a566c" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>,</li>
<li><a class="el" href="classpiranha_1_1thread__pool__.html#ab9d1fe61963e14532c7f18254c703b45" title="Enqueue task. ">thread_pool::enqueue()</a>,</li>
<li><a class="el" href="classpiranha_1_1future__list.html#a52161ce8fcc55a22299c9164a2ca4bd3" title="Move-insert a future. ">future_list::push_back()</a>,</li>
<li><a class="el" href="classpiranha_1_1series__multiplier_3_01_series_00_01detail_1_1poly__multiplier__enabler_3_01_series_01_4_01_4.html#a848f7a75427b391729387cf8bcb91fd8" title="Truncated multiplication. ">_truncated_multiplication()</a>,</li>
<li><a class="el" href="classpiranha_1_1polynomial.html#a1448978bc7f49ee46d3099cd8580dd1a" title="Query the status of the degree-based auto-truncation mechanism. ">polynomial::get_auto_truncate_degree()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="polynomial_8hpp_source.html#l01358">1358</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a id="acb17023864005423955671f8181dd2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb17023864005423955671f8181dd2a5">&#9670;&nbsp;</a></span>plain_multiplication() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<div class="memtemplate">
template&lt;typename LimitFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Series <a class="el" href="classpiranha_1_1base__series__multiplier.html">piranha::base_series_multiplier</a>&lt; Series &gt;::plain_multiplication </td>
          <td>(</td>
          <td class="paramtype">const LimitFunctor &amp;&#160;</td>
          <td class="paramname"><em>lf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A plain series multiplication routine. </p>
<dl class="section note"><dt>Note</dt><dd>If the key and coefficient types of <code>Series</code> do not satisfy <a class="el" href="classpiranha_1_1key__is__multipliable.html" title="Type trait for multipliable key. ">piranha::key_is_multipliable</a>, or <code>LimitFunctor</code> does not satisfy the requirements outlined in <a class="el" href="classpiranha_1_1base__series__multiplier.html#a449c755e0923553efc310154ea83c25b" title="Blocked multiplication. ">base_series_multiplier::blocked_multiplication()</a>, a compile-time error will be produced.</dd></dl>
<p>This method implements a generic series multiplication routine suitable for key types that satisfy <a class="el" href="classpiranha_1_1key__is__multipliable.html" title="Type trait for multipliable key. ">piranha::key_is_multipliable</a>. The implementation is either single-threaded or multi-threaded, depending on the sizes of the input series, and it will use either <a class="el" href="classpiranha_1_1base__series__multiplier_1_1plain__multiplier.html" title="A plain multiplier functor. ">base_series_multiplier::plain_multiplier</a> or a similar thread-safe multiplier for the term-by-term multiplications. The <code>lf</code> functor will be forwarded as limit functor to <a class="el" href="classpiranha_1_1base__series__multiplier.html#a449c755e0923553efc310154ea83c25b" title="Blocked multiplication. ">base_series_multiplier::blocked_multiplication()</a> and <a class="el" href="classpiranha_1_1base__series__multiplier.html#a9ff9799081d495f98f3c3568d6a1ce4e" title="Estimate size of series multiplication. ">base_series_multiplier::estimate_final_series_size()</a>.</p>
<p>Note that, in multithreaded mode, <code>lf</code> will be shared among (and called concurrently from) all the threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lf</td><td>the limit functor (see <a class="el" href="classpiranha_1_1base__series__multiplier.html#a449c755e0923553efc310154ea83c25b" title="Blocked multiplication. ">base_series_multiplier::blocked_multiplication()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the series resulting from the multiplication of the two series used to construct <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>,</li>
<li><a class="el" href="classpiranha_1_1base__series__multiplier.html#a9ff9799081d495f98f3c3568d6a1ce4e" title="Estimate size of series multiplication. ">base_series_multiplier::estimate_final_series_size()</a>,</li>
<li><code>boost::numeric_cast()</code>,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1hash__set.html" title="Hash set. ">piranha::hash_set</a>,</li>
<li><a class="el" href="classpiranha_1_1base__series__multiplier.html#a449c755e0923553efc310154ea83c25b" title="Blocked multiplication. ">base_series_multiplier::blocked_multiplication()</a>,</li>
<li><a class="el" href="classpiranha_1_1base__series__multiplier.html#a97a2a9458cf1f78bc0fe33b70b867367" title="Sanitise series. ">base_series_multiplier::sanitise_series()</a>,</li>
<li>the <code>multiply()</code> method of the key type of <code>Series</code>,</li>
<li><a class="el" href="classpiranha_1_1thread__pool__.html#ab9d1fe61963e14532c7f18254c703b45" title="Enqueue task. ">thread_pool::enqueue()</a>,</li>
<li><a class="el" href="classpiranha_1_1future__list.html#a52161ce8fcc55a22299c9164a2ca4bd3" title="Move-insert a future. ">future_list::push_back()</a>,</li>
<li>the construction of terms,</li>
<li>in-place addition of coefficients. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="base__series__multiplier_8hpp_source.html#l00984">984</a> of file <a class="el" href="base__series__multiplier_8hpp_source.html">base_series_multiplier.hpp</a>.</p>

</div>
</div>
<a id="a6bedadeb03868439565053d51d6e78f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bedadeb03868439565053d51d6e78f6">&#9670;&nbsp;</a></span>plain_multiplication() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Series <a class="el" href="classpiranha_1_1base__series__multiplier.html">piranha::base_series_multiplier</a>&lt; Series &gt;::plain_multiplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A plain series multiplication routine (convenience overload). </p>
<dl class="section return"><dt>Returns</dt><dd>the output of the other overload of <a class="el" href="classpiranha_1_1base__series__multiplier.html#acb17023864005423955671f8181dd2a5" title="A plain series multiplication routine. ">plain_multiplication()</a>, with a limit functor whose call operator will always return the size of the second series unconditionally.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the other overload of <a class="el" href="classpiranha_1_1base__series__multiplier.html#acb17023864005423955671f8181dd2a5" title="A plain series multiplication routine. ">plain_multiplication()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="base__series__multiplier_8hpp_source.html#l01106">1106</a> of file <a class="el" href="base__series__multiplier_8hpp_source.html">base_series_multiplier.hpp</a>.</p>

</div>
</div>
<a id="a97a2a9458cf1f78bc0fe33b70b867367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a2a9458cf1f78bc0fe33b70b867367">&#9670;&nbsp;</a></span>sanitise_series()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1base__series__multiplier.html">piranha::base_series_multiplier</a>&lt; Series &gt;::sanitise_series </td>
          <td>(</td>
          <td class="paramtype">Series &amp;&#160;</td>
          <td class="paramname"><em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sanitise series. </p>
<p>When using the low-level interface of <a class="el" href="classpiranha_1_1hash__set.html" title="Hash set. ">piranha::hash_set</a> for term insertion, invariants might be violated both in <a class="el" href="classpiranha_1_1hash__set.html" title="Hash set. ">piranha::hash_set</a> and <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>. In particular:</p>
<ul>
<li>terms may not be checked for compatibility or ignorability upon insertion,</li>
<li>the count of elements in <a class="el" href="classpiranha_1_1hash__set.html" title="Hash set. ">piranha::hash_set</a> might not be updated.</li>
</ul>
<p>This method can be used to fix these invariants: each term of <code>retval</code> will be checked for ignorability and compatibility, and the total count of terms in the series will be set to the number of non-ignorable terms. Ignorable terms will be erased.</p>
<p>Note that in case of exceptions <code>retval</code> will likely be left in an inconsistent state which violates internal invariants. Calls to this function should always be wrapped in a try/catch block that makes sure that <code>retval</code> is cleared before re-throwing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">retval</td><td>the series to be sanitised. </td></tr>
    <tr><td class="paramname">n_threads</td><td>the number of threads to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>n_threads</code> is zero, or if one of the terms in <code>retval</code> is not compatible with the symbol set of <code>retval</code>. </td></tr>
    <tr><td class="paramname">std::overflow_error</td><td>if the number of terms in <code>retval</code> overflows the maximum value representable by <a class="el" href="classpiranha_1_1base__series__multiplier.html#af6c675eb2cbe3887a15eb06f5f6b70dd" title="The size type of Series. ">base_series_multiplier::bucket_size_type</a>. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the cast operator of <a class="el" href="namespacepiranha.html#a5b983cfca428401f011389e30157b362" title="Alias for piranha::mp_integer with 1 limb of static storage. ">piranha::integer</a>,</li>
<li>standard threading primitives,</li>
<li><a class="el" href="classpiranha_1_1thread__pool__.html#ab9d1fe61963e14532c7f18254c703b45" title="Enqueue task. ">thread_pool::enqueue()</a>,</li>
<li><a class="el" href="classpiranha_1_1future__list.html#a52161ce8fcc55a22299c9164a2ca4bd3" title="Move-insert a future. ">future_list::push_back()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="base__series__multiplier_8hpp_source.html#l00851">851</a> of file <a class="el" href="base__series__multiplier_8hpp_source.html">base_series_multiplier.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab03da0589cc878e131ee8325176e346c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03da0589cc878e131ee8325176e346c">&#9670;&nbsp;</a></span>m_n_threads</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classpiranha_1_1base__series__multiplier.html">piranha::base_series_multiplier</a>&lt; Series &gt;::m_n_threads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of threads. </p>
<p>This value will be set by the constructor, and it represents the number of threads that will be used by the multiplier. The value is always at least 1 and it is calculated via <a class="el" href="classpiranha_1_1thread__pool__.html#ae99fb9a5fcb09377eac3a3b5281aa233" title="Compute number of threads to use. ">thread_pool::use_threads()</a>. </p>

<p class="definition">Definition at line <a class="el" href="base__series__multiplier_8hpp_source.html#l01144">1144</a> of file <a class="el" href="base__series__multiplier_8hpp_source.html">base_series_multiplier.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
