<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>piranha: piranha::small_vector&lt; T, S &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepiranha.html">piranha</a></li><li class="navelem"><a class="el" href="classpiranha_1_1small__vector.html">small_vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classpiranha_1_1small__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">piranha::small_vector&lt; T, S &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Small vector class.  
 <a href="classpiranha_1_1small__vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="small__vector_8hpp_source.html">piranha/small_vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9b9eb977b50c3b72c0a3035ee6d0a429"><td class="memItemLeft" align="right" valign="top"><a id="a9b9eb977b50c3b72c0a3035ee6d0a429"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a> = size_type_impl</td></tr>
<tr class="memdesc:a9b9eb977b50c3b72c0a3035ee6d0a429"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fundamental unsigned integer type representing the number of elements stored in the vector. <br /></td></tr>
<tr class="separator:a9b9eb977b50c3b72c0a3035ee6d0a429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac215fd59f6bf3421712b3936a390a69d"><td class="memItemLeft" align="right" valign="top"><a id="ac215fd59f6bf3421712b3936a390a69d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#ac215fd59f6bf3421712b3936a390a69d">value_type</a> = T</td></tr>
<tr class="memdesc:ac215fd59f6bf3421712b3936a390a69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>T</code>. <br /></td></tr>
<tr class="separator:ac215fd59f6bf3421712b3936a390a69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9f382f4d485161a235eaa89a1e5090"><td class="memItemLeft" align="right" valign="top"><a id="a5a9f382f4d485161a235eaa89a1e5090"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a5a9f382f4d485161a235eaa89a1e5090">iterator</a> = <a class="el" href="classpiranha_1_1small__vector.html#ac215fd59f6bf3421712b3936a390a69d">value_type</a> *</td></tr>
<tr class="memdesc:a5a9f382f4d485161a235eaa89a1e5090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type. <br /></td></tr>
<tr class="separator:a5a9f382f4d485161a235eaa89a1e5090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3351558142e18f6bbfe0b73b26c069"><td class="memItemLeft" align="right" valign="top"><a id="add3351558142e18f6bbfe0b73b26c069"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#add3351558142e18f6bbfe0b73b26c069">const_iterator</a> = <a class="el" href="classpiranha_1_1small__vector.html#ac215fd59f6bf3421712b3936a390a69d">value_type</a> const *</td></tr>
<tr class="memdesc:add3351558142e18f6bbfe0b73b26c069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type. <br /></td></tr>
<tr class="separator:add3351558142e18f6bbfe0b73b26c069"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a46b76bfcb1b5f1700fb3c3ebafab7106"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a46b76bfcb1b5f1700fb3c3ebafab7106">small_vector</a> ()=default</td></tr>
<tr class="memdesc:a46b76bfcb1b5f1700fb3c3ebafab7106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a46b76bfcb1b5f1700fb3c3ebafab7106">More...</a><br /></td></tr>
<tr class="separator:a46b76bfcb1b5f1700fb3c3ebafab7106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63411e310a1c3d0ef51ce1b6bd55d682"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a63411e310a1c3d0ef51ce1b6bd55d682">small_vector</a> (const <a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> &amp;other)=default</td></tr>
<tr class="memdesc:a63411e310a1c3d0ef51ce1b6bd55d682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a63411e310a1c3d0ef51ce1b6bd55d682">More...</a><br /></td></tr>
<tr class="separator:a63411e310a1c3d0ef51ce1b6bd55d682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d880278f54abf6a887abb7c6c6fe29c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a1d880278f54abf6a887abb7c6c6fe29c">small_vector</a> (<a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:a1d880278f54abf6a887abb7c6c6fe29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a1d880278f54abf6a887abb7c6c6fe29c">More...</a><br /></td></tr>
<tr class="separator:a1d880278f54abf6a887abb7c6c6fe29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114be47984094c277db1ff8cf667fd05"><td class="memTemplParams" colspan="2">template&lt;typename U , init_list_enabler&lt; U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a114be47984094c277db1ff8cf667fd05"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a114be47984094c277db1ff8cf667fd05">small_vector</a> (std::initializer_list&lt; U &gt; l)</td></tr>
<tr class="memdesc:a114be47984094c277db1ff8cf667fd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from initializer list.  <a href="#a114be47984094c277db1ff8cf667fd05">More...</a><br /></td></tr>
<tr class="separator:a114be47984094c277db1ff8cf667fd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1269fe18f8ae8f16eacec2b39e2108a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#ab1269fe18f8ae8f16eacec2b39e2108a">small_vector</a> (const <a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a> &amp;<a class="el" href="classpiranha_1_1small__vector.html#ac0caf24d4456cbc77cd73ae71ffc8f06">size</a>, const T &amp;value)</td></tr>
<tr class="memdesc:ab1269fe18f8ae8f16eacec2b39e2108a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from size and value.  <a href="#ab1269fe18f8ae8f16eacec2b39e2108a">More...</a><br /></td></tr>
<tr class="separator:ab1269fe18f8ae8f16eacec2b39e2108a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39377555e41c414e8b9ebf2eacd1b683"><td class="memItemLeft" align="right" valign="top"><a id="a39377555e41c414e8b9ebf2eacd1b683"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a39377555e41c414e8b9ebf2eacd1b683">~small_vector</a> ()=default</td></tr>
<tr class="memdesc:a39377555e41c414e8b9ebf2eacd1b683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a39377555e41c414e8b9ebf2eacd1b683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8571d6f9f81ab411e7757e6677c3dfbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a8571d6f9f81ab411e7757e6677c3dfbd">operator=</a> (const <a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> &amp;)=default</td></tr>
<tr class="memdesc:a8571d6f9f81ab411e7757e6677c3dfbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a8571d6f9f81ab411e7757e6677c3dfbd">More...</a><br /></td></tr>
<tr class="separator:a8571d6f9f81ab411e7757e6677c3dfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227288fcad44953a7e321dcefe771ab4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a227288fcad44953a7e321dcefe771ab4">operator=</a> (<a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a227288fcad44953a7e321dcefe771ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a227288fcad44953a7e321dcefe771ab4">More...</a><br /></td></tr>
<tr class="separator:a227288fcad44953a7e321dcefe771ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cfb7403872d91a8fbb79d9362aaa90"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpiranha_1_1small__vector.html#ac215fd59f6bf3421712b3936a390a69d">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a44cfb7403872d91a8fbb79d9362aaa90">operator[]</a> (const <a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a> &amp;n) const</td></tr>
<tr class="memdesc:a44cfb7403872d91a8fbb79d9362aaa90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const subscript operator.  <a href="#a44cfb7403872d91a8fbb79d9362aaa90">More...</a><br /></td></tr>
<tr class="separator:a44cfb7403872d91a8fbb79d9362aaa90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a214dff0e2d3e6106c094d3abb7857"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1small__vector.html#ac215fd59f6bf3421712b3936a390a69d">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a87a214dff0e2d3e6106c094d3abb7857">operator[]</a> (const <a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a> &amp;n)</td></tr>
<tr class="memdesc:a87a214dff0e2d3e6106c094d3abb7857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator.  <a href="#a87a214dff0e2d3e6106c094d3abb7857">More...</a><br /></td></tr>
<tr class="separator:a87a214dff0e2d3e6106c094d3abb7857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af580b317cfd9f27a4def0c90589a99ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#af580b317cfd9f27a4def0c90589a99ff">push_back</a> (const <a class="el" href="classpiranha_1_1small__vector.html#ac215fd59f6bf3421712b3936a390a69d">value_type</a> &amp;x)</td></tr>
<tr class="memdesc:af580b317cfd9f27a4def0c90589a99ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-add element at the end.  <a href="#af580b317cfd9f27a4def0c90589a99ff">More...</a><br /></td></tr>
<tr class="separator:af580b317cfd9f27a4def0c90589a99ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741d01ca755b9462a592a39b636196c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a741d01ca755b9462a592a39b636196c3">push_back</a> (<a class="el" href="classpiranha_1_1small__vector.html#ac215fd59f6bf3421712b3936a390a69d">value_type</a> &amp;&amp;x)</td></tr>
<tr class="memdesc:a741d01ca755b9462a592a39b636196c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-add element at the end.  <a href="#a741d01ca755b9462a592a39b636196c3">More...</a><br /></td></tr>
<tr class="separator:a741d01ca755b9462a592a39b636196c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743a8f8d53fcac4d7a45644fd7046372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1small__vector.html#a5a9f382f4d485161a235eaa89a1e5090">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a743a8f8d53fcac4d7a45644fd7046372">begin</a> ()</td></tr>
<tr class="memdesc:a743a8f8d53fcac4d7a45644fd7046372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable begin iterator.  <a href="#a743a8f8d53fcac4d7a45644fd7046372">More...</a><br /></td></tr>
<tr class="separator:a743a8f8d53fcac4d7a45644fd7046372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3627e88facb5f6b2ecc95f9e9ee9f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1small__vector.html#a5a9f382f4d485161a235eaa89a1e5090">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#ad3627e88facb5f6b2ecc95f9e9ee9f88">end</a> ()</td></tr>
<tr class="memdesc:ad3627e88facb5f6b2ecc95f9e9ee9f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable end iterator.  <a href="#ad3627e88facb5f6b2ecc95f9e9ee9f88">More...</a><br /></td></tr>
<tr class="separator:ad3627e88facb5f6b2ecc95f9e9ee9f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59efe2b9ca1cef09b9d5439624f6ff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1small__vector.html#add3351558142e18f6bbfe0b73b26c069">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#af59efe2b9ca1cef09b9d5439624f6ff8">begin</a> () const</td></tr>
<tr class="memdesc:af59efe2b9ca1cef09b9d5439624f6ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const begin iterator.  <a href="#af59efe2b9ca1cef09b9d5439624f6ff8">More...</a><br /></td></tr>
<tr class="separator:af59efe2b9ca1cef09b9d5439624f6ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93242b27831e37b480fa2531fa60b546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1small__vector.html#add3351558142e18f6bbfe0b73b26c069">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a93242b27831e37b480fa2531fa60b546">end</a> () const</td></tr>
<tr class="memdesc:a93242b27831e37b480fa2531fa60b546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const end iterator.  <a href="#a93242b27831e37b480fa2531fa60b546">More...</a><br /></td></tr>
<tr class="separator:a93242b27831e37b480fa2531fa60b546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0caf24d4456cbc77cd73ae71ffc8f06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#ac0caf24d4456cbc77cd73ae71ffc8f06">size</a> () const</td></tr>
<tr class="memdesc:ac0caf24d4456cbc77cd73ae71ffc8f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size.  <a href="#ac0caf24d4456cbc77cd73ae71ffc8f06">More...</a><br /></td></tr>
<tr class="separator:ac0caf24d4456cbc77cd73ae71ffc8f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cab68c125ea476e8d3f43188c58145"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#ab1cab68c125ea476e8d3f43188c58145">is_static</a> () const</td></tr>
<tr class="memdesc:ab1cab68c125ea476e8d3f43188c58145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static storage flag.  <a href="#ab1cab68c125ea476e8d3f43188c58145">More...</a><br /></td></tr>
<tr class="separator:ab1cab68c125ea476e8d3f43188c58145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e26b3ee061fc4cd8f6679a6b7dedab"><td class="memTemplParams" colspan="2">template&lt;typename U  = value_type, equality_enabler&lt; U &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa3e26b3ee061fc4cd8f6679a6b7dedab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#aa3e26b3ee061fc4cd8f6679a6b7dedab">operator==</a> (const <a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> &amp;other) const</td></tr>
<tr class="memdesc:aa3e26b3ee061fc4cd8f6679a6b7dedab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#aa3e26b3ee061fc4cd8f6679a6b7dedab">More...</a><br /></td></tr>
<tr class="separator:aa3e26b3ee061fc4cd8f6679a6b7dedab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f7babc23df2929983bd409c3a6b55b"><td class="memTemplParams" colspan="2">template&lt;typename U  = value_type, equality_enabler&lt; U &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad4f7babc23df2929983bd409c3a6b55b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#ad4f7babc23df2929983bd409c3a6b55b">operator!=</a> (const <a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> &amp;other) const</td></tr>
<tr class="memdesc:ad4f7babc23df2929983bd409c3a6b55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#ad4f7babc23df2929983bd409c3a6b55b">More...</a><br /></td></tr>
<tr class="separator:ad4f7babc23df2929983bd409c3a6b55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ce39052c3854eb06aecda9fedf61d0"><td class="memTemplParams" colspan="2">template&lt;typename U  = value_type, hash_enabler&lt; U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a08ce39052c3854eb06aecda9fedf61d0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a08ce39052c3854eb06aecda9fedf61d0">hash</a> () const</td></tr>
<tr class="memdesc:a08ce39052c3854eb06aecda9fedf61d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash method.  <a href="#a08ce39052c3854eb06aecda9fedf61d0">More...</a><br /></td></tr>
<tr class="separator:a08ce39052c3854eb06aecda9fedf61d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83814842ed55b84ce450a97107784a38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a83814842ed55b84ce450a97107784a38">empty</a> () const</td></tr>
<tr class="memdesc:a83814842ed55b84ce450a97107784a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty test.  <a href="#a83814842ed55b84ce450a97107784a38">More...</a><br /></td></tr>
<tr class="separator:a83814842ed55b84ce450a97107784a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f10384372abdc0a59e1a117d919b12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a22f10384372abdc0a59e1a117d919b12">resize</a> (const <a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a> &amp;<a class="el" href="classpiranha_1_1small__vector.html#ac0caf24d4456cbc77cd73ae71ffc8f06">size</a>)</td></tr>
<tr class="memdesc:a22f10384372abdc0a59e1a117d919b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize.  <a href="#a22f10384372abdc0a59e1a117d919b12">More...</a><br /></td></tr>
<tr class="separator:a22f10384372abdc0a59e1a117d919b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea98589f1bbf3879bdfdfda81291e8e6"><td class="memTemplParams" colspan="2">template&lt;typename U  = value_type, add_enabler&lt; U &gt;  = 0&gt; </td></tr>
<tr class="memitem:aea98589f1bbf3879bdfdfda81291e8e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#aea98589f1bbf3879bdfdfda81291e8e6">add</a> (<a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> &amp;retval, const <a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> &amp;other) const</td></tr>
<tr class="memdesc:aea98589f1bbf3879bdfdfda81291e8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector addition.  <a href="#aea98589f1bbf3879bdfdfda81291e8e6">More...</a><br /></td></tr>
<tr class="separator:aea98589f1bbf3879bdfdfda81291e8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f19e1bb5e5c372e8d95045ec5271fab"><td class="memTemplParams" colspan="2">template&lt;typename U  = value_type, sub_enabler&lt; U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2f19e1bb5e5c372e8d95045ec5271fab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a2f19e1bb5e5c372e8d95045ec5271fab">sub</a> (<a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> &amp;retval, const <a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> &amp;other) const</td></tr>
<tr class="memdesc:a2f19e1bb5e5c372e8d95045ec5271fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector subtraction.  <a href="#a2f19e1bb5e5c372e8d95045ec5271fab">More...</a><br /></td></tr>
<tr class="separator:a2f19e1bb5e5c372e8d95045ec5271fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b96d076cd98e1336d97434bc063441d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1small__vector.html#a5a9f382f4d485161a235eaa89a1e5090">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a1b96d076cd98e1336d97434bc063441d">erase</a> (<a class="el" href="classpiranha_1_1small__vector.html#add3351558142e18f6bbfe0b73b26c069">const_iterator</a> it)</td></tr>
<tr class="memdesc:a1b96d076cd98e1336d97434bc063441d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element.  <a href="#a1b96d076cd98e1336d97434bc063441d">More...</a><br /></td></tr>
<tr class="separator:a1b96d076cd98e1336d97434bc063441d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6f725c3c63c9edebca268278ebb0ab"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a>, <a class="el" href="classpiranha_1_1small__vector.html#a5a9f382f4d485161a235eaa89a1e5090">iterator</a>, <a class="el" href="classpiranha_1_1small__vector.html#a5a9f382f4d485161a235eaa89a1e5090">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#aae6f725c3c63c9edebca268278ebb0ab">size_begin_end</a> ()</td></tr>
<tr class="memdesc:aae6f725c3c63c9edebca268278ebb0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size, begin and end.  <a href="#aae6f725c3c63c9edebca268278ebb0ab">More...</a><br /></td></tr>
<tr class="separator:aae6f725c3c63c9edebca268278ebb0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49707f30895a2724863148ba1ec72ed4"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a>, <a class="el" href="classpiranha_1_1small__vector.html#add3351558142e18f6bbfe0b73b26c069">const_iterator</a>, <a class="el" href="classpiranha_1_1small__vector.html#add3351558142e18f6bbfe0b73b26c069">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a49707f30895a2724863148ba1ec72ed4">size_begin_end</a> () const</td></tr>
<tr class="memdesc:a49707f30895a2724863148ba1ec72ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size, begin and end (const version).  <a href="#a49707f30895a2724863148ba1ec72ed4">More...</a><br /></td></tr>
<tr class="separator:a49707f30895a2724863148ba1ec72ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af6e3e262e2f9173991bc3276d41db066"><td class="memItemLeft" align="right" valign="top"><a id="af6e3e262e2f9173991bc3276d41db066"></a>
static const std::decay&lt; decltype(s_storage::max_size)&gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#af6e3e262e2f9173991bc3276d41db066">max_static_size</a> = s_storage::max_size</td></tr>
<tr class="memdesc:af6e3e262e2f9173991bc3276d41db066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of elements that can be stored in static storage. <br /></td></tr>
<tr class="separator:af6e3e262e2f9173991bc3276d41db066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10df094bd0920ee176128749a78e2bd"><td class="memItemLeft" align="right" valign="top"><a id="ad10df094bd0920ee176128749a78e2bd"></a>
static const std::decay&lt; decltype(d_storage::max_size)&gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#ad10df094bd0920ee176128749a78e2bd">max_dynamic_size</a> = d_storage::max_size</td></tr>
<tr class="memdesc:ad10df094bd0920ee176128749a78e2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of elements that can be stored in dynamic storage. <br /></td></tr>
<tr class="separator:ad10df094bd0920ee176128749a78e2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f014e6e1972ea5d47cb2fa4e2b208e"><td class="memItemLeft" align="right" valign="top"><a id="a06f014e6e1972ea5d47cb2fa4e2b208e"></a>
static const <a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html#a06f014e6e1972ea5d47cb2fa4e2b208e">max_size</a> = get_max&lt;<a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a>&gt;(<a class="el" href="classpiranha_1_1small__vector.html#af6e3e262e2f9173991bc3276d41db066">max_static_size</a>, <a class="el" href="classpiranha_1_1small__vector.html#ad10df094bd0920ee176128749a78e2bd">max_dynamic_size</a>)</td></tr>
<tr class="memdesc:a06f014e6e1972ea5d47cb2fa4e2b208e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of elements that can be stored. <br /></td></tr>
<tr class="separator:a06f014e6e1972ea5d47cb2fa4e2b208e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename S = std::integral_constant&lt;std::size_t, 0u&gt;&gt;<br />
class piranha::small_vector&lt; T, S &gt;</h3>

<p>Small vector class. </p>
<p>This class is a sequence container similar to the standard <code>std::vector</code> class. The class will avoid dynamic memory allocation by using internal static storage up to a certain number of stored elements. If <code>S</code> is a zero integral constant, this number is calculated automatically (but it will always be at least 1). Otherwise, the limit number is set to <code>S::value</code>.</p>
<h2>Type requirements</h2>
<ul>
<li><code>T</code> must satisfy <a class="el" href="structpiranha_1_1is__container__element.html" title="Type trait for well-behaved container elements. ">piranha::is_container_element</a>;</li>
<li><code>S</code> must be an <code>std::integral_constant</code> of type <code>std::size_t</code>.</li>
</ul>
<h2>Exception safety guarantee</h2>
<p>Unless otherwise specified, this class provides the strong exception safety guarantee for all operations.</p>
<h2>Move semantics</h2>
<p>After a move operation, the container will be empty. </p>

<p class="definition">Definition at line <a class="el" href="small__vector__fwd_8hpp_source.html#l00045">45</a> of file <a class="el" href="small__vector__fwd_8hpp_source.html">small_vector_fwd.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a46b76bfcb1b5f1700fb3c3ebafab7106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b76bfcb1b5f1700fb3c3ebafab7106">&#9670;&nbsp;</a></span>small_vector() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::<a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Will initialise an empty vector with internal static storage. </p>

</div>
</div>
<a id="a63411e310a1c3d0ef51ce1b6bd55d682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63411e310a1c3d0ef51ce1b6bd55d682">&#9670;&nbsp;</a></span>small_vector() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::<a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1small__vector.html">small_vector</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The storage type after successful construction will be the same of <code>other</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>construction argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>in case of memory allocation errors. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor of <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d880278f54abf6a887abb7c6c6fe29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d880278f54abf6a887abb7c6c6fe29c">&#9670;&nbsp;</a></span>small_vector() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::<a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1small__vector.html">small_vector</a>&lt; T, S &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>The storage type after successful construction will be the same of <code>other</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>construction argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a114be47984094c277db1ff8cf667fd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114be47984094c277db1ff8cf667fd05">&#9670;&nbsp;</a></span>small_vector() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U , init_list_enabler&lt; U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::<a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from initializer list. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor is enabled only if <code>U</code> is safely convertible to <code>T</code>.</dd></dl>
<p>The elements of <code>l</code> will be added to a default-constructed object, after conversion to <code>T</code> via <a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>list that will be used for initialisation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1small__vector.html#af580b317cfd9f27a4def0c90589a99ff" title="Copy-add element at the end. ">push_back()</a> or by <a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00676">676</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="ab1269fe18f8ae8f16eacec2b39e2108a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1269fe18f8ae8f16eacec2b39e2108a">&#9670;&nbsp;</a></span>small_vector() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::<a class="el" href="classpiranha_1_1small__vector.html">small_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from size and value. </p>
<p>This constructor will initialise a vector containing <code>size</code> copies of <code>value</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the desired vector size. </td></tr>
    <tr><td class="paramname">value</td><td>the value used to initialise all the elements of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1small__vector.html#af580b317cfd9f27a4def0c90589a99ff" title="Copy-add element at the end. ">push_back()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00692">692</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aea98589f1bbf3879bdfdfda81291e8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea98589f1bbf3879bdfdfda81291e8e6">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U  = value_type, add_enabler&lt; U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1small__vector.html">small_vector</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1small__vector.html">small_vector</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector addition. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <code>value_type</code> satisfies <a class="el" href="classpiranha_1_1has__add3.html" title="Detect piranha::math::add3(). ">piranha::has_add3</a>.</dd></dl>
<p>Will compute the element-wise addition of <code>this</code> and <code>other</code> via <a class="el" href="namespacepiranha_1_1math.html#ae11fd337327c260a957de8b40c2b8bfc" title="Ternary addition. ">piranha::math::add3()</a>, storing the result in <code>retval</code>. In face of exceptions during the addition of two elements, <code>retval</code> will be left in an unspecified but valid state, provided that <a class="el" href="namespacepiranha_1_1math.html#ae11fd337327c260a957de8b40c2b8bfc" title="Ternary addition. ">piranha::math::add3()</a> offers the basic exception safety guarantee.</p>
<p><code>this</code>, <code>retval</code> and/or <code>other</code> are allowed to be the same object, provided that <a class="el" href="namespacepiranha_1_1math.html#ae11fd337327c260a957de8b40c2b8bfc" title="Ternary addition. ">piranha::math::add3()</a> also supports this type of usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">retval</td><td>result of the addition. </td></tr>
    <tr><td class="paramname">other</td><td>argument for the addition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the sizes of <code>this</code> and <code>other</code> do not coincide. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1small__vector.html#a22f10384372abdc0a59e1a117d919b12" title="Resize. ">resize()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#ae11fd337327c260a957de8b40c2b8bfc" title="Ternary addition. ">piranha::math::add3()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00967">967</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="a743a8f8d53fcac4d7a45644fd7046372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743a8f8d53fcac4d7a45644fd7046372">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html#a5a9f382f4d485161a235eaa89a1e5090">iterator</a> <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutable begin iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the beginning of the vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00761">761</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="af59efe2b9ca1cef09b9d5439624f6ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59efe2b9ca1cef09b9d5439624f6ff8">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html#add3351558142e18f6bbfe0b73b26c069">const_iterator</a> <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const begin iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the beginning of the vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00785">785</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="a83814842ed55b84ce450a97107784a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83814842ed55b84ce450a97107784a38">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty test. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the size of the container is zero, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00896">896</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="ad3627e88facb5f6b2ecc95f9e9ee9f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3627e88facb5f6b2ecc95f9e9ee9f88">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html#a5a9f382f4d485161a235eaa89a1e5090">iterator</a> <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutable end iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the end of the vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00773">773</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="a93242b27831e37b480fa2531fa60b546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93242b27831e37b480fa2531fa60b546">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html#add3351558142e18f6bbfe0b73b26c069">const_iterator</a> <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const end iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the end of the vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00797">797</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="a1b96d076cd98e1336d97434bc063441d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b96d076cd98e1336d97434bc063441d">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html#a5a9f382f4d485161a235eaa89a1e5090">iterator</a> <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1small__vector.html#add3351558142e18f6bbfe0b73b26c069">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element. </p>
<p>This method will erase the element to which <code>it</code> points. The return value will be the iterator following the erased element (which will be the end iterator if <code>it</code> points to the last element of the vector).</p>
<p><code>it</code> must be a valid iterator to an element in <code>this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator to the element of <code>this</code> to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator following the erased element. </dd></dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l01027">1027</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="a08ce39052c3854eb06aecda9fedf61d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ce39052c3854eb06aecda9fedf61d0">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U  = value_type, hash_enabler&lt; U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash method. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <code>value_type</code> satisfies <a class="el" href="classpiranha_1_1is__hashable.html" title="Hashable type trait. ">piranha::is_hashable</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a hash value for <code>this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00884">884</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="ab1cab68c125ea476e8d3f43188c58145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cab68c125ea476e8d3f43188c58145">&#9670;&nbsp;</a></span>is_static()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::is_static </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static storage flag. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the storage being used is the static one, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00821">821</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="ad4f7babc23df2929983bd409c3a6b55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f7babc23df2929983bd409c3a6b55b">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U  = value_type, equality_enabler&lt; U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1small__vector.html">small_vector</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <code>T</code> is equality comparable.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>argument for the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the opposite of <a class="el" href="classpiranha_1_1small__vector.html#aa3e26b3ee061fc4cd8f6679a6b7dedab" title="Equality operator. ">operator==()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1small__vector.html#aa3e26b3ee061fc4cd8f6679a6b7dedab" title="Equality operator. ">operator==()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00872">872</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="a8571d6f9f81ab411e7757e6677c3dfbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8571d6f9f81ab411e7757e6677c3dfbd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html">small_vector</a>&amp; <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1small__vector.html">small_vector</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a227288fcad44953a7e321dcefe771ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227288fcad44953a7e321dcefe771ab4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html">small_vector</a>&amp; <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1small__vector.html">small_vector</a>&lt; T, S &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>. </dd></dl>

</div>
</div>
<a id="aa3e26b3ee061fc4cd8f6679a6b7dedab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e26b3ee061fc4cd8f6679a6b7dedab">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U  = value_type, equality_enabler&lt; U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1small__vector.html">small_vector</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <code>T</code> is equality comparable.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>argument for the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the sizes of <code>this</code> and <code>other</code> coincide and the element-wise comparison of the stored objects is <code>true</code>, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the equality operator of <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00838">838</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="a44cfb7403872d91a8fbb79d9362aaa90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cfb7403872d91a8fbb79d9362aaa90">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpiranha_1_1small__vector.html#ac215fd59f6bf3421712b3936a390a69d">value_type</a>&amp; <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const subscript operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>index of the element to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const reference to the <code>n</code>-th element of the vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00718">718</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="a87a214dff0e2d3e6106c094d3abb7857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a214dff0e2d3e6106c094d3abb7857">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html#ac215fd59f6bf3421712b3936a390a69d">value_type</a>&amp; <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>index of the element to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the <code>n</code>-th element of the vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00728">728</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="af580b317cfd9f27a4def0c90589a99ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af580b317cfd9f27a4def0c90589a99ff">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1small__vector.html#ac215fd59f6bf3421712b3936a390a69d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-add element at the end. </p>
<p><b>NOTE</b>: if <code>x</code> is an element of the vector, the behaviour will be undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object that will be added at the end of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>in case of memory allocation errors or if the size limit is exceeded. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor of <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00741">741</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="a741d01ca755b9462a592a39b636196c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741d01ca755b9462a592a39b636196c3">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1small__vector.html#ac215fd59f6bf3421712b3936a390a69d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-add element at the end. </p>
<p><b>NOTE</b>: if <code>x</code> is an element of the vector, the behaviour will be undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object that will be added at the end of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>in case of memory allocation errors or if the size limit is exceeded. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00753">753</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="a22f10384372abdc0a59e1a117d919b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f10384372abdc0a59e1a117d919b12">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize. </p>
<p>Resize the vector to <code>size</code>. Elements in excess will be destroyed, new elements will be value-initialised and placed at the end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>new size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>in case of memory allocation errors or if the size limit is exceeded. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the default constructor of <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00914">914</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="ac0caf24d4456cbc77cd73ae71ffc8f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0caf24d4456cbc77cd73ae71ffc8f06">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a> <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size. </p>
<dl class="section return"><dt>Returns</dt><dd>number of elements stored in the vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l00809">809</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="aae6f725c3c63c9edebca268278ebb0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6f725c3c63c9edebca268278ebb0ab">&#9670;&nbsp;</a></span>size_begin_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a>, <a class="el" href="classpiranha_1_1small__vector.html#a5a9f382f4d485161a235eaa89a1e5090">iterator</a>, <a class="el" href="classpiranha_1_1small__vector.html#a5a9f382f4d485161a235eaa89a1e5090">iterator</a>&gt; <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::size_begin_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size, begin and end. </p>
<dl class="section return"><dt>Returns</dt><dd>a tuple containing the size and the begin and the end iterators. </dd></dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l01039">1039</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="a49707f30895a2724863148ba1ec72ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49707f30895a2724863148ba1ec72ed4">&#9670;&nbsp;</a></span>size_begin_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classpiranha_1_1small__vector.html#a9b9eb977b50c3b72c0a3035ee6d0a429">size_type</a>, <a class="el" href="classpiranha_1_1small__vector.html#add3351558142e18f6bbfe0b73b26c069">const_iterator</a>, <a class="el" href="classpiranha_1_1small__vector.html#add3351558142e18f6bbfe0b73b26c069">const_iterator</a>&gt; <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::size_begin_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size, begin and end (const version). </p>
<dl class="section return"><dt>Returns</dt><dd>a tuple containing the size and the begin and the end const iterators. </dd></dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l01051">1051</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<a id="a2f19e1bb5e5c372e8d95045ec5271fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f19e1bb5e5c372e8d95045ec5271fab">&#9670;&nbsp;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = std::integral_constant&lt;std::size_t, 0u&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U  = value_type, sub_enabler&lt; U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1small__vector.html">piranha::small_vector</a>&lt; T, S &gt;::sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1small__vector.html">small_vector</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1small__vector.html">small_vector</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector subtraction. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <code>value_type</code> satisfies <a class="el" href="classpiranha_1_1has__sub3.html" title="Detect piranha::math::sub3(). ">piranha::has_sub3</a>.</dd></dl>
<p>Will compute the element-wise subtraction of <code>this</code> and <code>other</code> via <a class="el" href="namespacepiranha_1_1math.html#a47faea1d9992a1d5d8f8a02cb535c47c" title="Ternary subtraction. ">piranha::math::sub3()</a>, storing the result in <code>retval</code>. In face of exceptions during the subtraction of two elements, <code>retval</code> will be left in an unspecified but valid state, provided that <a class="el" href="namespacepiranha_1_1math.html#a47faea1d9992a1d5d8f8a02cb535c47c" title="Ternary subtraction. ">piranha::math::sub3()</a> offers the basic exception safety guarantee.</p>
<p><code>this</code>, <code>retval</code> and/or <code>other</code> are allowed to be the same object, provided that <a class="el" href="namespacepiranha_1_1math.html#a47faea1d9992a1d5d8f8a02cb535c47c" title="Ternary subtraction. ">piranha::math::sub3()</a> also supports this type of usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">retval</td><td>result of the subtraction. </td></tr>
    <tr><td class="paramname">other</td><td>argument for the subtraction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the sizes of <code>this</code> and <code>other</code> do not coincide. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1small__vector.html#a22f10384372abdc0a59e1a117d919b12" title="Resize. ">resize()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a47faea1d9992a1d5d8f8a02cb535c47c" title="Ternary subtraction. ">piranha::math::sub3()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="small__vector_8hpp_source.html#l01003">1003</a> of file <a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="small__vector__fwd_8hpp_source.html">small_vector_fwd.hpp</a></li>
<li><a class="el" href="small__vector_8hpp_source.html">small_vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
