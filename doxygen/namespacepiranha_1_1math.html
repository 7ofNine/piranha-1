<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>piranha: piranha::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepiranha.html">piranha</a></li><li class="navelem"><a class="el" href="namespacepiranha_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">piranha::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Math namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1abs__impl.html">abs_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a9fad3b6f8a6178867eeac66f69531397" title="Absolute value. ">piranha::math::abs()</a>.  <a href="structpiranha_1_1math_1_1abs__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1abs__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html">abs_impl&lt; mp_integer&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a9fad3b6f8a6178867eeac66f69531397" title="Absolute value. ">piranha::math::abs()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1abs__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1abs__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html">abs_impl&lt; mp_rational&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a9fad3b6f8a6178867eeac66f69531397" title="Absolute value. ">piranha::math::abs()</a> for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1abs__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1abs__impl_3_01_t_00_01detail_1_1abs__arith__enabler_3_01_t_01_4_01_4.html">abs_impl&lt; T, detail::abs_arith_enabler&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a9fad3b6f8a6178867eeac66f69531397" title="Absolute value. ">piranha::math::abs()</a> functor for signed and unsigned integer types, and floating-point types.  <a href="structpiranha_1_1math_1_1abs__impl_3_01_t_00_01detail_1_1abs__arith__enabler_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1abs__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_64b42996f6b094c3e973d702c791c900.html">abs_impl&lt; T, typename std::enable_if&lt; std::is_same&lt; T, real &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a9fad3b6f8a6178867eeac66f69531397" title="Absolute value. ">piranha::math::abs()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1abs__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_64b42996f6b094c3e973d702c791c900.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1add3__impl.html">add3_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#ae11fd337327c260a957de8b40c2b8bfc" title="Ternary addition. ">piranha::math::add3()</a>.  <a href="structpiranha_1_1math_1_1add3__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1add3__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html">add3_impl&lt; mp_integer&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#ae11fd337327c260a957de8b40c2b8bfc" title="Ternary addition. ">piranha::math::add3()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1add3__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1add3__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__inteec72cb2375cbb0b7786ed7aab275bb09.html">add3_impl&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ae11fd337327c260a957de8b40c2b8bfc" title="Ternary addition. ">piranha::math::add3()</a> functor for integral types.  <a href="structpiranha_1_1math_1_1add3__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__inteec72cb2375cbb0b7786ed7aab275bb09.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1binomial__impl.html">binomial_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a755a440fe280d7ee38347ce860e8484b" title="Generalised binomial coefficient. ">piranha::math::binomial()</a>.  <a href="structpiranha_1_1math_1_1binomial__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01binomial__fp__arith__enabler_3_01_t_00_01_u_01_4_01_4.html">binomial_impl&lt; T, U, binomial_fp_arith_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a755a440fe280d7ee38347ce860e8484b" title="Generalised binomial coefficient. ">piranha::math::binomial()</a> for floating-point and arithmetic arguments.  <a href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01binomial__fp__arith__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01detail_1_1real__binomial__enabler_3_01_t_00_01_u_01_4_01_4.html">binomial_impl&lt; T, U, detail::real_binomial_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a755a440fe280d7ee38347ce860e8484b" title="Generalised binomial coefficient. ">piranha::math::binomial()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01detail_1_1real__binomial__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01integer__binomial__enabler_3_01_t_00_01_u_01_4_01_4.html">binomial_impl&lt; T, U, integer_binomial_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a755a440fe280d7ee38347ce860e8484b" title="Generalised binomial coefficient. ">piranha::math::binomial()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01integer__binomial__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01math__rational__binomial__enabler_3_01_t_00_01_u_01_4_01_4.html">binomial_impl&lt; T, U, math_rational_binomial_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a755a440fe280d7ee38347ce860e8484b" title="Generalised binomial coefficient. ">piranha::math::binomial()</a> for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01math__rational__binomial__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl.html">cos_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#ae72b05770e0a4508814e7506f8a84e6f" title="Cosine. ">piranha::math::cos()</a>.  <a href="structpiranha_1_1math_1_1cos__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html">cos_impl&lt; mp_integer&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#ae72b05770e0a4508814e7506f8a84e6f" title="Cosine. ">piranha::math::cos()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1cos__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html">cos_impl&lt; mp_rational&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#ae72b05770e0a4508814e7506f8a84e6f" title="Cosine. ">piranha::math::cos()</a> for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1cos__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl_3_01_series_00_01detail_1_1series__cos__enabler_3_01_series_01_4_01_4.html">cos_impl&lt; Series, detail::series_cos_enabler&lt; Series &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ae72b05770e0a4508814e7506f8a84e6f" title="Cosine. ">piranha::math::cos()</a> functor for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>.  <a href="structpiranha_1_1math_1_1cos__impl_3_01_series_00_01detail_1_1series__cos__enabler_3_01_series_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__floatf4f236ad8bf40cd7845fb14616d6f642.html">cos_impl&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ae72b05770e0a4508814e7506f8a84e6f" title="Cosine. ">piranha::math::cos()</a> functor for floating-point types.  <a href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__floatf4f236ad8bf40cd7845fb14616d6f642.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__integ48a769cf6d1a2d076c37cd9e814c5a74.html">cos_impl&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ae72b05770e0a4508814e7506f8a84e6f" title="Cosine. ">piranha::math::cos()</a> functor for integral types.  <a href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__integ48a769cf6d1a2d076c37cd9e814c5a74.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_94693c6a6e2c113fa8c70612155aebe1.html">cos_impl&lt; T, typename std::enable_if&lt; std::is_same&lt; T, real &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ae72b05770e0a4508814e7506f8a84e6f" title="Cosine. ">piranha::math::cos()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_94693c6a6e2c113fa8c70612155aebe1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1degree__impl.html">degree_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a934cd86d1c6bd2c1f40d307a093010bd" title="Total degree. ">piranha::math::degree()</a>.  <a href="structpiranha_1_1math_1_1degree__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1degree__impl_3_01_series_00_01ps__degree__enabler_3_01_series_01_4_01_4.html">degree_impl&lt; Series, ps_degree_enabler&lt; Series &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a934cd86d1c6bd2c1f40d307a093010bd" title="Total degree. ">piranha::math::degree()</a> functor for instances of <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a>.  <a href="structpiranha_1_1math_1_1degree__impl_3_01_series_00_01ps__degree__enabler_3_01_series_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1div3__impl.html">div3_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#ab0b30a828ae8739cca5f4f492a8a4090" title="Ternary division. ">piranha::math::div3()</a>.  <a href="structpiranha_1_1math_1_1div3__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1div3__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html">div3_impl&lt; mp_integer&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#ab0b30a828ae8739cca5f4f492a8a4090" title="Ternary division. ">piranha::math::div3()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1div3__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1div3__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__inte21dc6168cc98f654bb07344e656952a7.html">div3_impl&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ab0b30a828ae8739cca5f4f492a8a4090" title="Ternary division. ">piranha::math::div3()</a> functor for integral types.  <a href="structpiranha_1_1math_1_1div3__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__inte21dc6168cc98f654bb07344e656952a7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1evaluate__impl.html">evaluate_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a7b7051ad0e4cd2e7373bb71747e2116a" title="Evaluation. ">piranha::math::evaluate()</a>.  <a href="structpiranha_1_1math_1_1evaluate__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1evaluate__impl_3_01_series_00_01_t_00_01typename_01std_1_1enable__if_3_690d7ddd2bdd98656327e649cf5b52da.html">evaluate_impl&lt; Series, T, typename std::enable_if&lt; is_series&lt; Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a7b7051ad0e4cd2e7373bb71747e2116a" title="Evaluation. ">piranha::math::evaluate()</a> functor for series types.  <a href="structpiranha_1_1math_1_1evaluate__impl_3_01_series_00_01_t_00_01typename_01std_1_1enable__if_3_690d7ddd2bdd98656327e649cf5b52da.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1gcd3__impl.html">gcd3_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#aed326292eae1eeef5a46fd472a6e3165" title="Ternary GCD. ">piranha::math::gcd3()</a>.  <a href="structpiranha_1_1math_1_1gcd3__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1gcd3__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html">gcd3_impl&lt; mp_integer&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#aed326292eae1eeef5a46fd472a6e3165" title="Ternary GCD. ">piranha::math::gcd3()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1gcd3__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1gcd3__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__inte9290cbb467ef29e73838541794edbf94.html">gcd3_impl&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#aed326292eae1eeef5a46fd472a6e3165" title="Ternary GCD. ">piranha::math::gcd3()</a> functor for integral types.  <a href="structpiranha_1_1math_1_1gcd3__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__inte9290cbb467ef29e73838541794edbf94.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1gcd__impl.html">gcd_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a1c4d8d79c21d909f852c4678121bcad5" title="GCD. ">piranha::math::gcd()</a>.  <a href="structpiranha_1_1math_1_1gcd__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1gcd__impl_3_01_t_00_01_u_00_01math__mp__integer__gcd__enabler_3_01_t_00_01_u_01_4_01_4.html">gcd_impl&lt; T, U, math_mp_integer_gcd_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a1c4d8d79c21d909f852c4678121bcad5" title="GCD. ">piranha::math::gcd()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1gcd__impl_3_01_t_00_01_u_00_01math__mp__integer__gcd__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1gcd__impl_3_01_t_00_01_u_00_01typename_01std_1_1enable__if_3_01std_1_1i966278f0bd674b55ba6e4db6232660ac.html">gcd_impl&lt; T, U, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_integral&lt; U &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="namespacepiranha_1_1math.html#a1c4d8d79c21d909f852c4678121bcad5" title="GCD. ">piranha::math::gcd()</a> for integral types.  <a href="structpiranha_1_1math_1_1gcd__impl_3_01_t_00_01_u_00_01typename_01std_1_1enable__if_3_01std_1_1i966278f0bd674b55ba6e4db6232660ac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1integrate__impl.html">integrate_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#ad7f46a0b6a203a29e27aefd1a196edc6" title="Integration. ">piranha::math::integrate()</a>.  <a href="structpiranha_1_1math_1_1integrate__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1integrate__impl_3_01_series_00_01detail_1_1series__integrate__enabler_3_01_series_01_4_01_4.html">integrate_impl&lt; Series, detail::series_integrate_enabler&lt; Series &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ad7f46a0b6a203a29e27aefd1a196edc6" title="Integration. ">piranha::math::integrate()</a> functor for series types.  <a href="structpiranha_1_1math_1_1integrate__impl_3_01_series_00_01detail_1_1series__integrate__enabler_3_01_series_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1invert__impl.html">invert_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#ad1e5e54357d0937d3e42780f03e2e7df" title="Compute the inverse. ">piranha::math::invert()</a>.  <a href="structpiranha_1_1math_1_1invert__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1invert__impl_3_01_series_00_01detail_1_1series__invert__enabler_3_01_series_01_4_01_4.html">invert_impl&lt; Series, detail::series_invert_enabler&lt; Series &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ad1e5e54357d0937d3e42780f03e2e7df" title="Compute the inverse. ">piranha::math::invert()</a> functor for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>.  <a href="structpiranha_1_1math_1_1invert__impl_3_01_series_00_01detail_1_1series__invert__enabler_3_01_series_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1ipow__subs__impl.html">ipow_subs_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a66b150f5b9d8168854f5a0a5f7ad278f" title="Substitution of integral power. ">piranha::math::ipow_subs()</a>.  <a href="structpiranha_1_1math_1_1ipow__subs__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1ipow__subs__impl_3_01_series_00_01_t_00_01detail_1_1ipow__subs__impl__i05512f754a96e06f7f436d1e41d65424.html">ipow_subs_impl&lt; Series, T, detail::ipow_subs_impl_ipow_subs_series_enabler&lt; Series, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="structpiranha_1_1math_1_1ipow__subs__impl.html" title="Default functor for the implementation of piranha::math::ipow_subs(). ">piranha::math::ipow_subs_impl</a> functor for instances of <a class="el" href="classpiranha_1_1ipow__substitutable__series.html" title="Toolbox for series suitable for integral power substitution. ">piranha::ipow_substitutable_series</a>.  <a href="structpiranha_1_1math_1_1ipow__subs__impl_3_01_series_00_01_t_00_01detail_1_1ipow__subs__impl__i05512f754a96e06f7f436d1e41d65424.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__unitary__impl.html">is_unitary_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a339e411baab25b72946944a87a04df80" title="Unitary test. ">piranha::math::is_unitary()</a>.  <a href="structpiranha_1_1math_1_1is__unitary__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__unitary__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html">is_unitary_impl&lt; mp_integer&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a339e411baab25b72946944a87a04df80" title="Unitary test. ">piranha::math::is_unitary()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1is__unitary__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__unitary__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html">is_unitary_impl&lt; mp_rational&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a339e411baab25b72946944a87a04df80" title="Unitary test. ">piranha::math::is_unitary()</a> for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1is__unitary__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__zero__impl.html">is_zero_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a>.  <a href="structpiranha_1_1math_1_1is__zero__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__zero__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html">is_zero_impl&lt; mp_integer&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1is__zero__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__zero__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html">is_zero_impl&lt; mp_rational&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a> for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1is__zero__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__zero__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__sedde2b95e1c3c348c590a053259c997ba.html">is_zero_impl&lt; Series, typename std::enable_if&lt; is_series&lt; Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a> functor for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>.  <a href="structpiranha_1_1math_1_1is__zero__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__sedde2b95e1c3c348c590a053259c997ba.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__zero__impl_3_01_t_00_01detail_1_1math__is__zero__std__complex__enabler_3_01_t_01_4_01_4.html">is_zero_impl&lt; T, detail::math_is_zero_std_complex_enabler&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a> functor for C++ complex floating-point types.  <a href="structpiranha_1_1math_1_1is__zero__impl_3_01_t_00_01detail_1_1math__is__zero__std__complex__enabler_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__zero__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__0f5293ccea14433d6d670df85edcd144.html">is_zero_impl&lt; T, typename std::enable_if&lt; std::is_same&lt; T, real &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1is__zero__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__0f5293ccea14433d6d670df85edcd144.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1math_1_1lambdified.html">lambdified</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor interface for <a class="el" href="namespacepiranha_1_1math.html#a7b7051ad0e4cd2e7373bb71747e2116a" title="Evaluation. ">piranha::math::evaluate()</a>.  <a href="classpiranha_1_1math_1_1lambdified.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html">ldegree_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a05ad27dfa7dce556237f837c5c317890" title="Total low degree. ">piranha::math::ldegree()</a>.  <a href="structpiranha_1_1math_1_1ldegree__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1ldegree__impl_3_01_series_00_01ps__degree__enabler_3_01_series_01_4_01_4.html">ldegree_impl&lt; Series, ps_degree_enabler&lt; Series &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a05ad27dfa7dce556237f837c5c317890" title="Total low degree. ">piranha::math::ldegree()</a> functor for instances of <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a>.  <a href="structpiranha_1_1math_1_1ldegree__impl_3_01_series_00_01ps__degree__enabler_3_01_series_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1mul3__impl.html">mul3_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a4e861376c8a922cae01bcd27ee757d39" title="Ternary multiplication. ">piranha::math::mul3()</a>.  <a href="structpiranha_1_1math_1_1mul3__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1mul3__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html">mul3_impl&lt; mp_integer&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a4e861376c8a922cae01bcd27ee757d39" title="Ternary multiplication. ">piranha::math::mul3()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1mul3__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1mul3__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__inte9965c0455e21c2cda692411cd3cafb46.html">mul3_impl&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a4e861376c8a922cae01bcd27ee757d39" title="Ternary multiplication. ">piranha::math::mul3()</a> functor for integral types.  <a href="structpiranha_1_1math_1_1mul3__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__inte9965c0455e21c2cda692411cd3cafb46.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1multiply__accumulate__impl.html">multiply_accumulate_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#ad3b85fa643adb089c7980693221a566c" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>.  <a href="structpiranha_1_1math_1_1multiply__accumulate__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1multiply__accumulate__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html">multiply_accumulate_impl&lt; mp_integer&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#ad3b85fa643adb089c7980693221a566c" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1multiply__accumulate__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1multiply__accumulate__impl_3_01real_01_4.html">multiply_accumulate_impl&lt; real &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#ad3b85fa643adb089c7980693221a566c" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a> for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1multiply__accumulate__impl_3_01real_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1negate__impl.html">negate_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a>.  <a href="structpiranha_1_1math_1_1negate__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1negate__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html">negate_impl&lt; mp_integer&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1negate__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1negate__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html">negate_impl&lt; mp_rational&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a> for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1negate__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1negate__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01is__series_3_961a47b4cbfa205db4994c14d12bdfe4.html">negate_impl&lt; T, typename std::enable_if&lt; is_series&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a> functor for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>.  <a href="structpiranha_1_1math_1_1negate__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01is__series_3_961a47b4cbfa205db4994c14d12bdfe4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1negate__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__sa0c299022750663470c1226628bce710f.html">negate_impl&lt; T, typename std::enable_if&lt; std::is_same&lt; T, real &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1negate__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__sa0c299022750663470c1226628bce710f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1partial__impl.html">partial_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a>.  <a href="structpiranha_1_1math_1_1partial__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1partial__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html">partial_impl&lt; mp_integer&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1partial__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1partial__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html">partial_impl&lt; mp_rational&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a> for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1partial__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1partial__impl_3_01_series_00_01detail_1_1series__partial__enabler_3_01_series_01_4_01_4.html">partial_impl&lt; Series, detail::series_partial_enabler&lt; Series &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a> functor for series types.  <a href="structpiranha_1_1math_1_1partial__impl_3_01_series_00_01detail_1_1series__partial__enabler_3_01_series_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1partial__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__a932a86beb58173e9e98ed77b68c78e2b.html">partial_impl&lt; T, typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a> functor for arithmetic types.  <a href="structpiranha_1_1math_1_1partial__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__a932a86beb58173e9e98ed77b68c78e2b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1partial__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__s84a8d9181bfd7f11229ba677189d6635.html">partial_impl&lt; T, typename std::enable_if&lt; std::is_same&lt; T, real &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1partial__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__s84a8d9181bfd7f11229ba677189d6635.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1pow__impl.html">pow_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a38c4927a813897b54020e9e8d6a08a13" title="Exponentiation. ">piranha::math::pow()</a>.  <a href="structpiranha_1_1math_1_1pow__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1pow__impl_3_01_series_00_01_t_00_01pow__series__enabler_3_01_series_00_01_t_01_4_01_4.html">pow_impl&lt; Series, T, pow_series_enabler&lt; Series, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a38c4927a813897b54020e9e8d6a08a13" title="Exponentiation. ">piranha::math::pow()</a> functor for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>.  <a href="structpiranha_1_1math_1_1pow__impl_3_01_series_00_01_t_00_01pow__series__enabler_3_01_series_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01detail_1_1real__pow__enabler_3_01_t_00_01_u_01_4_01_4.html">pow_impl&lt; T, U, detail::real_pow_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a38c4927a813897b54020e9e8d6a08a13" title="Exponentiation. ">piranha::math::pow()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01detail_1_1real__pow__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01integer__pow__enabler_3_01_t_00_01_u_01_4_01_4.html">pow_impl&lt; T, U, integer_pow_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a38c4927a813897b54020e9e8d6a08a13" title="Exponentiation. ">piranha::math::pow()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a> and integral types.  <a href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01integer__pow__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01math__rational__pow__enabler_3_01_t_00_01_u_01_4_01_4.html">pow_impl&lt; T, U, math_rational_pow_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a38c4927a813897b54020e9e8d6a08a13" title="Exponentiation. ">piranha::math::pow()</a> for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01math__rational__pow__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01pow__fp__arith__enabler_3_01_t_00_01_u_01_4_01_4.html">pow_impl&lt; T, U, pow_fp_arith_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a38c4927a813897b54020e9e8d6a08a13" title="Exponentiation. ">piranha::math::pow()</a> for arithmetic and floating-point types.  <a href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01pow__fp__arith__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl.html">sin_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a8c98a78b13de3619ba578d2afe606209" title="Sine. ">piranha::math::sin()</a>.  <a href="structpiranha_1_1math_1_1sin__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html">sin_impl&lt; mp_integer&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a8c98a78b13de3619ba578d2afe606209" title="Sine. ">piranha::math::sin()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1sin__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html">sin_impl&lt; mp_rational&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a8c98a78b13de3619ba578d2afe606209" title="Sine. ">piranha::math::sin()</a> for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1sin__impl_3_01mp__rational_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl_3_01_series_00_01detail_1_1series__sin__enabler_3_01_series_01_4_01_4.html">sin_impl&lt; Series, detail::series_sin_enabler&lt; Series &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a8c98a78b13de3619ba578d2afe606209" title="Sine. ">piranha::math::sin()</a> functor for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>.  <a href="structpiranha_1_1math_1_1sin__impl_3_01_series_00_01detail_1_1series__sin__enabler_3_01_series_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__float7cae8112752e060a2327e5b460d34870.html">sin_impl&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a8c98a78b13de3619ba578d2afe606209" title="Sine. ">piranha::math::sin()</a> functor for floating-point types.  <a href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__float7cae8112752e060a2327e5b460d34870.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__integ49b44ca1249b78a6db0acdaca721d670.html">sin_impl&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a8c98a78b13de3619ba578d2afe606209" title="Sine. ">piranha::math::sin()</a> functor for integral types.  <a href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__integ49b44ca1249b78a6db0acdaca721d670.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_3232b8e745899f431b03676fbfb865b4.html">sin_impl&lt; T, typename std::enable_if&lt; std::is_same&lt; T, real &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a8c98a78b13de3619ba578d2afe606209" title="Sine. ">piranha::math::sin()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_3232b8e745899f431b03676fbfb865b4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sub3__impl.html">sub3_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a47faea1d9992a1d5d8f8a02cb535c47c" title="Ternary subtraction. ">piranha::math::sub3()</a>.  <a href="structpiranha_1_1math_1_1sub3__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sub3__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html">sub3_impl&lt; mp_integer&lt; SSize &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a47faea1d9992a1d5d8f8a02cb535c47c" title="Ternary subtraction. ">piranha::math::sub3()</a> for <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180" title="Alias for mppp::mp_integer. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1sub3__impl_3_01mp__integer_3_01_s_size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sub3__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__inteac30227b814b28fc04ccb3ea49aa31c5.html">sub3_impl&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a47faea1d9992a1d5d8f8a02cb535c47c" title="Ternary subtraction. ">piranha::math::sub3()</a> functor for integral types.  <a href="structpiranha_1_1math_1_1sub3__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__inteac30227b814b28fc04ccb3ea49aa31c5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1subs__impl.html">subs_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#abd7b607dc1e19d28a2f8bd601e6916c7" title="Substitution. ">piranha::math::subs()</a>.  <a href="structpiranha_1_1math_1_1subs__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1subs__impl_3_01_series_00_01_t_00_01detail_1_1subs__impl__subs__series_6dd9288dcb2ac77e6637b29f9090c18e.html">subs_impl&lt; Series, T, detail::subs_impl_subs_series_enabler&lt; Series, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="structpiranha_1_1math_1_1subs__impl.html" title="Default functor for the implementation of piranha::math::subs(). ">piranha::math::subs_impl</a> functor for instances of <a class="el" href="classpiranha_1_1substitutable__series.html" title="Toolbox for substitutable series. ">piranha::substitutable_series</a>.  <a href="structpiranha_1_1math_1_1subs__impl_3_01_series_00_01_t_00_01detail_1_1subs__impl__subs__series_6dd9288dcb2ac77e6637b29f9090c18e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html">t_degree_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a9cb790b56c7e9e146af38442d0aa21e7" title="Total trigonometric degree. ">piranha::math::t_degree()</a>.  <a href="structpiranha_1_1math_1_1t__degree__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__degree__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01std_18be94f7a73e2285d700806a20f36ef45.html">t_degree_impl&lt; Series, typename std::enable_if&lt; std::is_base_of&lt; detail::trigonometric_series_tag, Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a9cb790b56c7e9e146af38442d0aa21e7" title="Total trigonometric degree. ">piranha::math::t_degree()</a> functor for instances of <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a>.  <a href="structpiranha_1_1math_1_1t__degree__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01std_18be94f7a73e2285d700806a20f36ef45.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html">t_ldegree_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#ad2b8b1f80aee0a381281198ff64365cf" title="Total trigonometric low degree. ">piranha::math::t_ldegree()</a>.  <a href="structpiranha_1_1math_1_1t__ldegree__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01std_2cb7021c0adcbf52a23f4f54c80a10b0.html">t_ldegree_impl&lt; Series, typename std::enable_if&lt; std::is_base_of&lt; detail::trigonometric_series_tag, Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ad2b8b1f80aee0a381281198ff64365cf" title="Total trigonometric low degree. ">piranha::math::t_ldegree()</a> functor for instances of <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a>.  <a href="structpiranha_1_1math_1_1t__ldegree__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01std_2cb7021c0adcbf52a23f4f54c80a10b0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html">t_lorder_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#af2332cb80565e16bd33b18556e526e09" title="Total trigonometric low order. ">piranha::math::t_lorder()</a>.  <a href="structpiranha_1_1math_1_1t__lorder__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__lorder__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01std_143e8d88b209171f085d6417658ac4f43.html">t_lorder_impl&lt; Series, typename std::enable_if&lt; std::is_base_of&lt; detail::trigonometric_series_tag, Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#af2332cb80565e16bd33b18556e526e09" title="Total trigonometric low order. ">piranha::math::t_lorder()</a> functor for instances of <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a>.  <a href="structpiranha_1_1math_1_1t__lorder__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01std_143e8d88b209171f085d6417658ac4f43.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__order__impl.html">t_order_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a0bbc2ff5743dc9f7a7bb7a78d0bea14a" title="Total trigonometric order. ">piranha::math::t_order()</a>.  <a href="structpiranha_1_1math_1_1t__order__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__order__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01std_1_15a53f88a3f43b9dc95fb379f425536b.html">t_order_impl&lt; Series, typename std::enable_if&lt; std::is_base_of&lt; detail::trigonometric_series_tag, Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a0bbc2ff5743dc9f7a7bb7a78d0bea14a" title="Total trigonometric order. ">piranha::math::t_order()</a> functor for instances of <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a>.  <a href="structpiranha_1_1math_1_1t__order__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01std_1_15a53f88a3f43b9dc95fb379f425536b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__subs__impl.html">t_subs_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a48deac9c138773162dcd4ac65404ad65" title="Trigonometric substitution. ">piranha::math::t_subs()</a>.  <a href="structpiranha_1_1math_1_1t__subs__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__subs__impl_3_01_series_00_01_u_00_01_v_00_01detail_1_1t__subs__impl_7ad9c986dc1d74d55bde4986687ea40b.html">t_subs_impl&lt; Series, U, V, detail::t_subs_impl_t_subs_series_enabler&lt; Series, U, V &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a48deac9c138773162dcd4ac65404ad65" title="Trigonometric substitution. ">piranha::math::t_subs()</a> functor for instances of <a class="el" href="classpiranha_1_1t__substitutable__series.html" title="Toolbox for series that support trigonometric substitution. ">piranha::t_substitutable_series</a>.  <a href="structpiranha_1_1math_1_1t__subs__impl_3_01_series_00_01_u_00_01_v_00_01detail_1_1t__subs__impl_7ad9c986dc1d74d55bde4986687ea40b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html">truncate_degree_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a> functor.  <a href="structpiranha_1_1math_1_1truncate__degree__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl_3_01_series_00_01_t_00_01ps__degree__enabler_3_01_series_01_4_01_4.html">truncate_degree_impl&lt; Series, T, ps_degree_enabler&lt; Series &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a> functor for instances of <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a>.  <a href="structpiranha_1_1math_1_1truncate__degree__impl_3_01_series_00_01_t_00_01ps__degree__enabler_3_01_series_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a755a440fe280d7ee38347ce860e8484b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a755a440fe280d7ee38347ce860e8484b"><td class="memTemplItemLeft" align="right" valign="top">math_binomial_type&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a755a440fe280d7ee38347ce860e8484b">binomial</a> (const T &amp;x, const U &amp;y)</td></tr>
<tr class="memdesc:a755a440fe280d7ee38347ce860e8484b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalised binomial coefficient.  <a href="#a755a440fe280d7ee38347ce860e8484b">More...</a><br /></td></tr>
<tr class="separator:a755a440fe280d7ee38347ce860e8484b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e5e54357d0937d3e42780f03e2e7df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1e5e54357d0937d3e42780f03e2e7df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ad1e5e54357d0937d3e42780f03e2e7df">invert</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1invert__impl.html">invert_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:ad1e5e54357d0937d3e42780f03e2e7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse.  <a href="#ad1e5e54357d0937d3e42780f03e2e7df">More...</a><br /></td></tr>
<tr class="separator:ad1e5e54357d0937d3e42780f03e2e7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbf22d958ba696f713feb60ce502373"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T &gt; </td></tr>
<tr class="memitem:a6fbf22d958ba696f713feb60ce502373"><td class="memTemplItemLeft" align="right" valign="top">detail::math_lambdify_type&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a6fbf22d958ba696f713feb60ce502373">lambdify</a> (T &amp;&amp;x, const std::vector&lt; std::string &gt; &amp;names, detail::math_lambdify_extra_map_type&lt; T, U &gt; extra_map=detail::math_lambdify_extra_map_type&lt; T, U &gt;{})</td></tr>
<tr class="memdesc:a6fbf22d958ba696f713feb60ce502373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a functor interface for <a class="el" href="namespacepiranha_1_1math.html#a7b7051ad0e4cd2e7373bb71747e2116a" title="Evaluation. ">piranha::math::evaluate()</a>.  <a href="#a6fbf22d958ba696f713feb60ce502373">More...</a><br /></td></tr>
<tr class="separator:a6fbf22d958ba696f713feb60ce502373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d210d7fd0c312b5a280445548a853c"><td class="memTemplParams" colspan="2">template&lt;typename T , detail::math_is_zero_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a39d210d7fd0c312b5a280445548a853c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c">is_zero</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a39d210d7fd0c312b5a280445548a853c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero test.  <a href="#a39d210d7fd0c312b5a280445548a853c">More...</a><br /></td></tr>
<tr class="separator:a39d210d7fd0c312b5a280445548a853c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339e411baab25b72946944a87a04df80"><td class="memTemplParams" colspan="2">template&lt;typename T , detail::math_is_unitary_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a339e411baab25b72946944a87a04df80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a339e411baab25b72946944a87a04df80">is_unitary</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a339e411baab25b72946944a87a04df80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unitary test.  <a href="#a339e411baab25b72946944a87a04df80">More...</a><br /></td></tr>
<tr class="separator:a339e411baab25b72946944a87a04df80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fae3623a188a7a711be3cce4f4da56"><td class="memTemplParams" colspan="2">template&lt;typename T , detail::math_negate_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a47fae3623a188a7a711be3cce4f4da56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56">negate</a> (T &amp;x)</td></tr>
<tr class="memdesc:a47fae3623a188a7a711be3cce4f4da56"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place negation.  <a href="#a47fae3623a188a7a711be3cce4f4da56">More...</a><br /></td></tr>
<tr class="separator:a47fae3623a188a7a711be3cce4f4da56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b85fa643adb089c7980693221a566c"><td class="memTemplParams" colspan="2">template&lt;typename T , math_multiply_accumulate_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad3b85fa643adb089c7980693221a566c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ad3b85fa643adb089c7980693221a566c">multiply_accumulate</a> (T &amp;x, const T &amp;y, const T &amp;z)</td></tr>
<tr class="memdesc:ad3b85fa643adb089c7980693221a566c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate.  <a href="#ad3b85fa643adb089c7980693221a566c">More...</a><br /></td></tr>
<tr class="separator:ad3b85fa643adb089c7980693221a566c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72b05770e0a4508814e7506f8a84e6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae72b05770e0a4508814e7506f8a84e6f"><td class="memTemplItemLeft" align="right" valign="top">detail::math_cos_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ae72b05770e0a4508814e7506f8a84e6f">cos</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae72b05770e0a4508814e7506f8a84e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cosine.  <a href="#ae72b05770e0a4508814e7506f8a84e6f">More...</a><br /></td></tr>
<tr class="separator:ae72b05770e0a4508814e7506f8a84e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c98a78b13de3619ba578d2afe606209"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c98a78b13de3619ba578d2afe606209"><td class="memTemplItemLeft" align="right" valign="top">detail::math_sin_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a8c98a78b13de3619ba578d2afe606209">sin</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a8c98a78b13de3619ba578d2afe606209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sine.  <a href="#a8c98a78b13de3619ba578d2afe606209">More...</a><br /></td></tr>
<tr class="separator:a8c98a78b13de3619ba578d2afe606209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90685f4074f56de82b6e4683227243d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90685f4074f56de82b6e4683227243d6"><td class="memTemplItemLeft" align="right" valign="top">detail::math_partial_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6">partial</a> (const T &amp;x, const std::string &amp;str)</td></tr>
<tr class="memdesc:a90685f4074f56de82b6e4683227243d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial derivative.  <a href="#a90685f4074f56de82b6e4683227243d6">More...</a><br /></td></tr>
<tr class="separator:a90685f4074f56de82b6e4683227243d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f46a0b6a203a29e27aefd1a196edc6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7f46a0b6a203a29e27aefd1a196edc6"><td class="memTemplItemLeft" align="right" valign="top">detail::math_integrate_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ad7f46a0b6a203a29e27aefd1a196edc6">integrate</a> (const T &amp;x, const std::string &amp;str)</td></tr>
<tr class="memdesc:ad7f46a0b6a203a29e27aefd1a196edc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integration.  <a href="#ad7f46a0b6a203a29e27aefd1a196edc6">More...</a><br /></td></tr>
<tr class="separator:ad7f46a0b6a203a29e27aefd1a196edc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7051ad0e4cd2e7373bb71747e2116a"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T &gt; </td></tr>
<tr class="memitem:a7b7051ad0e4cd2e7373bb71747e2116a"><td class="memTemplItemLeft" align="right" valign="top">detail::math_evaluate_type&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a7b7051ad0e4cd2e7373bb71747e2116a">evaluate</a> (const T &amp;x, const std::unordered_map&lt; std::string, U &gt; &amp;dict)</td></tr>
<tr class="memdesc:a7b7051ad0e4cd2e7373bb71747e2116a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation.  <a href="#a7b7051ad0e4cd2e7373bb71747e2116a">More...</a><br /></td></tr>
<tr class="separator:a7b7051ad0e4cd2e7373bb71747e2116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7b607dc1e19d28a2f8bd601e6916c7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:abd7b607dc1e19d28a2f8bd601e6916c7"><td class="memTemplItemLeft" align="right" valign="top">detail::math_subs_type&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#abd7b607dc1e19d28a2f8bd601e6916c7">subs</a> (const T &amp;x, const std::string &amp;name, const U &amp;y)</td></tr>
<tr class="memdesc:abd7b607dc1e19d28a2f8bd601e6916c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#abd7b607dc1e19d28a2f8bd601e6916c7">More...</a><br /></td></tr>
<tr class="separator:abd7b607dc1e19d28a2f8bd601e6916c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48deac9c138773162dcd4ac65404ad65"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V &gt; </td></tr>
<tr class="memitem:a48deac9c138773162dcd4ac65404ad65"><td class="memTemplItemLeft" align="right" valign="top">detail::math_t_subs_type&lt; T, U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a48deac9c138773162dcd4ac65404ad65">t_subs</a> (const T &amp;x, const std::string &amp;name, const U &amp;c, const V &amp;s)</td></tr>
<tr class="memdesc:a48deac9c138773162dcd4ac65404ad65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric substitution.  <a href="#a48deac9c138773162dcd4ac65404ad65">More...</a><br /></td></tr>
<tr class="separator:a48deac9c138773162dcd4ac65404ad65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fad3b6f8a6178867eeac66f69531397"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fad3b6f8a6178867eeac66f69531397"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a9fad3b6f8a6178867eeac66f69531397">abs</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1abs__impl.html">abs_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:a9fad3b6f8a6178867eeac66f69531397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value.  <a href="#a9fad3b6f8a6178867eeac66f69531397">More...</a><br /></td></tr>
<tr class="separator:a9fad3b6f8a6178867eeac66f69531397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac3a41bda6c458a8a4280badc7fcf17"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ac3a41bda6c458a8a4280badc7fcf17"><td class="memTemplItemLeft" align="right" valign="top">detail::pbracket_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a7ac3a41bda6c458a8a4280badc7fcf17">pbracket</a> (const T &amp;f, const T &amp;g, const std::vector&lt; std::string &gt; &amp;p_list, const std::vector&lt; std::string &gt; &amp;q_list)</td></tr>
<tr class="memdesc:a7ac3a41bda6c458a8a4280badc7fcf17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poisson bracket.  <a href="#a7ac3a41bda6c458a8a4280badc7fcf17">More...</a><br /></td></tr>
<tr class="separator:a7ac3a41bda6c458a8a4280badc7fcf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652df25527486c9c55b365dd62e74e64"><td class="memTemplParams" colspan="2">template&lt;typename T , detail::is_canonical_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a652df25527486c9c55b365dd62e74e64"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a652df25527486c9c55b365dd62e74e64">transformation_is_canonical</a> (const std::vector&lt; T &gt; &amp;new_p, const std::vector&lt; T &gt; &amp;new_q, const std::vector&lt; std::string &gt; &amp;p_list, const std::vector&lt; std::string &gt; &amp;q_list)</td></tr>
<tr class="memdesc:a652df25527486c9c55b365dd62e74e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a transformation is canonical.  <a href="#a652df25527486c9c55b365dd62e74e64">More...</a><br /></td></tr>
<tr class="separator:a652df25527486c9c55b365dd62e74e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfb369fc27fce5b5d3c6bf4847b9f34"><td class="memTemplParams" colspan="2">template&lt;typename T , detail::is_canonical_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:aebfb369fc27fce5b5d3c6bf4847b9f34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#aebfb369fc27fce5b5d3c6bf4847b9f34">transformation_is_canonical</a> (std::initializer_list&lt; T &gt; new_p, std::initializer_list&lt; T &gt; new_q, const std::vector&lt; std::string &gt; &amp;p_list, const std::vector&lt; std::string &gt; &amp;q_list)</td></tr>
<tr class="memdesc:aebfb369fc27fce5b5d3c6bf4847b9f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a transformation is canonical (alternative overload).  <a href="#aebfb369fc27fce5b5d3c6bf4847b9f34">More...</a><br /></td></tr>
<tr class="separator:aebfb369fc27fce5b5d3c6bf4847b9f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934cd86d1c6bd2c1f40d307a093010bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a934cd86d1c6bd2c1f40d307a093010bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a934cd86d1c6bd2c1f40d307a093010bd">degree</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1degree__impl.html">degree_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:a934cd86d1c6bd2c1f40d307a093010bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total degree.  <a href="#a934cd86d1c6bd2c1f40d307a093010bd">More...</a><br /></td></tr>
<tr class="separator:a934cd86d1c6bd2c1f40d307a093010bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e42e3294b0b6bd50f75ac0e45ffc9f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e42e3294b0b6bd50f75ac0e45ffc9f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a9e42e3294b0b6bd50f75ac0e45ffc9f8">degree</a> (const T &amp;x, const std::vector&lt; std::string &gt; &amp;names) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1degree__impl.html">degree_impl</a>&lt; T &gt;()(x, names))</td></tr>
<tr class="memdesc:a9e42e3294b0b6bd50f75ac0e45ffc9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial degree.  <a href="#a9e42e3294b0b6bd50f75ac0e45ffc9f8">More...</a><br /></td></tr>
<tr class="separator:a9e42e3294b0b6bd50f75ac0e45ffc9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ad27dfa7dce556237f837c5c317890"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05ad27dfa7dce556237f837c5c317890"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a05ad27dfa7dce556237f837c5c317890">ldegree</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html">ldegree_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:a05ad27dfa7dce556237f837c5c317890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total low degree.  <a href="#a05ad27dfa7dce556237f837c5c317890">More...</a><br /></td></tr>
<tr class="separator:a05ad27dfa7dce556237f837c5c317890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2178fa50985be7fd6a4a846cf38cc58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2178fa50985be7fd6a4a846cf38cc58"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ab2178fa50985be7fd6a4a846cf38cc58">ldegree</a> (const T &amp;x, const std::vector&lt; std::string &gt; &amp;names) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html">ldegree_impl</a>&lt; T &gt;()(x, names))</td></tr>
<tr class="memdesc:ab2178fa50985be7fd6a4a846cf38cc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial low degree.  <a href="#ab2178fa50985be7fd6a4a846cf38cc58">More...</a><br /></td></tr>
<tr class="separator:ab2178fa50985be7fd6a4a846cf38cc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb790b56c7e9e146af38442d0aa21e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9cb790b56c7e9e146af38442d0aa21e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a9cb790b56c7e9e146af38442d0aa21e7">t_degree</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html">t_degree_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:a9cb790b56c7e9e146af38442d0aa21e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total trigonometric degree.  <a href="#a9cb790b56c7e9e146af38442d0aa21e7">More...</a><br /></td></tr>
<tr class="separator:a9cb790b56c7e9e146af38442d0aa21e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d83fd1c32d2533ac6ec8ab3b9b2390"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad0d83fd1c32d2533ac6ec8ab3b9b2390"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ad0d83fd1c32d2533ac6ec8ab3b9b2390">t_degree</a> (const T &amp;x, const std::vector&lt; std::string &gt; &amp;names) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html">t_degree_impl</a>&lt; T &gt;()(x, names))</td></tr>
<tr class="memdesc:ad0d83fd1c32d2533ac6ec8ab3b9b2390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric degree.  <a href="#ad0d83fd1c32d2533ac6ec8ab3b9b2390">More...</a><br /></td></tr>
<tr class="separator:ad0d83fd1c32d2533ac6ec8ab3b9b2390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b8b1f80aee0a381281198ff64365cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2b8b1f80aee0a381281198ff64365cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ad2b8b1f80aee0a381281198ff64365cf">t_ldegree</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html">t_ldegree_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:ad2b8b1f80aee0a381281198ff64365cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total trigonometric low degree.  <a href="#ad2b8b1f80aee0a381281198ff64365cf">More...</a><br /></td></tr>
<tr class="separator:ad2b8b1f80aee0a381281198ff64365cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548360bd4049145e4eec938c2d1dbfe5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a548360bd4049145e4eec938c2d1dbfe5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a548360bd4049145e4eec938c2d1dbfe5">t_ldegree</a> (const T &amp;x, const std::vector&lt; std::string &gt; &amp;names) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html">t_ldegree_impl</a>&lt; T &gt;()(x, names))</td></tr>
<tr class="memdesc:a548360bd4049145e4eec938c2d1dbfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric low degree.  <a href="#a548360bd4049145e4eec938c2d1dbfe5">More...</a><br /></td></tr>
<tr class="separator:a548360bd4049145e4eec938c2d1dbfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbc2ff5743dc9f7a7bb7a78d0bea14a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bbc2ff5743dc9f7a7bb7a78d0bea14a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a0bbc2ff5743dc9f7a7bb7a78d0bea14a">t_order</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__order__impl.html">t_order_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:a0bbc2ff5743dc9f7a7bb7a78d0bea14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total trigonometric order.  <a href="#a0bbc2ff5743dc9f7a7bb7a78d0bea14a">More...</a><br /></td></tr>
<tr class="separator:a0bbc2ff5743dc9f7a7bb7a78d0bea14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34d31975ddec861842b368be8f0f2ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab34d31975ddec861842b368be8f0f2ca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ab34d31975ddec861842b368be8f0f2ca">t_order</a> (const T &amp;x, const std::vector&lt; std::string &gt; &amp;names) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__order__impl.html">t_order_impl</a>&lt; T &gt;()(x, names))</td></tr>
<tr class="memdesc:ab34d31975ddec861842b368be8f0f2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric order.  <a href="#ab34d31975ddec861842b368be8f0f2ca">More...</a><br /></td></tr>
<tr class="separator:ab34d31975ddec861842b368be8f0f2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2332cb80565e16bd33b18556e526e09"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2332cb80565e16bd33b18556e526e09"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#af2332cb80565e16bd33b18556e526e09">t_lorder</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html">t_lorder_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:af2332cb80565e16bd33b18556e526e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total trigonometric low order.  <a href="#af2332cb80565e16bd33b18556e526e09">More...</a><br /></td></tr>
<tr class="separator:af2332cb80565e16bd33b18556e526e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cbe510754525dde205678937eb0b7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab7cbe510754525dde205678937eb0b7d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ab7cbe510754525dde205678937eb0b7d">t_lorder</a> (const T &amp;x, const std::vector&lt; std::string &gt; &amp;names) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html">t_lorder_impl</a>&lt; T &gt;()(x, names))</td></tr>
<tr class="memdesc:ab7cbe510754525dde205678937eb0b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric low order.  <a href="#ab7cbe510754525dde205678937eb0b7d">More...</a><br /></td></tr>
<tr class="separator:ab7cbe510754525dde205678937eb0b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab529e82af5b6a2f2a87d7c4f2c4268a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , detail::truncate_degree_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab529e82af5b6a2f2a87d7c4f2c4268a8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8">truncate_degree</a> (const T &amp;x, const U &amp;max_degree)</td></tr>
<tr class="memdesc:ab529e82af5b6a2f2a87d7c4f2c4268a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncation based on the total degree.  <a href="#ab529e82af5b6a2f2a87d7c4f2c4268a8">More...</a><br /></td></tr>
<tr class="separator:ab529e82af5b6a2f2a87d7c4f2c4268a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076b8891d207ab8a65b0cb131722cb5c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , detail::truncate_pdegree_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a076b8891d207ab8a65b0cb131722cb5c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a076b8891d207ab8a65b0cb131722cb5c">truncate_degree</a> (const T &amp;x, const U &amp;max_degree, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:a076b8891d207ab8a65b0cb131722cb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncation based on the partial degree.  <a href="#a076b8891d207ab8a65b0cb131722cb5c">More...</a><br /></td></tr>
<tr class="separator:a076b8891d207ab8a65b0cb131722cb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11fd337327c260a957de8b40c2b8bfc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae11fd337327c260a957de8b40c2b8bfc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ae11fd337327c260a957de8b40c2b8bfc">add3</a> (T &amp;a, const T &amp;b, const T &amp;c) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1add3__impl.html">add3_impl</a>&lt; T &gt;()(a, b, c))</td></tr>
<tr class="memdesc:ae11fd337327c260a957de8b40c2b8bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary addition.  <a href="#ae11fd337327c260a957de8b40c2b8bfc">More...</a><br /></td></tr>
<tr class="separator:ae11fd337327c260a957de8b40c2b8bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47faea1d9992a1d5d8f8a02cb535c47c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a47faea1d9992a1d5d8f8a02cb535c47c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a47faea1d9992a1d5d8f8a02cb535c47c">sub3</a> (T &amp;a, const T &amp;b, const T &amp;c) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1sub3__impl.html">sub3_impl</a>&lt; T &gt;()(a, b, c))</td></tr>
<tr class="memdesc:a47faea1d9992a1d5d8f8a02cb535c47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary subtraction.  <a href="#a47faea1d9992a1d5d8f8a02cb535c47c">More...</a><br /></td></tr>
<tr class="separator:a47faea1d9992a1d5d8f8a02cb535c47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e861376c8a922cae01bcd27ee757d39"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e861376c8a922cae01bcd27ee757d39"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a4e861376c8a922cae01bcd27ee757d39">mul3</a> (T &amp;a, const T &amp;b, const T &amp;c) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1mul3__impl.html">mul3_impl</a>&lt; T &gt;()(a, b, c))</td></tr>
<tr class="memdesc:a4e861376c8a922cae01bcd27ee757d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary multiplication.  <a href="#a4e861376c8a922cae01bcd27ee757d39">More...</a><br /></td></tr>
<tr class="separator:a4e861376c8a922cae01bcd27ee757d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b30a828ae8739cca5f4f492a8a4090"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0b30a828ae8739cca5f4f492a8a4090"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ab0b30a828ae8739cca5f4f492a8a4090">div3</a> (T &amp;a, const T &amp;b, const T &amp;c) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1div3__impl.html">div3_impl</a>&lt; T &gt;()(a, b, c))</td></tr>
<tr class="memdesc:ab0b30a828ae8739cca5f4f492a8a4090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary division.  <a href="#ab0b30a828ae8739cca5f4f492a8a4090">More...</a><br /></td></tr>
<tr class="separator:ab0b30a828ae8739cca5f4f492a8a4090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4d8d79c21d909f852c4678121bcad5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1c4d8d79c21d909f852c4678121bcad5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a1c4d8d79c21d909f852c4678121bcad5">gcd</a> (const T &amp;a, const U &amp;b) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1gcd__impl.html">gcd_impl</a>&lt; T, U &gt;()(a, b))</td></tr>
<tr class="memdesc:a1c4d8d79c21d909f852c4678121bcad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">GCD.  <a href="#a1c4d8d79c21d909f852c4678121bcad5">More...</a><br /></td></tr>
<tr class="separator:a1c4d8d79c21d909f852c4678121bcad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed326292eae1eeef5a46fd472a6e3165"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed326292eae1eeef5a46fd472a6e3165"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#aed326292eae1eeef5a46fd472a6e3165">gcd3</a> (T &amp;out, const T &amp;a, const T &amp;b) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1gcd3__impl.html">gcd3_impl</a>&lt; T &gt;()(out, a, b))</td></tr>
<tr class="memdesc:aed326292eae1eeef5a46fd472a6e3165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary GCD.  <a href="#aed326292eae1eeef5a46fd472a6e3165">More...</a><br /></td></tr>
<tr class="separator:aed326292eae1eeef5a46fd472a6e3165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5197472e0afd7cfea5eb15d0afd7d9"><td class="memTemplParams" colspan="2">template&lt;std::size_t SSize&gt; </td></tr>
<tr class="memitem:afe5197472e0afd7cfea5eb15d0afd7d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180">mp_integer</a>&lt; SSize &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#afe5197472e0afd7cfea5eb15d0afd7d9">factorial</a> (const <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180">mp_integer</a>&lt; SSize &gt; &amp;n)</td></tr>
<tr class="memdesc:afe5197472e0afd7cfea5eb15d0afd7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorial.  <a href="#afe5197472e0afd7cfea5eb15d0afd7d9">More...</a><br /></td></tr>
<tr class="separator:afe5197472e0afd7cfea5eb15d0afd7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b150f5b9d8168854f5a0a5f7ad278f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a66b150f5b9d8168854f5a0a5f7ad278f"><td class="memTemplItemLeft" align="right" valign="top">math_ipow_subs_t&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a66b150f5b9d8168854f5a0a5f7ad278f">ipow_subs</a> (const T &amp;x, const std::string &amp;name, const <a class="el" href="namespacepiranha.html#a5b983cfca428401f011389e30157b362">integer</a> &amp;n, const U &amp;y)</td></tr>
<tr class="memdesc:a66b150f5b9d8168854f5a0a5f7ad278f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution of integral power.  <a href="#a66b150f5b9d8168854f5a0a5f7ad278f">More...</a><br /></td></tr>
<tr class="separator:a66b150f5b9d8168854f5a0a5f7ad278f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103983d188b426b4103b2e131dce7908"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename Int &gt; </td></tr>
<tr class="memitem:a103983d188b426b4103b2e131dce7908"><td class="memTemplItemLeft" align="right" valign="top">math_ipow_subs_int_t&lt; T, U, Int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a103983d188b426b4103b2e131dce7908">ipow_subs</a> (const T &amp;x, const std::string &amp;name, const Int &amp;n, const U &amp;y)</td></tr>
<tr class="memdesc:a103983d188b426b4103b2e131dce7908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution of integral power (convenience overload).  <a href="#a103983d188b426b4103b2e131dce7908">More...</a><br /></td></tr>
<tr class="separator:a103983d188b426b4103b2e131dce7908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c4927a813897b54020e9e8d6a08a13"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a38c4927a813897b54020e9e8d6a08a13"><td class="memTemplItemLeft" align="right" valign="top">math_pow_t&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a38c4927a813897b54020e9e8d6a08a13">pow</a> (const T &amp;x, const U &amp;y)</td></tr>
<tr class="memdesc:a38c4927a813897b54020e9e8d6a08a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponentiation.  <a href="#a38c4927a813897b54020e9e8d6a08a13">More...</a><br /></td></tr>
<tr class="separator:a38c4927a813897b54020e9e8d6a08a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Math namespace. </p>
<p>Namespace for general-purpose mathematical functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9fad3b6f8a6178867eeac66f69531397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fad3b6f8a6178867eeac66f69531397">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::abs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1abs__impl.html">abs_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute value. </p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1abs__impl.html" title="Default functor for the implementation of piranha::math::abs(). ">piranha::math::abs_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>quantity whose absolute value will be calculated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute value of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1abs__impl.html" title="Default functor for the implementation of piranha::math::abs(). ">piranha::math::abs_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01013">1013</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ae11fd337327c260a957de8b40c2b8bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11fd337327c260a957de8b40c2b8bfc">&#9670;&nbsp;</a></span>add3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::add3 </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1add3__impl.html">add3_impl</a>&lt;T&gt;()(a, b, c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary addition. </p>
<p>This function will set <code>a</code> to <code>b + c</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1add3__impl.html" title="Default functor for the implementation of piranha::math::add3(). ">piranha::math::add3_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the return value. </td></tr>
    <tr><td class="paramname">b</td><td>the first operand. </td></tr>
    <tr><td class="paramname">c</td><td>the second operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned by the call operator of <a class="el" href="structpiranha_1_1math_1_1add3__impl.html" title="Default functor for the implementation of piranha::math::add3(). ">piranha::math::add3_impl</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1add3__impl.html" title="Default functor for the implementation of piranha::math::add3(). ">piranha::math::add3_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l02602">2602</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a755a440fe280d7ee38347ce860e8484b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755a440fe280d7ee38347ce860e8484b">&#9670;&nbsp;</a></span>binomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">math_binomial_type&lt;T, U&gt; piranha::math::binomial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generalised binomial coefficient. </p>
<p>Generic binomial coefficient.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>binomial_impl&lt;T,U&gt;{}(x,y)</code> is a valid expression, returning a type which satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</dd></dl>
<p>Will return the generalised binomial coefficient: </p><p class="formulaDsp">
\[ {x \choose y}. \]
</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1binomial__impl.html" title="Default functor for the implementation of piranha::math::binomial(). ">piranha::math::binomial_impl</a> functor. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> binomial_impl&lt;T,U&gt;{}(x,y);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>top number. </td></tr>
    <tr><td class="paramname">y</td><td>bottom number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> choose <code>y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1binomial__impl.html" title="Default functor for the implementation of piranha::math::binomial(). ">piranha::math::binomial_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="binomial_8hpp_source.html#l00215">215</a> of file <a class="el" href="binomial_8hpp_source.html">binomial.hpp</a>.</p>

</div>
</div>
<a id="ae72b05770e0a4508814e7506f8a84e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72b05770e0a4508814e7506f8a84e6f">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::math_cos_type&lt;T&gt; piranha::math::cos </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cosine. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if the expression <code>cos_impl&lt;T&gt;{}(x)</code> is valid, returning a type which satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</dd></dl>
<p>Returns the cosine of <code>x</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1cos__impl.html" title="Default functor for the implementation of piranha::math::cos(). ">piranha::math::cos_impl</a> functor's call operator. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> cos_impl&lt;T&gt;{}(x);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>cosine argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cosine of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1cos__impl.html" title="Default functor for the implementation of piranha::math::cos(). ">piranha::math::cos_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00535">535</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a934cd86d1c6bd2c1f40d307a093010bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934cd86d1c6bd2c1f40d307a093010bd">&#9670;&nbsp;</a></span>degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1degree__impl.html">degree_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total degree. </p>
<p>Return the total degree (as in polynomial degree).</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1degree__impl.html" title="Default functor for the implementation of piranha::math::degree(). ">piranha::math::degree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object whose degree will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1degree__impl.html" title="Default functor for the implementation of piranha::math::degree(). ">piranha::math::degree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01340">1340</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a9e42e3294b0b6bd50f75ac0e45ffc9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e42e3294b0b6bd50f75ac0e45ffc9f8">&#9670;&nbsp;</a></span>degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1degree__impl.html">degree_impl</a>&lt;T&gt;()(x, names))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial degree. </p>
<p>Return the partial degree (as in polynomial degree, but only a set of variables is considered in the computation).</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1degree__impl.html" title="Default functor for the implementation of piranha::math::degree(). ">piranha::math::degree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object whose partial degree will be computed. </td></tr>
    <tr><td class="paramname">names</td><td>names of the variables that will be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1degree__impl.html" title="Default functor for the implementation of piranha::math::degree(). ">piranha::math::degree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01359">1359</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ab0b30a828ae8739cca5f4f492a8a4090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b30a828ae8739cca5f4f492a8a4090">&#9670;&nbsp;</a></span>div3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::div3 </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1div3__impl.html">div3_impl</a>&lt;T&gt;()(a, b, c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary division. </p>
<p>This function will set <code>a</code> to <code>b / c</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1div3__impl.html" title="Default functor for the implementation of piranha::math::div3(). ">piranha::math::div3_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the return value. </td></tr>
    <tr><td class="paramname">b</td><td>the first operand. </td></tr>
    <tr><td class="paramname">c</td><td>the second operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned by the call operator of <a class="el" href="structpiranha_1_1math_1_1div3__impl.html" title="Default functor for the implementation of piranha::math::div3(). ">piranha::math::div3_impl</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1div3__impl.html" title="Default functor for the implementation of piranha::math::div3(). ">piranha::math::div3_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l02818">2818</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a7b7051ad0e4cd2e7373bb71747e2116a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7051ad0e4cd2e7373bb71747e2116a">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::math_evaluate_type&lt;T, U&gt; piranha::math::evaluate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; std::string, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>dict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluation. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>evaluate_impl&lt;T,U&gt;{}(x,dict)</code> is a valid expression, returning a type which satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</dd></dl>
<p>Evaluation is the simultaneous substitution of all symbolic arguments in an expression. The input dictionary <code>dict</code> specifies the quantity (value) that will be susbstituted for each argument (key), represented as a string. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1evaluate__impl.html" title="Default functor for the implementation of piranha::math::evaluate(). ">piranha::math::evaluate_impl</a> functor. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> evaluate_impl&lt;T,U&gt;{}(x,dict);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>quantity that will be evaluated. </td></tr>
    <tr><td class="paramname">dict</td><td>dictionary that will be used to perform the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> evaluated according to <code>dict</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1evaluate__impl.html" title="Default functor for the implementation of piranha::math::evaluate(). ">piranha::math::evaluate_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00823">823</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="afe5197472e0afd7cfea5eb15d0afd7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5197472e0afd7cfea5eb15d0afd7d9">&#9670;&nbsp;</a></span>factorial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180">mp_integer</a>&lt;SSize&gt; piranha::math::factorial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepiranha.html#a4521ec5ea56e318ade722c8bd0ca0180">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factorial. </p>
<p>This function will use internally <a class="el" href="classmppp_1_1mp__integer.html#abc8fcd9090b94b24b6684af97191f7a3" title="Factorial. ">piranha::mp_integer::fac_ui()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>factorial argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the factorial of <code>n</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if <code>n</code> is negative. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classmppp_1_1mp__integer.html#abc8fcd9090b94b24b6684af97191f7a3" title="Factorial. ">piranha::mp_integer::fac_ui()</a> or by the conversion of <code>n</code> to <code>unsigned long</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp__integer_8hpp_source.html#l00255">255</a> of file <a class="el" href="mp__integer_8hpp_source.html">mp_integer.hpp</a>.</p>

</div>
</div>
<a id="a1c4d8d79c21d909f852c4678121bcad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4d8d79c21d909f852c4678121bcad5">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::gcd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1gcd__impl.html">gcd_impl</a>&lt;T, U&gt;()(a, b))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GCD. </p>
<p>This function will return the GCD of <code>a</code> and <code>b</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1gcd__impl.html" title="Default functor for the implementation of piranha::math::gcd(). ">piranha::math::gcd_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first operand. </td></tr>
    <tr><td class="paramname">b</td><td>the second operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned by the call operator of <a class="el" href="structpiranha_1_1math_1_1gcd__impl.html" title="Default functor for the implementation of piranha::math::gcd(). ">piranha::math::gcd_impl</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1gcd__impl.html" title="Default functor for the implementation of piranha::math::gcd(). ">piranha::math::gcd_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l02898">2898</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="aed326292eae1eeef5a46fd472a6e3165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed326292eae1eeef5a46fd472a6e3165">&#9670;&nbsp;</a></span>gcd3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::gcd3 </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1gcd3__impl.html">gcd3_impl</a>&lt;T&gt;()(out, a, b))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary GCD. </p>
<p>This function will write the GCD of <code>a</code> and <code>b</code> into <code>out</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1gcd3__impl.html" title="Default functor for the implementation of piranha::math::gcd3(). ">piranha::math::gcd3_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output value. </td></tr>
    <tr><td class="paramname">a</td><td>the first operand. </td></tr>
    <tr><td class="paramname">b</td><td>the second operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned by the call operator of <a class="el" href="structpiranha_1_1math_1_1gcd3__impl.html" title="Default functor for the implementation of piranha::math::gcd3(). ">piranha::math::gcd3_impl</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1gcd3__impl.html" title="Default functor for the implementation of piranha::math::gcd3(). ">piranha::math::gcd3_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l02967">2967</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ad7f46a0b6a203a29e27aefd1a196edc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f46a0b6a203a29e27aefd1a196edc6">&#9670;&nbsp;</a></span>integrate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::math_integrate_type&lt;T&gt; piranha::math::integrate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integration. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if the expression <code>integrate_impl&lt;T&gt;{}(x,str)</code> is valid, returning a type that satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</dd></dl>
<p>Return the antiderivative of <code>x</code> with respect to the symbolic quantity named <code>str</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1integrate__impl.html" title="Default functor for the implementation of piranha::math::integrate(). ">piranha::math::integrate_impl</a> functor. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> integrate_impl&lt;T&gt;{}(x,str);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument for the integration. </td></tr>
    <tr><td class="paramname">str</td><td>name of the symbolic quantity with respect to which the integration will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>antiderivative of <code>x</code> with respect to <code>str</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1integrate__impl.html" title="Default functor for the implementation of piranha::math::integrate(). ">piranha::math::integrate_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00748">748</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ad1e5e54357d0937d3e42780f03e2e7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e5e54357d0937d3e42780f03e2e7df">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::invert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1invert__impl.html">invert_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the inverse. </p>
<p>Return the multiplicative inverse of <code>x</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1invert__impl.html" title="Default functor for the implementation of piranha::math::invert(). ">piranha::math::invert_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the multiplicative inverse of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1invert__impl.html" title="Default functor for the implementation of piranha::math::invert(). ">piranha::math::invert_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="invert_8hpp_source.html#l00079">79</a> of file <a class="el" href="invert_8hpp_source.html">invert.hpp</a>.</p>

</div>
</div>
<a id="a66b150f5b9d8168854f5a0a5f7ad278f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b150f5b9d8168854f5a0a5f7ad278f">&#9670;&nbsp;</a></span>ipow_subs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">math_ipow_subs_t&lt;T, U&gt; piranha::math::ipow_subs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepiranha.html#a5b983cfca428401f011389e30157b362">integer</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution of integral power. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if the expression <code>ipow_subs_impl&lt;T, U&gt;{}(x, name, n, y)</code> is valid, returning a type which satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</dd></dl>
<p>Substitute, in <code>x</code>, <code>name**n</code> with <code>y</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1ipow__subs__impl.html" title="Default functor for the implementation of piranha::math::ipow_subs(). ">piranha::math::ipow_subs_impl</a> functor's call operator. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> ipow_subs_impl&lt;T, U&gt;{}(x, name, n, y);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>quantity that will be subject to substitution. </td></tr>
    <tr><td class="paramname">name</td><td>name of the symbolic variable that will be substituted. </td></tr>
    <tr><td class="paramname">n</td><td>power of <code>name</code> that will be substituted. </td></tr>
    <tr><td class="paramname">y</td><td>object that will substitute the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> after the substitution of <code>name</code> to the power of <code>n</code> with <code>y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1subs__impl.html" title="Default functor for the implementation of piranha::math::subs(). ">piranha::math::subs_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp__integer_8hpp_source.html#l00313">313</a> of file <a class="el" href="mp__integer_8hpp_source.html">mp_integer.hpp</a>.</p>

</div>
</div>
<a id="a103983d188b426b4103b2e131dce7908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103983d188b426b4103b2e131dce7908">&#9670;&nbsp;</a></span>ipow_subs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">math_ipow_subs_int_t&lt;T, U, Int&gt; piranha::math::ipow_subs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution of integral power (convenience overload). </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if:<ul>
<li><code>Int</code> is a C++ integral type from which <a class="el" href="namespacepiranha.html#a5b983cfca428401f011389e30157b362" title="Alias for piranha::mp_integer with 1 limb of static storage. ">piranha::integer</a> can be constructed, and</li>
<li>the other overload of <a class="el" href="namespacepiranha_1_1math.html#a66b150f5b9d8168854f5a0a5f7ad278f" title="Substitution of integral power. ">piranha::math::ipow_subs()</a> is enabled with template arguments <code>T</code> and <code>U</code>.</li>
</ul>
</dd></dl>
<p>This function is a convenience wrapper that will call the other <a class="el" href="namespacepiranha_1_1math.html#a66b150f5b9d8168854f5a0a5f7ad278f" title="Substitution of integral power. ">piranha::math::ipow_subs()</a> overload, with <code>n</code> converted to a <a class="el" href="namespacepiranha.html#a5b983cfca428401f011389e30157b362" title="Alias for piranha::mp_integer with 1 limb of static storage. ">piranha::integer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>quantity that will be subject to substitution. </td></tr>
    <tr><td class="paramname">name</td><td>name of the symbolic variable that will be substituted. </td></tr>
    <tr><td class="paramname">n</td><td>power of <code>name</code> that will be substituted. </td></tr>
    <tr><td class="paramname">y</td><td>object that will substitute the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> after the substitution of <code>name</code> to the power of <code>n</code> with <code>y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the other overload of <a class="el" href="namespacepiranha_1_1math.html#a66b150f5b9d8168854f5a0a5f7ad278f" title="Substitution of integral power. ">piranha::math::ipow_subs()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp__integer_8hpp_source.html#l00519">519</a> of file <a class="el" href="mp__integer_8hpp_source.html">mp_integer.hpp</a>.</p>

</div>
</div>
<a id="a339e411baab25b72946944a87a04df80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339e411baab25b72946944a87a04df80">&#9670;&nbsp;</a></span>is_unitary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , detail::math_is_unitary_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool piranha::math::is_unitary </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unitary test. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>is_unitary_impl&lt;T&gt;{}(x)</code> is a valid expression, returning a type which is implicitly convertible to <code>bool</code>.</dd></dl>
<p>Test if value is equal to 1. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1is__unitary__impl.html" title="Default functor for the implementation of piranha::math::is_unitary(). ">piranha::math::is_unitary_impl</a> functor's call operator. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> is_unitary_impl&lt;T&gt;{}(x);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value to be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value is equal to 1, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1is__unitary__impl.html" title="Default functor for the implementation of piranha::math::is_unitary(). ">piranha::math::is_unitary_impl</a> functor, or by the conversion of the result to <code>bool</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00245">245</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a39d210d7fd0c312b5a280445548a853c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d210d7fd0c312b5a280445548a853c">&#9670;&nbsp;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , detail::math_is_zero_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool piranha::math::is_zero </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero test. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>is_zero_impl&lt;T&gt;{}(x)</code> is a well-formed expression returning a type implicitly convertible to <code>bool</code>.</dd></dl>
<p>Test if value is zero. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1is__zero__impl.html" title="Default functor for the implementation of piranha::math::is_zero(). ">piranha::math::is_zero_impl</a> functor's call operator. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> is_zero_impl&lt;T&gt;{}(x);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value to be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value is zero, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1is__zero__impl.html" title="Default functor for the implementation of piranha::math::is_zero(). ">piranha::math::is_zero_impl</a> functor or by the conversion of the result to <code>bool</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00135">135</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a6fbf22d958ba696f713feb60ce502373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbf22d958ba696f713feb60ce502373">&#9670;&nbsp;</a></span>lambdify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::math_lambdify_type&lt;T, U&gt; piranha::math::lambdify </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::math_lambdify_extra_map_type&lt; T, U &gt;&#160;</td>
          <td class="paramname"><em>extra_map</em> = <code>detail::math_lambdify_extra_map_type&lt;T,&#160;U&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a functor interface for <a class="el" href="namespacepiranha_1_1math.html#a7b7051ad0e4cd2e7373bb71747e2116a" title="Evaluation. ">piranha::math::evaluate()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if the decay types of <code>T</code> and <code>U</code> can be used as template parameters in <a class="el" href="classpiranha_1_1math_1_1lambdified.html" title="Functor interface for piranha::math::evaluate(). ">piranha::math::lambdified</a>.</dd></dl>
<p>This utility function will create an object of type <a class="el" href="classpiranha_1_1math_1_1lambdified.html" title="Functor interface for piranha::math::evaluate(). ">piranha::math::lambdified</a> that can be used to evaluate <code>x</code> with a function-like interface. The parameters of this function are passed to the constructor of the returned <a class="el" href="classpiranha_1_1math_1_1lambdified.html" title="Functor interface for piranha::math::evaluate(). ">piranha::math::lambdified</a> object. For example: </p><div class="fragment"><div class="line">polynomial&lt;integer,k_monomial&gt; x{<span class="stringliteral">&quot;x&quot;</span>}, y{<span class="stringliteral">&quot;y&quot;</span>}, z{<span class="stringliteral">&quot;z&quot;</span>};</div><div class="line"><span class="keyword">auto</span> l = lambdify&lt;double&gt;(x-2*y+3*z,{<span class="stringliteral">&quot;z&quot;</span>,<span class="stringliteral">&quot;y&quot;</span>,<span class="stringliteral">&quot;x&quot;</span>});</div></div><!-- fragment --><p> The object <code>l</code> can then be used to evaluate <code>x-2*y+3*z</code> in the following way: </p><div class="fragment"><div class="line">l({1.,2.,3.});</div></div><!-- fragment --><p> That is, <code>x-2*y+3*z</code> is evaluated with <code>x=3.</code>, <code>y=2.</code> and <code>z=1.</code>.</p>
<p>The optional parameter <code>extra_map</code> (of type <a class="el" href="classpiranha_1_1math_1_1lambdified.html#a8a37396a62ec2f0f32995f991104ac94" title="The map type for the custom evaluation of symbols. ">piranha::math::lambdified::extra_map_type</a>) is a map specifying how specific symbols should be evaluated. It is most useful when symbols have an implicit dependency on other symbols. For instance, suppose that the symbol \(z\) is implicitly dependent on the symbols \(x\) and \(y\) via \(z\left(x,y\right) = \sqrt{x+y}\). Then in order to evaluate \(x + y + z\) we can write: </p><div class="fragment"><div class="line">polynomial&lt;integer,k_monomial&gt; x{<span class="stringliteral">&quot;x&quot;</span>}, y{<span class="stringliteral">&quot;y&quot;</span>}, z{<span class="stringliteral">&quot;z&quot;</span>};</div><div class="line"><span class="keyword">auto</span> l = lambdify&lt;double&gt;(x+y+z,{<span class="stringliteral">&quot;x&quot;</span>,<span class="stringliteral">&quot;y&quot;</span>},{{<span class="stringliteral">&quot;z&quot;</span>,[](<span class="keyword">const</span> std::vector&lt;double&gt; &amp;v) {<span class="keywordflow">return</span> std::sqrt(v[0]+v[1]);}}});</div><div class="line">std::cout &lt;&lt; l({1.,2.}) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> <span class="comment">// This will print 1.+2.+sqrt(1.+2.) = 4.7320508076...</span></div></div><!-- fragment --><p> See the constructor of <a class="el" href="classpiranha_1_1math_1_1lambdified.html" title="Functor interface for piranha::math::evaluate(). ">piranha::math::lambdified</a> for more details on the <code>extra_map</code> argument.</p>
<p>The decay types of <code>T</code> and <code>U</code> are used as template parameters for the <a class="el" href="classpiranha_1_1math_1_1lambdified.html" title="Functor interface for piranha::math::evaluate(). ">piranha::math::lambdified</a> return type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object that will be evaluated. </td></tr>
    <tr><td class="paramname">names</td><td>names of the symbols that will be used for evaluation. </td></tr>
    <tr><td class="paramname">extra_map</td><td>map of type <a class="el" href="classpiranha_1_1math_1_1lambdified.html#a8a37396a62ec2f0f32995f991104ac94" title="The map type for the custom evaluation of symbols. ">piranha::math::lambdified::extra_map_type</a> for custom symbol evaluation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of <a class="el" href="classpiranha_1_1math_1_1lambdified.html" title="Functor interface for piranha::math::evaluate(). ">piranha::math::lambdified</a> that can be used to evaluate <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the constructor of <a class="el" href="classpiranha_1_1math_1_1lambdified.html" title="Functor interface for piranha::math::evaluate(). ">piranha::math::lambdified</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lambdify_8hpp_source.html#l00397">397</a> of file <a class="el" href="lambdify_8hpp_source.html">lambdify.hpp</a>.</p>

</div>
</div>
<a id="a05ad27dfa7dce556237f837c5c317890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ad27dfa7dce556237f837c5c317890">&#9670;&nbsp;</a></span>ldegree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::ldegree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html">ldegree_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total low degree. </p>
<p>Return the total low degree (as in polynomial low degree).</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html" title="Default functor for the implementation of piranha::math::ldegree(). ">piranha::math::ldegree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object whose low degree will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total low degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html" title="Default functor for the implementation of piranha::math::ldegree(). ">piranha::math::ldegree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01390">1390</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ab2178fa50985be7fd6a4a846cf38cc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2178fa50985be7fd6a4a846cf38cc58">&#9670;&nbsp;</a></span>ldegree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::ldegree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html">ldegree_impl</a>&lt;T&gt;()(x, names))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial low degree. </p>
<p>Return the partial low degree (as in polynomial low degree, but only a set of variables is considered in the computation).</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html" title="Default functor for the implementation of piranha::math::ldegree(). ">piranha::math::ldegree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object whose partial low degree will be computed. </td></tr>
    <tr><td class="paramname">names</td><td>names of the variables that will be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial low degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html" title="Default functor for the implementation of piranha::math::ldegree(). ">piranha::math::ldegree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01410">1410</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a4e861376c8a922cae01bcd27ee757d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e861376c8a922cae01bcd27ee757d39">&#9670;&nbsp;</a></span>mul3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::mul3 </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1mul3__impl.html">mul3_impl</a>&lt;T&gt;()(a, b, c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary multiplication. </p>
<p>This function will set <code>a</code> to <code>b * c</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1mul3__impl.html" title="Default functor for the implementation of piranha::math::mul3(). ">piranha::math::mul3_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the return value. </td></tr>
    <tr><td class="paramname">b</td><td>the first operand. </td></tr>
    <tr><td class="paramname">c</td><td>the second operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned by the call operator of <a class="el" href="structpiranha_1_1math_1_1mul3__impl.html" title="Default functor for the implementation of piranha::math::mul3(). ">piranha::math::mul3_impl</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1mul3__impl.html" title="Default functor for the implementation of piranha::math::mul3(). ">piranha::math::mul3_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l02746">2746</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ad3b85fa643adb089c7980693221a566c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b85fa643adb089c7980693221a566c">&#9670;&nbsp;</a></span>multiply_accumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , math_multiply_accumulate_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void piranha::math::multiply_accumulate </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply-accumulate. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if the expression <code>multiply_accumulate_impl&lt;T&gt;{}(x, y, z)</code> is valid.</dd></dl>
<p>This function will set <code>x</code> to <code>x + y * z</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1multiply__accumulate__impl.html" title="Default functor for the implementation of piranha::math::multiply_accumulate(). ">piranha::math::multiply_accumulate_impl</a> functor's call operator. The body of this function is equivalent to: </p><div class="fragment"><div class="line">multiply_accumulate_impl&lt;T&gt;{}(x, y, z);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>target value for accumulation. </td></tr>
    <tr><td class="paramname">y</td><td>first argument. </td></tr>
    <tr><td class="paramname">z</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1multiply__accumulate__impl.html" title="Default functor for the implementation of piranha::math::multiply_accumulate(). ">piranha::math::multiply_accumulate_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00443">443</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a47fae3623a188a7a711be3cce4f4da56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fae3623a188a7a711be3cce4f4da56">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , detail::math_negate_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void piranha::math::negate </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place negation. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>T</code> is not const and if the expression <code>negate_impl&lt;T&gt;{}(x)</code> is valid.</dd></dl>
<p>Negate value in-place. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1negate__impl.html" title="Default functor for the implementation of piranha::math::negate(). ">piranha::math::negate_impl</a> functor's call operator. The body of this function is equivalent to: </p><div class="fragment"><div class="line">negate_impl&lt;T&gt;{}(x);</div></div><!-- fragment --><p> The result of the call operator of <a class="el" href="structpiranha_1_1math_1_1negate__impl.html" title="Default functor for the implementation of piranha::math::negate(). ">piranha::math::negate_impl</a> is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value to be negated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1negate__impl.html" title="Default functor for the implementation of piranha::math::negate(). ">piranha::math::negate_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00334">334</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a90685f4074f56de82b6e4683227243d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90685f4074f56de82b6e4683227243d6">&#9670;&nbsp;</a></span>partial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::math_partial_type&lt;T&gt; piranha::math::partial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if the expression <code>partial_impl&lt;T&gt;{}(x,str)</code> is valid, returning a type that satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</dd></dl>
<p>Return the partial derivative of <code>x</code> with respect to the symbolic quantity named <code>str</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1partial__impl.html" title="Default functor for the implementation of piranha::math::partial(). ">piranha::math::partial_impl</a> functor. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> partial_impl&lt;T&gt;{}(x,str);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument for the partial derivative. </td></tr>
    <tr><td class="paramname">str</td><td>name of the symbolic quantity with respect to which the derivative will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial derivative of <code>x</code> with respect to <code>str</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1partial__impl.html" title="Default functor for the implementation of piranha::math::partial(). ">piranha::math::partial_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00696">696</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a7ac3a41bda6c458a8a4280badc7fcf17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac3a41bda6c458a8a4280badc7fcf17">&#9670;&nbsp;</a></span>pbracket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::pbracket_type&lt;T&gt; piranha::math::pbracket </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Poisson bracket. </p>
<dl class="section note"><dt>Note</dt><dd>This template function is enabled only if <code>T</code> is differentiable and the arithmetic operations needed to compute the brackets are supported by the types involved in the computation.</dd></dl>
<p>The Poisson bracket of <code>f</code> and <code>g</code> with respect to the list of momenta <code>p_list</code> and coordinates <code>q_list</code> is defined as: </p><p class="formulaDsp">
\[ \left\{f,g\right\} = \sum_{i=1}^{N} \left[ \frac{\partial f}{\partial q_{i}} \frac{\partial g}{\partial p_{i}} - \frac{\partial f}{\partial p_{i}} \frac{\partial g}{\partial q_{i}} \right], \]
</p>
<p> where \( p_i \) and \( q_i \) are the elements of <code>p_list</code> and <code>q_list</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>first argument. </td></tr>
    <tr><td class="paramname">g</td><td>second argument. </td></tr>
    <tr><td class="paramname">p_list</td><td>list of the names of momenta. </td></tr>
    <tr><td class="paramname">q_list</td><td>list of the names of coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the poisson bracket of <code>f</code> and <code>g</code> with respect to <code>p_list</code> and <code>q_list</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the sizes of <code>p_list</code> and <code>q_list</code> differ or if <code>p_list</code> or <code>q_list</code> contain duplicate entries. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a> or by the invoked arithmetic operators, constructors and assignment operators. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01151">1151</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a38c4927a813897b54020e9e8d6a08a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c4927a813897b54020e9e8d6a08a13">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">math_pow_t&lt;T, U&gt; piranha::math::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exponentiation. </p>
<p>Generic binary exponentiation.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if the expression <code>pow_impl&lt;T, U&gt;{}(x, y)</code> is valid, returning a type which satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</dd></dl>
<p>Return <code>x</code> to the power of <code>y</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1pow__impl.html" title="Default functor for the implementation of piranha::math::pow(). ">piranha::math::pow_impl</a> functor's call operator. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> pow_impl&lt;T, U&gt;{}(x, y);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>base. </td></tr>
    <tr><td class="paramname">y</td><td>exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> to the power of <code>y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1pow__impl.html" title="Default functor for the implementation of piranha::math::pow(). ">piranha::math::pow_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pow_8hpp_source.html#l00126">126</a> of file <a class="el" href="pow_8hpp_source.html">pow.hpp</a>.</p>

</div>
</div>
<a id="a8c98a78b13de3619ba578d2afe606209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c98a78b13de3619ba578d2afe606209">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::math_sin_type&lt;T&gt; piranha::math::sin </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sine. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if the expression <code>sin_impl&lt;T&gt;{}(x)</code> is valid, returning a type which satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</dd></dl>
<p>Returns the sine of <code>x</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1sin__impl.html" title="Default functor for the implementation of piranha::math::sin(). ">piranha::math::sin_impl</a> functor's call operator. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> sin_impl&lt;T&gt;{}(x);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>sine argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sine of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1sin__impl.html" title="Default functor for the implementation of piranha::math::sin(). ">piranha::math::sin_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00627">627</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a47faea1d9992a1d5d8f8a02cb535c47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47faea1d9992a1d5d8f8a02cb535c47c">&#9670;&nbsp;</a></span>sub3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::sub3 </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1sub3__impl.html">sub3_impl</a>&lt;T&gt;()(a, b, c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary subtraction. </p>
<p>This function will set <code>a</code> to <code>b - c</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1sub3__impl.html" title="Default functor for the implementation of piranha::math::sub3(). ">piranha::math::sub3_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the return value. </td></tr>
    <tr><td class="paramname">b</td><td>the first operand. </td></tr>
    <tr><td class="paramname">c</td><td>the second operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned by the call operator of <a class="el" href="structpiranha_1_1math_1_1sub3__impl.html" title="Default functor for the implementation of piranha::math::sub3(). ">piranha::math::sub3_impl</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1sub3__impl.html" title="Default functor for the implementation of piranha::math::sub3(). ">piranha::math::sub3_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l02674">2674</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="abd7b607dc1e19d28a2f8bd601e6916c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7b607dc1e19d28a2f8bd601e6916c7">&#9670;&nbsp;</a></span>subs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::math_subs_type&lt;T, U&gt; piranha::math::subs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>subs_impl&lt;T,U&gt;{}(x,name,y)</code> is a valid expression, returning a type which satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</dd></dl>
<p>Substitute a symbolic variable with a generic object. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1subs__impl.html" title="Default functor for the implementation of piranha::math::subs(). ">piranha::math::subs_impl</a> functor. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> subs_impl&lt;T,U&gt;{}(x,name,y);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>quantity that will be subject to substitution. </td></tr>
    <tr><td class="paramname">name</td><td>name of the symbolic variable that will be substituted. </td></tr>
    <tr><td class="paramname">y</td><td>object that will substitute the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> after substitution of <code>name</code> with <code>y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1subs__impl.html" title="Default functor for the implementation of piranha::math::subs(). ">piranha::math::subs_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00876">876</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a9cb790b56c7e9e146af38442d0aa21e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb790b56c7e9e146af38442d0aa21e7">&#9670;&nbsp;</a></span>t_degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html">t_degree_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total trigonometric degree. </p>
<p>A type exposing a trigonometric degree property, in analogy with the concept of polynomial degree, should be a linear combination of real or complex trigonometric functions. For instance, the Poisson series </p><p class="formulaDsp">
\[ 2\cos\left(3x+y\right) + 3\cos\left(2x-y\right) \]
</p>
<p> has a trigonometric degree of 3+1=4.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html" title="Default functor for the implementation of piranha::math::t_degree(). ">piranha::math::t_degree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object whose trigonometric degree will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html" title="Default functor for the implementation of piranha::math::t_degree(). ">piranha::math::t_degree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01447">1447</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ad0d83fd1c32d2533ac6ec8ab3b9b2390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d83fd1c32d2533ac6ec8ab3b9b2390">&#9670;&nbsp;</a></span>t_degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html">t_degree_impl</a>&lt;T&gt;()(x, names))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric degree. </p>
<p>The partial trigonometric degree is the trigonometric degree when only certain variables are considered in the computation.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html" title="Default functor for the implementation of piranha::math::t_degree(). ">piranha::math::t_degree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object whose trigonometric degree will be computed. </td></tr>
    <tr><td class="paramname">names</td><td>names of the variables that will be considered in the computation of the degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html" title="Default functor for the implementation of piranha::math::t_degree(). ">piranha::math::t_degree_impl</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepiranha_1_1math.html#a9cb790b56c7e9e146af38442d0aa21e7" title="Total trigonometric degree. ">piranha::math::t_degree()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01469">1469</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ad2b8b1f80aee0a381281198ff64365cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b8b1f80aee0a381281198ff64365cf">&#9670;&nbsp;</a></span>t_ldegree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_ldegree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html">t_ldegree_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total trigonometric low degree. </p>
<p>A type exposing a trigonometric low degree property, in analogy with the concept of polynomial low degree, should be a linear combination of real or complex trigonometric functions. For instance, the Poisson series </p><p class="formulaDsp">
\[ 2\cos\left(3x+y\right) + 3\cos\left(2x-y\right) \]
</p>
<p> has a trigonometric low degree of 2-1=1.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html" title="Default functor for the implementation of piranha::math::t_ldegree(). ">piranha::math::t_ldegree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object whose trigonometric low degree will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric low degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html" title="Default functor for the implementation of piranha::math::t_ldegree(). ">piranha::math::t_ldegree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01506">1506</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a548360bd4049145e4eec938c2d1dbfe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548360bd4049145e4eec938c2d1dbfe5">&#9670;&nbsp;</a></span>t_ldegree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_ldegree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html">t_ldegree_impl</a>&lt;T&gt;()(x, names))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric low degree. </p>
<p>The partial trigonometric low degree is the trigonometric low degree when only certain variables are considered in the computation.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html" title="Default functor for the implementation of piranha::math::t_ldegree(). ">piranha::math::t_ldegree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object whose trigonometric low degree will be computed. </td></tr>
    <tr><td class="paramname">names</td><td>names of the variables that will be considered in the computation of the degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric low degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html" title="Default functor for the implementation of piranha::math::t_ldegree(). ">piranha::math::t_ldegree_impl</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepiranha_1_1math.html#ad2b8b1f80aee0a381281198ff64365cf" title="Total trigonometric low degree. ">piranha::math::t_ldegree()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01528">1528</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="af2332cb80565e16bd33b18556e526e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2332cb80565e16bd33b18556e526e09">&#9670;&nbsp;</a></span>t_lorder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_lorder </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html">t_lorder_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total trigonometric low order. </p>
<p>A type exposing a trigonometric low order property should be a linear combination of real or complex trigonometric functions. The low order is computed in a way similar to the trigonometric low degree, with the key difference that the absolute values of the trigonometric degrees of each variable are considered in the computation. For instance, the Poisson series </p><p class="formulaDsp">
\[ 2\cos\left(3x+y\right) + 3\cos\left(2x-y\right) \]
</p>
<p> has a trigonometric low order of abs(2)+abs(1)=3.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html" title="Default functor for the implementation of piranha::math::t_lorder(). ">piranha::math::t_lorder_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object whose trigonometric low order will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric low order.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html" title="Default functor for the implementation of piranha::math::t_lorder(). ">piranha::math::t_lorder_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01630">1630</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ab7cbe510754525dde205678937eb0b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cbe510754525dde205678937eb0b7d">&#9670;&nbsp;</a></span>t_lorder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_lorder </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html">t_lorder_impl</a>&lt;T&gt;()(x, names))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric low order. </p>
<p>The partial trigonometric low order is the trigonometric low order when only certain variables are considered in the computation.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html" title="Default functor for the implementation of piranha::math::t_lorder(). ">piranha::math::t_lorder_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object whose trigonometric low order will be computed. </td></tr>
    <tr><td class="paramname">names</td><td>names of the variables that will be considered in the computation of the order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric low order.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html" title="Default functor for the implementation of piranha::math::t_lorder(). ">piranha::math::t_lorder_impl</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepiranha_1_1math.html#af2332cb80565e16bd33b18556e526e09" title="Total trigonometric low order. ">piranha::math::t_lorder()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01652">1652</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a0bbc2ff5743dc9f7a7bb7a78d0bea14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbc2ff5743dc9f7a7bb7a78d0bea14a">&#9670;&nbsp;</a></span>t_order() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_order </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__order__impl.html">t_order_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total trigonometric order. </p>
<p>A type exposing a trigonometric order property should be a linear combination of real or complex trigonometric functions. The order is computed in a way similar to the trigonometric degree, with the key difference that the absolute values of the trigonometric degrees of each variable are considered in the computation. For instance, the Poisson series </p><p class="formulaDsp">
\[ 2\cos\left(3x+y\right) + 3\cos\left(2x-y\right) \]
</p>
<p> has a trigonometric order of abs(3)+abs(1)=4.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__order__impl.html" title="Default functor for the implementation of piranha::math::t_order(). ">piranha::math::t_order_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object whose trigonometric order will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric order.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__order__impl.html" title="Default functor for the implementation of piranha::math::t_order(). ">piranha::math::t_order_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01568">1568</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ab34d31975ddec861842b368be8f0f2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34d31975ddec861842b368be8f0f2ca">&#9670;&nbsp;</a></span>t_order() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_order </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__order__impl.html">t_order_impl</a>&lt;T&gt;()(x, names))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric order. </p>
<p>The partial trigonometric order is the trigonometric order when only certain variables are considered in the computation.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__order__impl.html" title="Default functor for the implementation of piranha::math::t_order(). ">piranha::math::t_order_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object whose trigonometric order will be computed. </td></tr>
    <tr><td class="paramname">names</td><td>names of the variables that will be considered in the computation of the order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric order.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__order__impl.html" title="Default functor for the implementation of piranha::math::t_order(). ">piranha::math::t_order_impl</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepiranha_1_1math.html#a0bbc2ff5743dc9f7a7bb7a78d0bea14a" title="Total trigonometric order. ">piranha::math::t_order()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01590">1590</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a48deac9c138773162dcd4ac65404ad65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48deac9c138773162dcd4ac65404ad65">&#9670;&nbsp;</a></span>t_subs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::math_t_subs_type&lt;T, U, V&gt; piranha::math::t_subs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>t_subs_impl&lt;T,U,V&gt;{}(x,name,c,s)</code> is a valid expression, returning a type which satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</dd></dl>
<p>Substitute the cosine and sine of a symbolic variable with generic objects. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__subs__impl.html" title="Default functor for the implementation of piranha::math::t_subs(). ">piranha::math::t_subs_impl</a> functor. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> t_subs_impl&lt;T,U,V&gt;{}(x,name,c,s);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>quantity that will be subject to substitution. </td></tr>
    <tr><td class="paramname">name</td><td>name of the symbolic variable that will be substituted. </td></tr>
    <tr><td class="paramname">c</td><td>object that will substitute the cosine of the variable. </td></tr>
    <tr><td class="paramname">s</td><td>object that will substitute the sine of the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> after substitution of cosine and sine of <code>name</code> with <code>c</code> and <code>s</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__subs__impl.html" title="Default functor for the implementation of piranha::math::t_subs(). ">piranha::math::t_subs_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00931">931</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a652df25527486c9c55b365dd62e74e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652df25527486c9c55b365dd62e74e64">&#9670;&nbsp;</a></span>transformation_is_canonical() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , detail::is_canonical_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool piranha::math::transformation_is_canonical </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a transformation is canonical. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if all the following requirements are met:<ul>
<li><code>T</code> satisfies <a class="el" href="classpiranha_1_1has__pbracket.html" title="Detect piranha::math::pbracket(). ">piranha::has_pbracket</a>,</li>
<li>the output type of <a class="el" href="classpiranha_1_1has__pbracket.html" title="Detect piranha::math::pbracket(). ">piranha::has_pbracket</a> for <code>T</code> satisfies <a class="el" href="classpiranha_1_1has__is__zero.html" title="Type trait to detect the presence of the piranha::math::is_zero() function. ">piranha::has_is_zero</a>, it is constructible from <code>int</code> and it is equality comparable.</li>
</ul>
</dd></dl>
<p>This function will check if a transformation of Hamiltonian momenta and coordinates is canonical using the Poisson bracket test. The transformation is expressed as two separate collections of objects, <code>new_p</code> and <code>new_q</code>, representing the new momenta and coordinates as functions of the old momenta <code>p_list</code> and <code>q_list</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_p</td><td>list of objects representing the new momenta. </td></tr>
    <tr><td class="paramname">new_q</td><td>list of objects representing the new coordinates. </td></tr>
    <tr><td class="paramname">p_list</td><td>list of names of the old momenta. </td></tr>
    <tr><td class="paramname">q_list</td><td>list of names of the old coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the transformation is canonical, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the sizes of the four input arguments are not the same or if either <code>p_list</code> or <code>q_list</code> contain duplicate entries. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha_1_1math.html#a7ac3a41bda6c458a8a4280badc7fcf17" title="Poisson bracket. ">piranha::math::pbracket()</a>,</li>
<li>construction and comparison of objects of the type returned by <a class="el" href="namespacepiranha_1_1math.html#a7ac3a41bda6c458a8a4280badc7fcf17" title="Poisson bracket. ">piranha::math::pbracket()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a>,</li>
<li>memory errors in standard containers. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01282">1282</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="aebfb369fc27fce5b5d3c6bf4847b9f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfb369fc27fce5b5d3c6bf4847b9f34">&#9670;&nbsp;</a></span>transformation_is_canonical() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , detail::is_canonical_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool piranha::math::transformation_is_canonical </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>new_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>new_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a transformation is canonical (alternative overload). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_p</td><td>list of objects representing the new momenta. </td></tr>
    <tr><td class="paramname">new_q</td><td>list of objects representing the new coordinates. </td></tr>
    <tr><td class="paramname">p_list</td><td>list of names of the old momenta. </td></tr>
    <tr><td class="paramname">q_list</td><td>list of names of the old coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="namespacepiranha_1_1math.html#a652df25527486c9c55b365dd62e74e64" title="Check if a transformation is canonical. ">transformation_is_canonical(const std::vector&lt;T&gt; &amp;, const std::vector&lt;T&gt; &amp;, const std::vector&lt;std::string&gt; &amp;, const std::vector&lt;std::string&gt; &amp;)</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="namespacepiranha_1_1math.html#a652df25527486c9c55b365dd62e74e64" title="Check if a transformation is canonical. ">transformation_is_canonical(const std::vector&lt;T&gt; &amp;, const std::vector&lt;T&gt; &amp;, const std::vector&lt;std::string&gt; &amp;, const std::vector&lt;std::string&gt; &amp;)</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01305">1305</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ab529e82af5b6a2f2a87d7c4f2c4268a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab529e82af5b6a2f2a87d7c4f2c4268a8">&#9670;&nbsp;</a></span>truncate_degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , detail::truncate_degree_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T piranha::math::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncation based on the total degree. </p>
<p>This method is used to eliminate from the input argument <code>x</code> all the parts whose total degree is greater than <code>max_degree</code>.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html" title="Implementation of the piranha::math::truncate_degree() functor. ">piranha::math::truncate_degree_impl</a> functor.</p>
<p>The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> truncate_degree_impl&lt;T,U&gt;()(x,max_degree);</div></div><!-- fragment --><p> The call operator of <a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html" title="Implementation of the piranha::math::truncate_degree() functor. ">piranha::math::truncate_degree_impl</a> is required to return type <code>T</code>, otherwise this function will be disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object which will be subject to truncation. </td></tr>
    <tr><td class="paramname">max_degree</td><td>maximum allowed total degree in the output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html" title="Implementation of the piranha::math::truncate_degree() functor. ">piranha::math::truncate_degree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01711">1711</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a076b8891d207ab8a65b0cb131722cb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076b8891d207ab8a65b0cb131722cb5c">&#9670;&nbsp;</a></span>truncate_degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , detail::truncate_pdegree_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T piranha::math::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncation based on the partial degree. </p>
<p>This method is used to eliminate from the input argument <code>x</code> all the parts whose partial degree is greater than <code>max_degree</code>.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html" title="Implementation of the piranha::math::truncate_degree() functor. ">piranha::math::truncate_degree_impl</a> functor.</p>
<p>The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> truncate_degree_impl&lt;T,U&gt;()(x,max_degree,names);</div></div><!-- fragment --><p> The call operator of <a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html" title="Implementation of the piranha::math::truncate_degree() functor. ">piranha::math::truncate_degree_impl</a> is required to return type <code>T</code>, otherwise this function will be disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>object which will be subject to truncation. </td></tr>
    <tr><td class="paramname">max_degree</td><td>maximum allowed partial degree in the output. </td></tr>
    <tr><td class="paramname">names</td><td>names of the variables that will be considered in the computation of the partial degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html" title="Implementation of the piranha::math::truncate_degree() functor. ">piranha::math::truncate_degree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l01739">1739</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
