<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>piranha: piranha::power_series&lt; Series, Derived &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepiranha.html">piranha</a></li><li class="navelem"><a class="el" href="classpiranha_1_1power__series.html">power_series</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpiranha_1_1power__series-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">piranha::power_series&lt; Series, Derived &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Power series toolbox.  
 <a href="classpiranha_1_1power__series.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>&gt;</code></p>

<p>Inherits Series, and power_series_tag.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a579ed43117f54ca7d88fda3f8786c76a"><td class="memItemLeft" align="right" valign="top"><a id="a579ed43117f54ca7d88fda3f8786c76a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a579ed43117f54ca7d88fda3f8786c76a">power_series</a> ()=default</td></tr>
<tr class="memdesc:a579ed43117f54ca7d88fda3f8786c76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted default constructor. <br /></td></tr>
<tr class="separator:a579ed43117f54ca7d88fda3f8786c76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296dac7c1270bd02f9b77d4c91c59d13"><td class="memItemLeft" align="right" valign="top"><a id="a296dac7c1270bd02f9b77d4c91c59d13"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a296dac7c1270bd02f9b77d4c91c59d13">power_series</a> (const <a class="el" href="classpiranha_1_1power__series.html">power_series</a> &amp;)=default</td></tr>
<tr class="memdesc:a296dac7c1270bd02f9b77d4c91c59d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor. <br /></td></tr>
<tr class="separator:a296dac7c1270bd02f9b77d4c91c59d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0522905efe2a31aef2b99f2837195fe"><td class="memItemLeft" align="right" valign="top"><a id="ae0522905efe2a31aef2b99f2837195fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#ae0522905efe2a31aef2b99f2837195fe">power_series</a> (<a class="el" href="classpiranha_1_1power__series.html">power_series</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:ae0522905efe2a31aef2b99f2837195fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move constructor. <br /></td></tr>
<tr class="separator:ae0522905efe2a31aef2b99f2837195fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16800c266c95fda4e519e6d4d4c95bcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1power__series.html">power_series</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a16800c266c95fda4e519e6d4d4c95bcf">operator=</a> (const <a class="el" href="classpiranha_1_1power__series.html">power_series</a> &amp;other)=default</td></tr>
<tr class="memdesc:a16800c266c95fda4e519e6d4d4c95bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a16800c266c95fda4e519e6d4d4c95bcf">More...</a><br /></td></tr>
<tr class="separator:a16800c266c95fda4e519e6d4d4c95bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a751047710b3909bee179ab9d955a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1power__series.html">power_series</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a7a751047710b3909bee179ab9d955a16">operator=</a> (<a class="el" href="classpiranha_1_1power__series.html">power_series</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:a7a751047710b3909bee179ab9d955a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a7a751047710b3909bee179ab9d955a16">More...</a><br /></td></tr>
<tr class="separator:a7a751047710b3909bee179ab9d955a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d95d21f47fa51a4e9af531f7150a0b5"><td class="memItemLeft" align="right" valign="top"><a id="a7d95d21f47fa51a4e9af531f7150a0b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a7d95d21f47fa51a4e9af531f7150a0b5">~power_series</a> ()</td></tr>
<tr class="memdesc:a7d95d21f47fa51a4e9af531f7150a0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial destructor. <br /></td></tr>
<tr class="separator:a7d95d21f47fa51a4e9af531f7150a0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5735ddbc2dd58808c625cbe652888f8b"><td class="memTemplParams" colspan="2">template&lt;typename T  = power_series&gt; </td></tr>
<tr class="memitem:a5735ddbc2dd58808c625cbe652888f8b"><td class="memTemplItemLeft" align="right" valign="top">degree_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a5735ddbc2dd58808c625cbe652888f8b">degree</a> () const</td></tr>
<tr class="memdesc:a5735ddbc2dd58808c625cbe652888f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total degree.  <a href="#a5735ddbc2dd58808c625cbe652888f8b">More...</a><br /></td></tr>
<tr class="separator:a5735ddbc2dd58808c625cbe652888f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740700e20a5a450958c183d8eef33430"><td class="memTemplParams" colspan="2">template&lt;typename T  = power_series&gt; </td></tr>
<tr class="memitem:a740700e20a5a450958c183d8eef33430"><td class="memTemplItemLeft" align="right" valign="top">ldegree_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a740700e20a5a450958c183d8eef33430">ldegree</a> () const</td></tr>
<tr class="memdesc:a740700e20a5a450958c183d8eef33430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total low degree.  <a href="#a740700e20a5a450958c183d8eef33430">More...</a><br /></td></tr>
<tr class="separator:a740700e20a5a450958c183d8eef33430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f206670c33151c3b8c3d715d2dfd4d6"><td class="memTemplParams" colspan="2">template&lt;typename T  = power_series&gt; </td></tr>
<tr class="memitem:a1f206670c33151c3b8c3d715d2dfd4d6"><td class="memTemplItemLeft" align="right" valign="top">pdegree_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a1f206670c33151c3b8c3d715d2dfd4d6">degree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:a1f206670c33151c3b8c3d715d2dfd4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial degree.  <a href="#a1f206670c33151c3b8c3d715d2dfd4d6">More...</a><br /></td></tr>
<tr class="separator:a1f206670c33151c3b8c3d715d2dfd4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b89d255d38827c62014bd47b6cf2cd"><td class="memTemplParams" colspan="2">template&lt;typename T  = power_series&gt; </td></tr>
<tr class="memitem:a86b89d255d38827c62014bd47b6cf2cd"><td class="memTemplItemLeft" align="right" valign="top">pldegree_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a86b89d255d38827c62014bd47b6cf2cd">ldegree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:a86b89d255d38827c62014bd47b6cf2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial low degree.  <a href="#a86b89d255d38827c62014bd47b6cf2cd">More...</a><br /></td></tr>
<tr class="separator:a86b89d255d38827c62014bd47b6cf2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105b7fa2770982a071e2452af0fd94f4"><td class="memTemplParams" colspan="2">template&lt;typename T , truncate_degree_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a105b7fa2770982a071e2452af0fd94f4"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a105b7fa2770982a071e2452af0fd94f4">truncate_degree</a> (const T &amp;max_degree) const</td></tr>
<tr class="memdesc:a105b7fa2770982a071e2452af0fd94f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total degree truncation.  <a href="#a105b7fa2770982a071e2452af0fd94f4">More...</a><br /></td></tr>
<tr class="separator:a105b7fa2770982a071e2452af0fd94f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac308a9c055ae2d5af5dac621268d3e43"><td class="memTemplParams" colspan="2">template&lt;typename T , truncate_pdegree_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac308a9c055ae2d5af5dac621268d3e43"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#ac308a9c055ae2d5af5dac621268d3e43">truncate_degree</a> (const T &amp;max_degree, const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:ac308a9c055ae2d5af5dac621268d3e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial degree truncation.  <a href="#ac308a9c055ae2d5af5dac621268d3e43">More...</a><br /></td></tr>
<tr class="separator:ac308a9c055ae2d5af5dac621268d3e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Series, typename Derived&gt;<br />
class piranha::power_series&lt; Series, Derived &gt;</h3>

<p>Power series toolbox. </p>
<p>This toolbox is intended to extend the <code>Series</code> type with properties of formal power series.</p>
<p>Specifically, the toolbox will conditionally augment a <code>Series</code> type by adding methods to query the total and partial (low) degree * of a <code>Series</code> object. Such augmentation takes place if the series' coefficient and/or key types expose methods to query their degree properties (as established by the <a class="el" href="classpiranha_1_1has__degree.html" title="Type trait to detect if type has a degree property. ">piranha::has_degree</a>, <a class="el" href="classpiranha_1_1key__has__degree.html" title="Type trait to detect if a key type has a degree property. ">piranha::key_has_degree</a> and similar type traits), and if the necessary arithmetic operations are supported by the involved types. As an additional requirement, the types returned when querying the degree must be constructible from <code>int</code>, less-than comparable and they must satisfy <a class="el" href="structpiranha_1_1is__container__element.html" title="Type trait for well-behaved container elements. ">piranha::is_container_element</a>. If the computation of the degree of a single term involves only C++ integral types, then the computation will be checked for overflow.</p>
<p>This toolbox provides also support for truncation based on the total or partial degree. In addition to the requirements of the degree-querying methods, the truncation methods also require the supplied degree limit to be comparable to the type returned by the degree-querying methods. The truncation methods will recursively truncate the coefficients of the series via the <a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a> function.</p>
<p>If the requirements outlined above are not satisfied, the degree-querying and the truncation methods will be disabled.</p>
<p>This class satisfies the <a class="el" href="classpiranha_1_1is__series.html" title="Type trait to detect series types. ">piranha::is_series</a> type trait.</p>
<h2>Type requirements</h2>
<ul>
<li><code>Series</code> must satisfy the <a class="el" href="classpiranha_1_1is__series.html" title="Type trait to detect series types. ">piranha::is_series</a> type trait,</li>
<li><code>Derived</code> must derive from <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">power_series</a> of <code>Series</code> and <code>Derived</code>.</li>
</ul>
<h2>Exception safety guarantee</h2>
<p>This class provides the same guarantee as <code>Series</code>. The auto-truncation methods offer the basic exception safety guarantee.</p>
<h2>Move semantics</h2>
<p>Move semantics is equivalent to the move semantics of <code>Series</code>. </p>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00322">322</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5735ddbc2dd58808c625cbe652888f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5735ddbc2dd58808c625cbe652888f8b">&sect;&nbsp;</a></span>degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T  = power_series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">degree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; Series, Derived &gt;::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The degree of the series is the maximum degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the total degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00397">397</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a1f206670c33151c3b8c3d715d2dfd4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f206670c33151c3b8c3d715d2dfd4d6">&sect;&nbsp;</a></span>degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T  = power_series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pdegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; Series, Derived &gt;::degree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The partial degree of the series is the maximum partial degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation of the degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the partial degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00451">451</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a740700e20a5a450958c183d8eef33430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740700e20a5a450958c183d8eef33430">&sect;&nbsp;</a></span>ldegree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T  = power_series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; Series, Derived &gt;::ldegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The low degree of the series is the minimum low degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the total low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the low degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00423">423</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a86b89d255d38827c62014bd47b6cf2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b89d255d38827c62014bd47b6cf2cd">&sect;&nbsp;</a></span>ldegree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T  = power_series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; Series, Derived &gt;::ldegree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The partial low degree of the series is the minimum partial low degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation of the low degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the partial low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the low degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00481">481</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a16800c266c95fda4e519e6d4d4c95bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16800c266c95fda4e519e6d4d4c95bcf">&sect;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1power__series.html">power_series</a>&amp; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; Series, Derived &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1power__series.html">power_series</a>&lt; Series, Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the assignment operator of the base class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a751047710b3909bee179ab9d955a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a751047710b3909bee179ab9d955a16">&sect;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1power__series.html">power_series</a>&amp; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; Series, Derived &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1power__series.html">power_series</a>&lt; Series, Derived &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>. </dd></dl>

</div>
</div>
<a id="a105b7fa2770982a071e2452af0fd94f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105b7fa2770982a071e2452af0fd94f4">&sect;&nbsp;</a></span>truncate_degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T , truncate_degree_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; Series, Derived &gt;::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total degree truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>This method can be used to eliminate the parts of a series whose degree is greater than <code>max_degree</code>. This includes the elimination of whole terms, but also the recursive truncation of coefficients via the <a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a> function, if supported by the coefficient. It must be noted that, in general, this method is not guaranteed to eliminate all the parts whose degree is greater than <code>max_degree</code> (in particular, in the current implementation there is no truncation implemented for keys - a key is kept as-is or completely eliminated).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_degree</td><td>maximum allowed total degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a>, if used,</li>
<li>the constructor of the term type,</li>
<li>the computation and comparison of degree types,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00516">516</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="ac308a9c055ae2d5af5dac621268d3e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac308a9c055ae2d5af5dac621268d3e43">&sect;&nbsp;</a></span>truncate_degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Series, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T , truncate_pdegree_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; Series, Derived &gt;::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial degree truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>This method is equivalent to the other overload, the only difference being that the partial degree is considered in the computation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_degree</td><td>maximum allowed partial degree. </td></tr>
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation of the partial degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a>, if used,</li>
<li>the constructor of the term type,</li>
<li>the computation and comparison of degree types,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00549">549</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="power__series_8hpp_source.html">power_series.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
