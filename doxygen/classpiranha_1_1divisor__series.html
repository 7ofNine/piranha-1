<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>piranha: piranha::divisor_series&lt; Cf, Key &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepiranha.html">piranha</a></li><li class="navelem"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpiranha_1_1divisor__series-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">piranha::divisor_series&lt; Cf, Key &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Divisor series.  
 <a href="classpiranha_1_1divisor__series.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="divisor__series_8hpp_source.html">divisor_series.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for piranha::divisor_series&lt; Cf, Key &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpiranha_1_1divisor__series__inherit__graph.png" border="0" usemap="#piranha_1_1divisor__series_3_01_cf_00_01_key_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="piranha_1_1divisor__series_3_01_cf_00_01_key_01_4_inherit__map" id="piranha_1_1divisor__series_3_01_cf_00_01_key_01_4_inherit__map">
<area shape="rect" id="node2" href="classpiranha_1_1power__series.html" title="piranha::power_series\l\&lt; ipow_substitutable\l_series\&lt; substitutable\l_series\&lt; series\&lt; Cf, Key,\l divisor_series\&lt; Cf, Key\l \&gt; \&gt;, divisor_series\&lt; Cf,\l Key \&gt; \&gt;, divisor_series\&lt; Cf,\l Key \&gt; \&gt;, divisor_series\&lt; Cf, Key \&gt; \&gt;" alt="" coords="920,5,1163,155"/>
<area shape="rect" id="node4" href="classpiranha_1_1ipow__substitutable__series.html" title="piranha::ipow_substitutable\l_series\&lt; substitutable_series\l\&lt; series\&lt; Cf, Key, divisor_series\l\&lt; Cf, Key \&gt; \&gt;, divisor_series\&lt; Cf,\l Key \&gt; \&gt;, divisor_series\&lt; Cf, Key \&gt; \&gt;" alt="" coords="629,31,872,129"/>
<area shape="rect" id="node6" href="classpiranha_1_1substitutable__series.html" title="piranha::substitutable\l_series\&lt; series\&lt; Cf, Key,\l divisor_series\&lt; Cf, Key\l \&gt; \&gt;, divisor_series\&lt; Cf,\l Key \&gt; \&gt;" alt="" coords="409,31,580,129"/>
<area shape="rect" id="node8" href="classpiranha_1_1series.html" title="piranha::series\&lt; Cf,\l Key, divisor_series\l\&lt; Cf, Key \&gt; \&gt;" alt="" coords="223,48,359,112"/>
<area shape="rect" id="node10" href="classpiranha_1_1series__operators.html" title="Series operators. " alt="" coords="5,65,173,95"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for piranha::divisor_series&lt; Cf, Key &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpiranha_1_1divisor__series__coll__graph.png" border="0" usemap="#piranha_1_1divisor__series_3_01_cf_00_01_key_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="piranha_1_1divisor__series_3_01_cf_00_01_key_01_4_coll__map" id="piranha_1_1divisor__series_3_01_cf_00_01_key_01_4_coll__map">
<area shape="rect" id="node2" href="classpiranha_1_1power__series.html" title="piranha::power_series\l\&lt; ipow_substitutable\l_series\&lt; substitutable\l_series\&lt; series\&lt; Cf, Key,\l divisor_series\&lt; Cf, Key\l \&gt; \&gt;, divisor_series\&lt; Cf,\l Key \&gt; \&gt;, divisor_series\&lt; Cf,\l Key \&gt; \&gt;, divisor_series\&lt; Cf, Key \&gt; \&gt;" alt="" coords="1019,5,1261,155"/>
<area shape="rect" id="node4" href="classpiranha_1_1ipow__substitutable__series.html" title="piranha::ipow_substitutable\l_series\&lt; substitutable_series\l\&lt; series\&lt; Cf, Key, divisor_series\l\&lt; Cf, Key \&gt; \&gt;, divisor_series\&lt; Cf,\l Key \&gt; \&gt;, divisor_series\&lt; Cf, Key \&gt; \&gt;" alt="" coords="725,31,968,129"/>
<area shape="rect" id="node6" href="classpiranha_1_1substitutable__series.html" title="piranha::substitutable\l_series\&lt; series\&lt; Cf, Key,\l divisor_series\&lt; Cf, Key\l \&gt; \&gt;, divisor_series\&lt; Cf,\l Key \&gt; \&gt;" alt="" coords="503,31,673,129"/>
<area shape="rect" id="node8" href="classpiranha_1_1series.html" title="piranha::series\&lt; Cf,\l Key, divisor_series\l\&lt; Cf, Key \&gt; \&gt;" alt="" coords="313,48,449,112"/>
<area shape="rect" id="node10" href="classpiranha_1_1series__operators.html" title="Series operators. " alt="" coords="5,39,173,68"/>
<area shape="rect" id="node12" href="classpiranha_1_1symbol__set.html" title="Symbol set. " alt="" coords="20,92,159,121"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1d19a4edb6888bb5a0336a0772c5d540"><td class="memTemplParams" colspan="2"><a id="a1d19a4edb6888bb5a0336a0772c5d540"></a>
template&lt;typename Cf2 &gt; </td></tr>
<tr class="memitem:a1d19a4edb6888bb5a0336a0772c5d540"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1divisor__series.html#a1d19a4edb6888bb5a0336a0772c5d540">rebind</a> = <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf2, Key &gt;</td></tr>
<tr class="memdesc:a1d19a4edb6888bb5a0336a0772c5d540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series rebind alias. <br /></td></tr>
<tr class="separator:a1d19a4edb6888bb5a0336a0772c5d540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10de1584bd47b244c1b17dd9ce85ec3"><td class="memItemLeft" align="right" valign="top"><a id="ad10de1584bd47b244c1b17dd9ce85ec3"></a>
typedef <a class="el" href="classpiranha_1_1term.html">term</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3">term_type</a></td></tr>
<tr class="memdesc:ad10de1584bd47b244c1b17dd9ce85ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for term type. <br /></td></tr>
<tr class="separator:ad10de1584bd47b244c1b17dd9ce85ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06139c15c51191a979417513882cb02c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a> = typename <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">container_type::size_type</a></td></tr>
<tr class="memdesc:a06139c15c51191a979417513882cb02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type.  <a href="#a06139c15c51191a979417513882cb02c">More...</a><br /></td></tr>
<tr class="separator:a06139c15c51191a979417513882cb02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f4fc0e8a9566adbb560680df6d9084"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a> = const_iterator_impl</td></tr>
<tr class="memdesc:a35f4fc0e8a9566adbb560680df6d9084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator.  <a href="#a35f4fc0e8a9566adbb560680df6d9084">More...</a><br /></td></tr>
<tr class="separator:a35f4fc0e8a9566adbb560680df6d9084"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab4e1acf347194e267bcfcc4539e9b062"><td class="memItemLeft" align="right" valign="top"><a id="ab4e1acf347194e267bcfcc4539e9b062"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1divisor__series.html#ab4e1acf347194e267bcfcc4539e9b062">divisor_series</a> ()=default</td></tr>
<tr class="memdesc:ab4e1acf347194e267bcfcc4539e9b062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted default constructor. <br /></td></tr>
<tr class="separator:ab4e1acf347194e267bcfcc4539e9b062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5faa304ebb9d15a31598234ee3f4034"><td class="memItemLeft" align="right" valign="top"><a id="ac5faa304ebb9d15a31598234ee3f4034"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1divisor__series.html#ac5faa304ebb9d15a31598234ee3f4034">divisor_series</a> (const <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a> &amp;)=default</td></tr>
<tr class="memdesc:ac5faa304ebb9d15a31598234ee3f4034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor. <br /></td></tr>
<tr class="separator:ac5faa304ebb9d15a31598234ee3f4034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904c1fadfc678c9e86ac2885ef6b866f"><td class="memItemLeft" align="right" valign="top"><a id="a904c1fadfc678c9e86ac2885ef6b866f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1divisor__series.html#a904c1fadfc678c9e86ac2885ef6b866f">divisor_series</a> (<a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a904c1fadfc678c9e86ac2885ef6b866f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move constructor. <br /></td></tr>
<tr class="separator:a904c1fadfc678c9e86ac2885ef6b866f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc008197c32fd585461eb5f286f2bc7"><td class="memItemLeft" align="right" valign="top"><a id="accc008197c32fd585461eb5f286f2bc7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1divisor__series.html#accc008197c32fd585461eb5f286f2bc7">~divisor_series</a> ()</td></tr>
<tr class="memdesc:accc008197c32fd585461eb5f286f2bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial destructor. <br /></td></tr>
<tr class="separator:accc008197c32fd585461eb5f286f2bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab113013a3808e1e0b1825a6f8e7fc281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1divisor__series.html#ab113013a3808e1e0b1825a6f8e7fc281">operator=</a> (const <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a> &amp;other)=default</td></tr>
<tr class="memdesc:ab113013a3808e1e0b1825a6f8e7fc281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#ab113013a3808e1e0b1825a6f8e7fc281">More...</a><br /></td></tr>
<tr class="separator:ab113013a3808e1e0b1825a6f8e7fc281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd654ff66cf941752a5382f8cd7ffc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1divisor__series.html#aefd654ff66cf941752a5382f8cd7ffc6">operator=</a> (<a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:aefd654ff66cf941752a5382f8cd7ffc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#aefd654ff66cf941752a5382f8cd7ffc6">More...</a><br /></td></tr>
<tr class="separator:aefd654ff66cf941752a5382f8cd7ffc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3b601d6168df9c096653df1daceb13"><td class="memTemplParams" colspan="2">template&lt;typename T  = divisor_series&gt; </td></tr>
<tr class="memitem:a9d3b601d6168df9c096653df1daceb13"><td class="memTemplItemLeft" align="right" valign="top">inverse_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1divisor__series.html#a9d3b601d6168df9c096653df1daceb13">invert</a> () const</td></tr>
<tr class="memdesc:a9d3b601d6168df9c096653df1daceb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversion.  <a href="#a9d3b601d6168df9c096653df1daceb13">More...</a><br /></td></tr>
<tr class="separator:a9d3b601d6168df9c096653df1daceb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82e84bc65498e06e5f50e7aacd03d0f"><td class="memTemplParams" colspan="2">template&lt;typename T  = divisor_series&gt; </td></tr>
<tr class="memitem:ac82e84bc65498e06e5f50e7aacd03d0f"><td class="memTemplItemLeft" align="right" valign="top">partial_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1divisor__series.html#ac82e84bc65498e06e5f50e7aacd03d0f">partial</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ac82e84bc65498e06e5f50e7aacd03d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial derivative.  <a href="#ac82e84bc65498e06e5f50e7aacd03d0f">More...</a><br /></td></tr>
<tr class="separator:ac82e84bc65498e06e5f50e7aacd03d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e542e0b1bbe96574bc42b17187d1747"><td class="memTemplParams" colspan="2">template&lt;typename T  = divisor_series&gt; </td></tr>
<tr class="memitem:a8e542e0b1bbe96574bc42b17187d1747"><td class="memTemplItemLeft" align="right" valign="top">integrate_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1divisor__series.html#a8e542e0b1bbe96574bc42b17187d1747">integrate</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a8e542e0b1bbe96574bc42b17187d1747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integration.  <a href="#a8e542e0b1bbe96574bc42b17187d1747">More...</a><br /></td></tr>
<tr class="separator:a8e542e0b1bbe96574bc42b17187d1747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5735ddbc2dd58808c625cbe652888f8b"><td class="memItemLeft" align="right" valign="top">degree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a5735ddbc2dd58808c625cbe652888f8b">degree</a> () const</td></tr>
<tr class="memdesc:a5735ddbc2dd58808c625cbe652888f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total degree.  <a href="#a5735ddbc2dd58808c625cbe652888f8b">More...</a><br /></td></tr>
<tr class="separator:a5735ddbc2dd58808c625cbe652888f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f206670c33151c3b8c3d715d2dfd4d6"><td class="memItemLeft" align="right" valign="top">pdegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a1f206670c33151c3b8c3d715d2dfd4d6">degree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:a1f206670c33151c3b8c3d715d2dfd4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial degree.  <a href="#a1f206670c33151c3b8c3d715d2dfd4d6">More...</a><br /></td></tr>
<tr class="separator:a1f206670c33151c3b8c3d715d2dfd4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740700e20a5a450958c183d8eef33430"><td class="memItemLeft" align="right" valign="top">ldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a740700e20a5a450958c183d8eef33430">ldegree</a> () const</td></tr>
<tr class="memdesc:a740700e20a5a450958c183d8eef33430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total low degree.  <a href="#a740700e20a5a450958c183d8eef33430">More...</a><br /></td></tr>
<tr class="separator:a740700e20a5a450958c183d8eef33430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b89d255d38827c62014bd47b6cf2cd"><td class="memItemLeft" align="right" valign="top">pldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a86b89d255d38827c62014bd47b6cf2cd">ldegree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:a86b89d255d38827c62014bd47b6cf2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial low degree.  <a href="#a86b89d255d38827c62014bd47b6cf2cd">More...</a><br /></td></tr>
<tr class="separator:a86b89d255d38827c62014bd47b6cf2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105b7fa2770982a071e2452af0fd94f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a105b7fa2770982a071e2452af0fd94f4">truncate_degree</a> (const T &amp;max_degree) const</td></tr>
<tr class="memdesc:a105b7fa2770982a071e2452af0fd94f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total degree truncation.  <a href="#a105b7fa2770982a071e2452af0fd94f4">More...</a><br /></td></tr>
<tr class="separator:a105b7fa2770982a071e2452af0fd94f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac308a9c055ae2d5af5dac621268d3e43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#ac308a9c055ae2d5af5dac621268d3e43">truncate_degree</a> (const T &amp;max_degree, const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:ac308a9c055ae2d5af5dac621268d3e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial degree truncation.  <a href="#ac308a9c055ae2d5af5dac621268d3e43">More...</a><br /></td></tr>
<tr class="separator:ac308a9c055ae2d5af5dac621268d3e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1b859da8985051abeb1fa01a8dbbd8"><td class="memItemLeft" align="right" valign="top">ipow_subs_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a3b1b859da8985051abeb1fa01a8dbbd8">ipow_subs</a> (const std::string &amp;name, const <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b">integer</a> &amp;n, const T &amp;x) const</td></tr>
<tr class="memdesc:a3b1b859da8985051abeb1fa01a8dbbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#a3b1b859da8985051abeb1fa01a8dbbd8">More...</a><br /></td></tr>
<tr class="separator:a3b1b859da8985051abeb1fa01a8dbbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23d5585f793eeaa6c612eb0cfdcc357"><td class="memItemLeft" align="right" valign="top">ipow_subs_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1ipow__substitutable__series.html#ac23d5585f793eeaa6c612eb0cfdcc357">ipow_subs</a> (const std::string &amp;name, const Int &amp;n, const T &amp;x) const</td></tr>
<tr class="memdesc:ac23d5585f793eeaa6c612eb0cfdcc357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#ac23d5585f793eeaa6c612eb0cfdcc357">More...</a><br /></td></tr>
<tr class="separator:ac23d5585f793eeaa6c612eb0cfdcc357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83de874d3264155ff92521be46dc57f6"><td class="memItemLeft" align="right" valign="top">subs_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1substitutable__series.html#a83de874d3264155ff92521be46dc57f6">subs</a> (const std::string &amp;name, const T &amp;x) const</td></tr>
<tr class="memdesc:a83de874d3264155ff92521be46dc57f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#a83de874d3264155ff92521be46dc57f6">More...</a><br /></td></tr>
<tr class="separator:a83de874d3264155ff92521be46dc57f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3d2e7f83e5f80f5e7535ab3c74ae54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#afa3d2e7f83e5f80f5e7535ab3c74ae54">size</a> () const</td></tr>
<tr class="memdesc:afa3d2e7f83e5f80f5e7535ab3c74ae54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series size.  <a href="#afa3d2e7f83e5f80f5e7535ab3c74ae54">More...</a><br /></td></tr>
<tr class="separator:afa3d2e7f83e5f80f5e7535ab3c74ae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38eec0bf05c2275b7dfdbeb37f156dd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a38eec0bf05c2275b7dfdbeb37f156dd3">empty</a> () const</td></tr>
<tr class="memdesc:a38eec0bf05c2275b7dfdbeb37f156dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty test.  <a href="#a38eec0bf05c2275b7dfdbeb37f156dd3">More...</a><br /></td></tr>
<tr class="separator:a38eec0bf05c2275b7dfdbeb37f156dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a826064332b8a234c2343d6975d2240"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a0a826064332b8a234c2343d6975d2240">is_single_coefficient</a> () const</td></tr>
<tr class="memdesc:a0a826064332b8a234c2343d6975d2240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for single-coefficient series.  <a href="#a0a826064332b8a234c2343d6975d2240">More...</a><br /></td></tr>
<tr class="separator:a0a826064332b8a234c2343d6975d2240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac049565106ddee1881fedf6481de9458"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458">insert</a> (T &amp;&amp;<a class="el" href="classpiranha_1_1term.html">term</a>)</td></tr>
<tr class="memdesc:ac049565106ddee1881fedf6481de9458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert term.  <a href="#ac049565106ddee1881fedf6481de9458">More...</a><br /></td></tr>
<tr class="separator:ac049565106ddee1881fedf6481de9458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a2d1924707f1dbc3c82284e48bdaf87f1">insert</a> (T &amp;&amp;<a class="el" href="classpiranha_1_1term.html">term</a>)</td></tr>
<tr class="memdesc:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert generic term with <code>Sign = true</code>.  <a href="#a2d1924707f1dbc3c82284e48bdaf87f1">More...</a><br /></td></tr>
<tr class="separator:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70cf84d7727f2ac0a449dddfc48e76c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad70cf84d7727f2ac0a449dddfc48e76c">operator+</a> () const</td></tr>
<tr class="memdesc:ad70cf84d7727f2ac0a449dddfc48e76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity operator.  <a href="#ad70cf84d7727f2ac0a449dddfc48e76c">More...</a><br /></td></tr>
<tr class="separator:ad70cf84d7727f2ac0a449dddfc48e76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60edb0a90a58e4750209fa0bf849a161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a60edb0a90a58e4750209fa0bf849a161">operator-</a> () const</td></tr>
<tr class="memdesc:a60edb0a90a58e4750209fa0bf849a161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation operator.  <a href="#a60edb0a90a58e4750209fa0bf849a161">More...</a><br /></td></tr>
<tr class="separator:a60edb0a90a58e4750209fa0bf849a161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dce8005ee4919ce2f68b508e6292118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118">negate</a> ()</td></tr>
<tr class="memdesc:a3dce8005ee4919ce2f68b508e6292118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate series in-place.  <a href="#a3dce8005ee4919ce2f68b508e6292118">More...</a><br /></td></tr>
<tr class="separator:a3dce8005ee4919ce2f68b508e6292118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9f290579db86ff6c8da7ec926a6a4a"><td class="memItemLeft" align="right" valign="top">pow_ret_type&lt; T, U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aae9f290579db86ff6c8da7ec926a6a4a">pow</a> (const T &amp;x) const</td></tr>
<tr class="memdesc:aae9f290579db86ff6c8da7ec926a6a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponentiation.  <a href="#aae9f290579db86ff6c8da7ec926a6a4a">More...</a><br /></td></tr>
<tr class="separator:aae9f290579db86ff6c8da7ec926a6a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98b21393d8659e1257f79dbca5a759a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a">begin</a> () const</td></tr>
<tr class="memdesc:ad98b21393d8659e1257f79dbca5a759a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator.  <a href="#ad98b21393d8659e1257f79dbca5a759a">More...</a><br /></td></tr>
<tr class="separator:ad98b21393d8659e1257f79dbca5a759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9963bb8ab72b8f7b2ffbd38cf286eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a5c9963bb8ab72b8f7b2ffbd38cf286eb">end</a> () const</td></tr>
<tr class="memdesc:a5c9963bb8ab72b8f7b2ffbd38cf286eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator.  <a href="#a5c9963bb8ab72b8f7b2ffbd38cf286eb">More...</a><br /></td></tr>
<tr class="separator:a5c9963bb8ab72b8f7b2ffbd38cf286eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33216a696a195e177799649af9a6720c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a33216a696a195e177799649af9a6720c">filter</a> (std::function&lt; bool(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt; &amp;)&gt; func) const</td></tr>
<tr class="memdesc:a33216a696a195e177799649af9a6720c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Term filtering.  <a href="#a33216a696a195e177799649af9a6720c">More...</a><br /></td></tr>
<tr class="separator:a33216a696a195e177799649af9a6720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea750c31fed6a17346955d34f119aa74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aea750c31fed6a17346955d34f119aa74">transform</a> (std::function&lt; std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt; &amp;)&gt; func) const</td></tr>
<tr class="memdesc:aea750c31fed6a17346955d34f119aa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Term transformation.  <a href="#aea750c31fed6a17346955d34f119aa74">More...</a><br /></td></tr>
<tr class="separator:aea750c31fed6a17346955d34f119aa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c9ee4d3741bec3a93ec78bf0831f43"><td class="memItemLeft" align="right" valign="top">eval_type&lt; Series, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ae5c9ee4d3741bec3a93ec78bf0831f43">evaluate</a> (const std::unordered_map&lt; std::string, T &gt; &amp;dict) const</td></tr>
<tr class="memdesc:ae5c9ee4d3741bec3a93ec78bf0831f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation.  <a href="#ae5c9ee4d3741bec3a93ec78bf0831f43">More...</a><br /></td></tr>
<tr class="separator:ae5c9ee4d3741bec3a93ec78bf0831f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4d59b09e4496548b895a4c1212545d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#abc4d59b09e4496548b895a4c1212545d">trim</a> () const</td></tr>
<tr class="memdesc:abc4d59b09e4496548b895a4c1212545d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim.  <a href="#abc4d59b09e4496548b895a4c1212545d">More...</a><br /></td></tr>
<tr class="separator:abc4d59b09e4496548b895a4c1212545d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c22ff3703ce20884442a7cb3fbe0bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aa1c22ff3703ce20884442a7cb3fbe0bd">print_tex</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:aa1c22ff3703ce20884442a7cb3fbe0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print in TeX mode.  <a href="#aa1c22ff3703ce20884442a7cb3fbe0bd">More...</a><br /></td></tr>
<tr class="separator:aa1c22ff3703ce20884442a7cb3fbe0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5650572085cb49da6c36ab4f12af12f4"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a5650572085cb49da6c36ab4f12af12f4">hash</a> () const</td></tr>
<tr class="memdesc:a5650572085cb49da6c36ab4f12af12f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash value.  <a href="#a5650572085cb49da6c36ab4f12af12f4">More...</a><br /></td></tr>
<tr class="separator:a5650572085cb49da6c36ab4f12af12f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feab0d5ff5aa889f30caf9e1fb116ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3feab0d5ff5aa889f30caf9e1fb116ce">is_identical</a> (const <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &amp;other) const</td></tr>
<tr class="memdesc:a3feab0d5ff5aa889f30caf9e1fb116ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for identical series.  <a href="#a3feab0d5ff5aa889f30caf9e1fb116ce">More...</a><br /></td></tr>
<tr class="separator:a3feab0d5ff5aa889f30caf9e1fb116ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44128f48b629d89fcc0be3659affd0e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a44128f48b629d89fcc0be3659affd0e5">get_symbol_set</a> () const</td></tr>
<tr class="memdesc:a44128f48b629d89fcc0be3659affd0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set getter.  <a href="#a44128f48b629d89fcc0be3659affd0e5">More...</a><br /></td></tr>
<tr class="separator:a44128f48b629d89fcc0be3659affd0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ac3752460cc7a4c4cc0bea3330b31bcc9">set_symbol_set</a> (const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;args)</td></tr>
<tr class="memdesc:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set setter.  <a href="#ac3752460cc7a4c4cc0bea3330b31bcc9">More...</a><br /></td></tr>
<tr class="separator:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafc56eba07220821ab4b7f026105bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aaafc56eba07220821ab4b7f026105bd9">extend_symbol_set</a> (const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;new_ss) const</td></tr>
<tr class="memdesc:aaafc56eba07220821ab4b7f026105bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend symbol set.  <a href="#aaafc56eba07220821ab4b7f026105bd9">More...</a><br /></td></tr>
<tr class="separator:aaafc56eba07220821ab4b7f026105bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Table-querying methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods to query the properties of the internal container used to store the terms. </p>
</div></td></tr>
<tr class="memitem:a9fd2a6b0508e72ba3e3b0012a6eb4cce"><td class="memItemLeft" align="right" valign="top">sparsity_info_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a9fd2a6b0508e72ba3e3b0012a6eb4cce">table_sparsity</a> () const</td></tr>
<tr class="memdesc:a9fd2a6b0508e72ba3e3b0012a6eb4cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table sparsity.  <a href="#a9fd2a6b0508e72ba3e3b0012a6eb4cce">More...</a><br /></td></tr>
<tr class="separator:a9fd2a6b0508e72ba3e3b0012a6eb4cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cb3fb9005133515123a3c0a4d7a28f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a05cb3fb9005133515123a3c0a4d7a28f">table_load_factor</a> () const</td></tr>
<tr class="memdesc:a05cb3fb9005133515123a3c0a4d7a28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table load factor.  <a href="#a05cb3fb9005133515123a3c0a4d7a28f">More...</a><br /></td></tr>
<tr class="separator:a05cb3fb9005133515123a3c0a4d7a28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456359928f9f7134aaf23488d3e47928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a456359928f9f7134aaf23488d3e47928">table_bucket_count</a> () const</td></tr>
<tr class="memdesc:a456359928f9f7134aaf23488d3e47928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table bucket count.  <a href="#a456359928f9f7134aaf23488d3e47928">More...</a><br /></td></tr>
<tr class="separator:a456359928f9f7134aaf23488d3e47928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low-level interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Low-level methods. </p>
</div></td></tr>
<tr class="memitem:a2af49084d17c39794e0b6802bcc1b530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a671792175b69fe5b4b1574fc3f084962">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a2af49084d17c39794e0b6802bcc1b530">_container</a> ()</td></tr>
<tr class="memdesc:a2af49084d17c39794e0b6802bcc1b530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable reference to the container of terms.  <a href="#a2af49084d17c39794e0b6802bcc1b530">More...</a><br /></td></tr>
<tr class="separator:a2af49084d17c39794e0b6802bcc1b530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3d05e9347eecb91b17db09689e32a1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpiranha_1_1series.html#a671792175b69fe5b4b1574fc3f084962">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aef3d05e9347eecb91b17db09689e32a1">_container</a> () const</td></tr>
<tr class="memdesc:aef3d05e9347eecb91b17db09689e32a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the container of terms.  <a href="#aef3d05e9347eecb91b17db09689e32a1">More...</a><br /></td></tr>
<tr class="separator:aef3d05e9347eecb91b17db09689e32a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae7da3b838cc92a235785ae4e339a1e97"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ae7da3b838cc92a235785ae4e339a1e97">clear_pow_cache</a> ()</td></tr>
<tr class="memdesc:ae7da3b838cc92a235785ae4e339a1e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the internal cache of natural powers.  <a href="#ae7da3b838cc92a235785ae4e339a1e97">More...</a><br /></td></tr>
<tr class="separator:ae7da3b838cc92a235785ae4e339a1e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e">register_custom_derivative</a> (const std::string &amp;name, F func)</td></tr>
<tr class="memdesc:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register custom partial derivative.  <a href="#a5ee2cef7972c1ed1a410351c9f3e175e">More...</a><br /></td></tr>
<tr class="separator:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041b2099313fa16a9b13d55ce7c0d930"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a041b2099313fa16a9b13d55ce7c0d930">unregister_custom_derivative</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a041b2099313fa16a9b13d55ce7c0d930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister custom partial derivative.  <a href="#a041b2099313fa16a9b13d55ce7c0d930">More...</a><br /></td></tr>
<tr class="separator:a041b2099313fa16a9b13d55ce7c0d930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40680bb3e8f2801b3754f0b03abb0633"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a40680bb3e8f2801b3754f0b03abb0633">unregister_all_custom_derivatives</a> ()</td></tr>
<tr class="memdesc:a40680bb3e8f2801b3754f0b03abb0633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister all custom partial derivatives.  <a href="#a40680bb3e8f2801b3754f0b03abb0633">More...</a><br /></td></tr>
<tr class="separator:a40680bb3e8f2801b3754f0b03abb0633"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a671792175b69fe5b4b1574fc3f084962"><td class="memItemLeft" align="right" valign="top"><a id="a671792175b69fe5b4b1574fc3f084962"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a671792175b69fe5b4b1574fc3f084962">container_type</a> = <a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; <a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3">term_type</a>, detail::term_hasher&lt; <a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3">term_type</a> &gt;&gt;</td></tr>
<tr class="memdesc:a671792175b69fe5b4b1574fc3f084962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for terms. <br /></td></tr>
<tr class="separator:a671792175b69fe5b4b1574fc3f084962"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="memItemLeft" align="right" valign="top"><a id="a4c1d33d3d9ed04b935e3024db2e46f04"></a>
<a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a4c1d33d3d9ed04b935e3024db2e46f04">m_symbol_set</a></td></tr>
<tr class="memdesc:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set. <br /></td></tr>
<tr class="separator:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ac93f383a79c3325197d6a951e9dd5"><td class="memItemLeft" align="right" valign="top"><a id="a68ac93f383a79c3325197d6a951e9dd5"></a>
<a class="el" href="classpiranha_1_1series.html#a671792175b69fe5b4b1574fc3f084962">container_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a68ac93f383a79c3325197d6a951e9dd5">m_container</a></td></tr>
<tr class="memdesc:a68ac93f383a79c3325197d6a951e9dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terms container. <br /></td></tr>
<tr class="separator:a68ac93f383a79c3325197d6a951e9dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Cf, typename Key&gt;<br />
class piranha::divisor_series&lt; Cf, Key &gt;</h3>

<p>Divisor series. </p>
<p>This class represents series in which the keys are divisor (see <a class="el" href="classpiranha_1_1divisor.html" title="Divisor class. ">piranha::divisor</a>) and the coefficient type is generic. This class satisfies the <a class="el" href="classpiranha_1_1is__series.html" title="Type trait to detect series types. ">piranha::is_series</a> and <a class="el" href="classpiranha_1_1is__cf.html" title="Type trait to detect coefficient types. ">piranha::is_cf</a> type traits.</p>
<h2>Type requirements</h2>
<p><code>Cf</code> must be suitable for use in <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a> as first template argument, <code>Key</code> must be an instance of <a class="el" href="classpiranha_1_1divisor.html" title="Divisor class. ">piranha::divisor</a>.</p>
<h2>Exception safety guarantee</h2>
<p>This class provides the same guarantee as the base series type it derives from.</p>
<h2>Move semantics</h2>
<p>Move semantics is equivalent to the move semantics of the base series type it derives from. </p>

<p>Definition at line <a class="el" href="divisor__series__fwd_8hpp_source.html#l00044">44</a> of file <a class="el" href="divisor__series__fwd_8hpp_source.html">divisor_series_fwd.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a35f4fc0e8a9566adbb560680df6d9084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f4fc0e8a9566adbb560680df6d9084">&sect;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::<a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a> =  const_iterator_impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const iterator. </p>
<p>Iterator type that can be used to iterate over the terms of the series. The object returned upon dereferentiation is an <code>std::pair</code> in which the first element is a copy of the coefficient of the term, the second element a single-term instance of <code>Derived</code> constructed from the term's key and a unitary coefficient.</p>
<p>This iterator is an input iterator which additionally offers the multi-pass guarantee.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a> and <a class="el" href="classpiranha_1_1series.html#a5c9963bb8ab72b8f7b2ffbd38cf286eb" title="End iterator. ">piranha::series::end()</a>. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02012">2012</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a06139c15c51191a979417513882cb02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06139c15c51191a979417513882cb02c">&sect;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::<a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a> =  typename <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">container_type::size_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size type. </p>
<p>Used to represent the number of terms in the series. Equivalent to <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee" title="Size type. ">piranha::hash_set::size_type</a>. </p>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01999">1999</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2af49084d17c39794e0b6802bcc1b530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af49084d17c39794e0b6802bcc1b530">&sect;&nbsp;</a></span>_container() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a671792175b69fe5b4b1574fc3f084962">container_type</a>&amp; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a mutable reference to the container of terms. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the internal container of terms. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02897">2897</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aef3d05e9347eecb91b17db09689e32a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3d05e9347eecb91b17db09689e32a1">&sect;&nbsp;</a></span>_container() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpiranha_1_1series.html#a671792175b69fe5b4b1574fc3f084962">container_type</a>&amp; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to the container of terms. </p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the internal container of terms. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02905">2905</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ad98b21393d8659e1257f79dbca5a759a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98b21393d8659e1257f79dbca5a759a">&sect;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin iterator. </p>
<p>Return an iterator to the first term of the series. The returned iterator will provide, when dereferenced, an <code>std::pair</code> in which the first element is a copy of the coefficient of the term, whereas the second element is a single-term instance of <code>Derived</code> built from the term's key and a unitary coefficient.</p>
<p>Note that terms are stored unordered in the series, hence it is not defined which particular term will be returned by calling this method. The only guarantee is that the iterator can be used to transverse all the series' terms until <a class="el" href="classpiranha_1_1series.html#a5c9963bb8ab72b8f7b2ffbd38cf286eb" title="End iterator. ">piranha::series::end()</a> is eventually reached.</p>
<p>Calling any non-const method on the series will invalidate the iterators obtained via <a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a> and <a class="el" href="classpiranha_1_1series.html#a5c9963bb8ab72b8f7b2ffbd38cf286eb" title="End iterator. ">piranha::series::end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the first term of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>construction and assignment of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>construction of term, coefficient and key instances. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02522">2522</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ae7da3b838cc92a235785ae4e339a1e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7da3b838cc92a235785ae4e339a1e97">&sect;&nbsp;</a></span>clear_pow_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::clear_pow_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the internal cache of natural powers. </p>
<p>This method can be used to clear the cache of natural powers of series maintained by <a class="el" href="classpiranha_1_1series.html#aae9f290579db86ff6c8da7ec926a6a4a" title="Exponentiation. ">piranha::series::pow()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by threading primitives. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02389">2389</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a5735ddbc2dd58808c625cbe652888f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5735ddbc2dd58808c625cbe652888f8b">&sect;&nbsp;</a></span>degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">degree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt; , <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The degree of the series is the maximum degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the total degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00397">397</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a1f206670c33151c3b8c3d715d2dfd4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f206670c33151c3b8c3d715d2dfd4d6">&sect;&nbsp;</a></span>degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pdegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt; , <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::degree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The partial degree of the series is the maximum partial degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation of the degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the partial degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00451">451</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a38eec0bf05c2275b7dfdbeb37f156dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38eec0bf05c2275b7dfdbeb37f156dd3">&sect;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty test. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classpiranha_1_1series.html#afa3d2e7f83e5f80f5e7535ab3c74ae54" title="Series size. ">size()</a> is nonzero, <code>false</code> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02121">2121</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a5c9963bb8ab72b8f7b2ffbd38cf286eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9963bb8ab72b8f7b2ffbd38cf286eb">&sect;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a35f4fc0e8a9566adbb560680df6d9084">const_iterator</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End iterator. </p>
<p>Return an iterator one past the last term of the series. See the documentation of <a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a> on how the returned iterator can be used.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the end of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>construction and assignment of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>construction of term, coefficient and key instances. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02541">2541</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ae5c9ee4d3741bec3a93ec78bf0831f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c9ee4d3741bec3a93ec78bf0831f43">&sect;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">eval_type&lt;Series, T&gt; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; std::string, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dict</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if:<ul>
<li>both the coefficient and the key types are evaluable,</li>
<li>the evaluated types are suitable for use in <a class="el" href="namespacepiranha_1_1math.html#ad3b85fa643adb089c7980693221a566c" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>,</li>
<li>the return type is constructible from <code>int</code> and it satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</li>
</ul>
</dd></dl>
<p>Series evaluation starts with a zero-initialised instance of the return type, which is determined according to the evaluation types of coefficient and key. The return value accumulates the evaluation of all terms in the series via the product of the evaluations of the coefficient-key pairs in each term. The input dictionary <code>dict</code> specifies with which value each symbolic quantity will be evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>dictionary of that will be used for evaluation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>evaluation of the series according to the evaluation dictionary <code>dict</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>coefficient and key evaluation,</li>
<li>insertion operations on <code>std::unordered_map</code>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#ad3b85fa643adb089c7980693221a566c" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02641">2641</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aaafc56eba07220821ab4b7f026105bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafc56eba07220821ab4b7f026105bd9">&sect;&nbsp;</a></span>extend_symbol_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::extend_symbol_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;&#160;</td>
          <td class="paramname"><em>new_ss</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend symbol set. </p>
<p>This method will return a series whose symbol set will be <code>new_ss</code> and whose terms will be the terms of <code>this</code> with new keys obtained from calling the existing keys' <code>merge_args()</code> method. That is, the new keys will be compatible with the new extended symbol set <code>new_ss</code>.</p>
<p><code>new_ss</code> must have a size equal to or greater than the size of the current symbol set of <code>this</code>, and all the symbols in the current symbol set must be present in <code>new_ss</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_ss</td><td>the new set of symbols.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>this</code> with <code>new_ss</code> as symbol set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>new_ss</code> is smaller than the current symbol set or if it does not include all the symbols of the current symbol set. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of coefficients, terms and keys,</li>
<li>the key's <code>merge_args()</code> method,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02876">2876</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a33216a696a195e177799649af9a6720c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33216a696a195e177799649af9a6720c">&sect;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Term filtering. </p>
<p>This method will apply the functor <code>func</code> to each term in the series, and produce a return series containing all terms in <code>this</code> for which <code>func</code> returns <code>true</code>. Terms are passed to <code>func</code> in the format resulting from dereferencing the iterators obtained via <a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>filtering functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>filtered series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the call operator of <code>func</code>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term, coefficient, key construction. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02565">2565</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a44128f48b629d89fcc0be3659affd0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44128f48b629d89fcc0be3659affd0e5">&sect;&nbsp;</a></span>get_symbol_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a>&amp; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::get_symbol_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbol set getter. </p>
<dl class="section return"><dt>Returns</dt><dd>const reference to the <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a> associated to the series. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02837">2837</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a5650572085cb49da6c36ab4f12af12f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5650572085cb49da6c36ab4f12af12f4">&sect;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash value. </p>
<p>The hash value for a series is zero if the series is empty, otherwise it is computed by adding the hash values of all terms. This ensures that two identical series in which the terms are stored in different order still produce the same hash value.</p>
<p>Note, however, that the arguments of the series are not considered in the hash value and that, in general, two series that compare equal according to <a class="el" href="classpiranha_1_1series__operators.html#abd1db7fd12e8271bce100f8fbaf95d73" title="Equality operator involving piranha::series. ">operator==()</a> will <b>not</b> have the same hash value (as the equality operator merges the arguments of two series before actually performing the comparison). Instead of <a class="el" href="classpiranha_1_1series__operators.html#abd1db7fd12e8271bce100f8fbaf95d73" title="Equality operator involving piranha::series. ">operator==()</a>, <a class="el" href="classpiranha_1_1series.html#a3feab0d5ff5aa889f30caf9e1fb116ce" title="Check for identical series. ">is_identical()</a> should be used for storing series as keys in associative containers.</p>
<dl class="section return"><dt>Returns</dt><dd>a hash value for the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by computing the hash of a term. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02805">2805</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ac049565106ddee1881fedf6481de9458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac049565106ddee1881fedf6481de9458">&sect;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert term. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the decay type of <code>T</code> is <a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3" title="Alias for term type. ">piranha::series::term_type</a>.</dd></dl>
<p>This method will insert <code>term</code> into the series using internally <a class="el" href="classpiranha_1_1hash__set.html#a9025fd16a4fc8868c8b835c8614e1171" title="Insert element. ">piranha::hash_set::insert</a>.</p>
<p>The insertion algorithm proceeds as follows:</p><ul>
<li>if the term is not compatible for insertion, an <code>std::invalid_argument</code> exception is thrown;</li>
<li>if the term is ignorable, the method will return without performing any insertion;</li>
<li>if the term is already in the series, then:<ul>
<li>its coefficient is added (if <code>Sign</code> is <code>true</code>) or subtracted (if <code>Sign</code> is <code>false</code>) to the existing term's coefficient;</li>
<li>if, after the addition/subtraction the existing term is ignorable, it will be erased;</li>
</ul>
</li>
<li>else:<ul>
<li>the term is inserted into the term container and, if <code>Sign</code> is <code>false</code>, its coefficient is negated.</li>
</ul>
</li>
</ul>
<p>After any modification to an existing term in the series (e.g., via insertion with negative <code>Sign</code> or via in-place addition or subtraction of existing coefficients), the term will be checked again for compatibility and ignorability, and, in case the term has become incompatible or ignorable, it will be erased from the series.</p>
<p>The exception safety guarantee upon insertion is that the series will be left in an undefined but valid state. Such a guarantee relies on the fact that the addition/subtraction and negation methods of the coefficient type will leave the coefficient in a valid (possibly undefined) state in face of exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>term to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1hash__set.html#a9025fd16a4fc8868c8b835c8614e1171" title="Insert element. ">piranha::hash_set::insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a7f52223f8638f91f56943168353e758a" title="Find element. ">piranha::hash_set::find()</a>,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a42c0ef2f03b797b1f509044a6ec3b80d" title="Erase element. ">piranha::hash_set::erase()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a>, in-place addition/subtraction on coefficient types. </li>
</ul>
</td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>term</code> is incompatible. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02179">2179</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a2d1924707f1dbc3c82284e48bdaf87f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1924707f1dbc3c82284e48bdaf87f1">&sect;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert generic term with <code>Sign = true</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the decay type of <code>T</code> is <a class="el" href="classpiranha_1_1series.html#ad10de1584bd47b244c1b17dd9ce85ec3" title="Alias for term type. ">piranha::series::term_type</a>.</dd></dl>
<p>Convenience wrapper for the generic <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a> method, with <code>Sign</code> set to <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>term to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by generic <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02195">2195</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a8e542e0b1bbe96574bc42b17187d1747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e542e0b1bbe96574bc42b17187d1747">&sect;&nbsp;</a></span>integrate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf , typename Key &gt; </div>
<div class="memtemplate">
template&lt;typename T  = divisor_series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integrate_type&lt;T&gt; <a class="el" href="classpiranha_1_1divisor__series.html">piranha::divisor_series</a>&lt; Cf, Key &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integration. </p>
<dl class="section note"><dt>Note</dt><dd>This template method is enabled only if the coefficient type is integrable, and the result of the multiplication of an integrated coefficient by a <a class="el" href="classpiranha_1_1divisor__series.html" title="Divisor series. ">piranha::divisor_series</a> is addable in-place and constructible from <code>int</code>.</dd></dl>
<p>Integration for divisor series is supported only if the coefficient is integrable and no divisor in the calling series depends on the integration variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the variable with respect to which the integration will be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the antiderivative of <code>this</code> with respect to <code>name</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if at least one divisor depends on the integration variable. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>construction of and arithmetics on the return type,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1symbol.html" title="Literal symbol class. ">piranha::symbol</a> and <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac3752460cc7a4c4cc0bea3330b31bcc9" title="Symbol set setter. ">piranha::series::set_symbol_set()</a>, <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>,</li>
<li>construction of the coefficients, keys and terms. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="divisor__series_8hpp_source.html#l00525">525</a> of file <a class="el" href="divisor__series_8hpp_source.html">divisor_series.hpp</a>.</p>

</div>
</div>
<a id="a9d3b601d6168df9c096653df1daceb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3b601d6168df9c096653df1daceb13">&sect;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf , typename Key &gt; </div>
<div class="memtemplate">
template&lt;typename T  = divisor_series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inverse_type&lt;T&gt; <a class="el" href="classpiranha_1_1divisor__series.html">piranha::divisor_series</a>&lt; Cf, Key &gt;::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inversion. </p>
<dl class="section note"><dt>Note</dt><dd>This template method is enabled only if <a class="el" href="namespacepiranha_1_1math.html#ad1e5e54357d0937d3e42780f03e2e7df" title="Compute the inverse. ">math::invert()</a> can be called on the class from which <a class="el" href="classpiranha_1_1divisor__series.html" title="Divisor series. ">piranha::divisor_series</a> derives (i.e., only if the default <a class="el" href="namespacepiranha_1_1math.html#ad1e5e54357d0937d3e42780f03e2e7df" title="Compute the inverse. ">math::invert()</a> implementation for series is appropriate).</dd></dl>
<p>This method works exactly like the default implementation of <a class="el" href="namespacepiranha_1_1math.html#ad1e5e54357d0937d3e42780f03e2e7df" title="Compute the inverse. ">piranha::math::invert()</a> for series types, unless:</p>
<ul>
<li>a <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> appears in the coefficient hierarchy and</li>
<li>the calling series is not empty and</li>
<li>the calling series satisfies <a class="el" href="classpiranha_1_1series.html#a0a826064332b8a234c2343d6975d2240" title="Test for single-coefficient series. ">piranha::series::is_single_coefficient()</a> and</li>
<li>the return type is divisible by <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a>, yielding a type which can be used to construct the return type.</li>
</ul>
<p>Under these circumstances, this method will attempt to construct a divisor from the first polynomial coefficient encountered in the hierarchy, and, if successful, it will return a <a class="el" href="classpiranha_1_1divisor__series.html" title="Divisor series. ">piranha::divisor_series</a> consisting of a single term with unitary coefficient and with the key containing the divisor built from the polynomial.</p>
<p>For example, inverting the following divisor series with polynomial coefficient </p><p class="formulaDsp">
\[ 2x+4y \]
</p>
<p> will result in the construction of the divisor series </p><p class="formulaDsp">
\[ \frac{1}{2}\frac{1}{\left(x+2y\right)}. \]
</p>
<p>In order for the procedure described above to be successful, the polynomial coefficient must be equivalent to an integral linear combination of symbols with no constant term. If this special inversion fails, a call to the default implementation of <a class="el" href="namespacepiranha_1_1math.html#ad1e5e54357d0937d3e42780f03e2e7df" title="Compute the inverse. ">piranha::math::invert()</a> will be attempted.</p>
<dl class="section return"><dt>Returns</dt><dd>the inverse of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the default implementation of <a class="el" href="namespacepiranha_1_1math.html#ad1e5e54357d0937d3e42780f03e2e7df" title="Compute the inverse. ">piranha::math::invert()</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#a0a826064332b8a234c2343d6975d2240" title="Test for single-coefficient series. ">piranha::series::is_single_coefficient()</a>,</li>
<li>the extraction of an integral linear combination of symbols from <code>p</code>,</li>
<li>memory errors in standard containers,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a>, <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a>,</li>
<li>the construction of terms, coefficients and keys,</li>
<li><a class="el" href="classpiranha_1_1divisor.html#a47a871f636bf0838da1bcd7d8aa5dfac" title="Create and insert a term from range and exponent. ">piranha::divisor::insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>, <a class="el" href="classpiranha_1_1series.html#ac3752460cc7a4c4cc0bea3330b31bcc9" title="Symbol set setter. ">piranha::series::set_symbol_set()</a>,</li>
<li>arithmetics on <a class="el" href="classpiranha_1_1divisor__series.html" title="Divisor series. ">piranha::divisor_series</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="divisor__series_8hpp_source.html#l00458">458</a> of file <a class="el" href="divisor__series_8hpp_source.html">divisor_series.hpp</a>.</p>

</div>
</div>
<a id="a3b1b859da8985051abeb1fa01a8dbbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1b859da8985051abeb1fa01a8dbbd8">&sect;&nbsp;</a></span>ipow_subs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipow_subs_type&lt;T&gt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">piranha::ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt; , <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::ipow_subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b">integer</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient and/or key types support integral power substitution, and if the types involved in the substitution support the necessary arithmetic operations to compute the result.</dd></dl>
<p>This method will return an object resulting from the substitution of the integral power of the symbol called <code>name</code> in <code>this</code> with the generic object <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">n</td><td>integral power of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">x</td><td>object used for the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from:<ul>
<li>the substitution routines for the coefficients and/or keys,</li>
<li>the computation of the return value,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ipow__substitutable__series_8hpp_source.html#l00222">222</a> of file <a class="el" href="ipow__substitutable__series_8hpp_source.html">ipow_substitutable_series.hpp</a>.</p>

</div>
</div>
<a id="ac23d5585f793eeaa6c612eb0cfdcc357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23d5585f793eeaa6c612eb0cfdcc357">&sect;&nbsp;</a></span>ipow_subs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipow_subs_type&lt;T&gt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">piranha::ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt; , <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::ipow_subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the other <a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a3b1b859da8985051abeb1fa01a8dbbd8" title="Substitution. ">ipow_subs()</a> overload is enabled, and <code>Int</code> is a C++ integral type.</dd></dl>
<p>This is a convenience method that will call the other <a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a3b1b859da8985051abeb1fa01a8dbbd8" title="Substitution. ">ipow_subs()</a> overload after converting <code>n</code> to <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">n</td><td>integral power of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">x</td><td>object used for the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from calling the other <a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a3b1b859da8985051abeb1fa01a8dbbd8" title="Substitution. ">ipow_subs()</a> overload, or by constructing a <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a> from a C++ integral type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ipow__substitutable__series_8hpp_source.html#l00249">249</a> of file <a class="el" href="ipow__substitutable__series_8hpp_source.html">ipow_substitutable_series.hpp</a>.</p>

</div>
</div>
<a id="a3feab0d5ff5aa889f30caf9e1fb116ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3feab0d5ff5aa889f30caf9e1fb116ce">&sect;&nbsp;</a></span>is_identical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::is_identical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for identical series. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <code>Derived</code> is equality-comparable.</dd></dl>
<p>This method will return <code>true</code> if the symbol sets of <code>this</code> and <code>other</code> are the same, and <code>other == *this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>argument for the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>this</code> and <code>other</code> are identical, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the comparison operator of <code>Derived</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02829">2829</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a0a826064332b8a234c2343d6975d2240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a826064332b8a234c2343d6975d2240">&sect;&nbsp;</a></span>is_single_coefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::is_single_coefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for single-coefficient series. </p>
<p>A series is considered to be <em>single-coefficient</em> when it is symbolically equivalent to a coefficient. That is, the series is either empty (in which case it is considered to be equivalent to a coefficient constructed from zero) or consisting of a single term with unitary key (in which case the series is considered equivalent to its only coefficient).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> in case of single-coefficient series, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the <code>is_unitary()</code> method of the key type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02136">2136</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a740700e20a5a450958c183d8eef33430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740700e20a5a450958c183d8eef33430">&sect;&nbsp;</a></span>ldegree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt; , <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::ldegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The low degree of the series is the minimum low degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the total low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the low degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00423">423</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a86b89d255d38827c62014bd47b6cf2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b89d255d38827c62014bd47b6cf2cd">&sect;&nbsp;</a></span>ldegree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt; , <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::ldegree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The partial low degree of the series is the minimum partial low degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation of the low degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the partial low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the computation results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the low degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00481">481</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a3dce8005ee4919ce2f68b508e6292118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dce8005ee4919ce2f68b508e6292118">&sect;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negate series in-place. </p>
<p>This method will call <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">math::negate()</a> on the coefficients of all terms. In case of exceptions, the basic exception safety guarantee is provided.</p>
<p>If any term becomes ignorable or incompatible after negation, it will be erased from the series.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">math::negate()</a> on the coefficient type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02232">2232</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ad70cf84d7727f2ac0a449dddfc48e76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70cf84d7727f2ac0a449dddfc48e76c">&sect;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identity operator. </p>
<dl class="section return"><dt>Returns</dt><dd>copy of <code>this</code>, cast to <code>Derived</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02205">2205</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a60edb0a90a58e4750209fa0bf849a161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60edb0a90a58e4750209fa0bf849a161">&sect;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negation operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>this</code> on which <a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118" title="Negate series in-place. ">negate()</a> has been called.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118" title="Negate series in-place. ">negate()</a>,</li>
<li>the copy constructor of <code>Derived</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02217">2217</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ab113013a3808e1e0b1825a6f8e7fc281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab113013a3808e1e0b1825a6f8e7fc281">&sect;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf , typename Key &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&amp; <a class="el" href="classpiranha_1_1divisor__series.html">piranha::divisor_series</a>&lt; Cf, Key &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the assignment operator of the base class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefd654ff66cf941752a5382f8cd7ffc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd654ff66cf941752a5382f8cd7ffc6">&sect;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf , typename Key &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&amp; <a class="el" href="classpiranha_1_1divisor__series.html">piranha::divisor_series</a>&lt; Cf, Key &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>. </dd></dl>

</div>
</div>
<a id="ac82e84bc65498e06e5f50e7aacd03d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82e84bc65498e06e5f50e7aacd03d0f">&sect;&nbsp;</a></span>partial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf , typename Key &gt; </div>
<div class="memtemplate">
template&lt;typename T  = divisor_series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">partial_type&lt;T&gt; <a class="el" href="classpiranha_1_1divisor__series.html">piranha::divisor_series</a>&lt; Cf, Key &gt;::partial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the algorithm described below is supported by all the involved types.</dd></dl>
<p>This method will compute the partial derivative of <code>this</code> with respect to the symbol called <code>name</code>. The derivative is computed via differentiation of the coefficients and the application of the product rule.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the variable with respect to which the differentiation will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the partial derivative of <code>this</code> with respect to <code>name</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the manipulation of integral exponents and multipliers in the divisors results in an overflow. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of the return type,</li>
<li>the arithmetics operations needed to compute the result,</li>
<li>the public interface of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a>, <a class="el" href="namespacepiranha_1_1math.html#a47fae3623a188a7a711be3cce4f4da56" title="In-place negation. ">piranha::math::negate()</a>,</li>
<li>construction and insertion of series terms,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac3752460cc7a4c4cc0bea3330b31bcc9" title="Symbol set setter. ">piranha::series::set_symbol_set()</a>,</li>
<li><a class="el" href="classpiranha_1_1divisor.html#a09c5b0910a055673f4d8c81a4ca26b06" title="Split divisor. ">piranha::divisor::split()</a>,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a9025fd16a4fc8868c8b835c8614e1171" title="Insert element. ">piranha::hash_set::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="divisor__series_8hpp_source.html#l00489">489</a> of file <a class="el" href="divisor__series_8hpp_source.html">divisor_series.hpp</a>.</p>

</div>
</div>
<a id="aae9f290579db86ff6c8da7ec926a6a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9f290579db86ff6c8da7ec926a6a4a">&sect;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pow_ret_type&lt;T, U&gt; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exponentiation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the algorithm outlined here is supported by the involved types.</dd></dl>
<p>Return <code>this</code> raised to the <code>x</code>-th power. The type of the result is either the calling series type, or the calling series type rebound to the type resulting from the exponentiation of the coefficient of the calling type to the power of <code>x</code>. The exponentiation algorithm proceeds as follows:</p><ul>
<li>if the series is single-coefficient, the result is a single-coefficient series in which the coefficient is the original coefficient (or zero, if the calling series is empty) raised to the power of <code>x</code>;</li>
<li>if <code>x</code> is zero (as established by <a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a>), a series with a single term with unitary key and coefficient constructed from the integer numeral "1" is returned (i.e., any series raised to the power of zero is 1 - including empty series);</li>
<li>if <code>x</code> represents a non-negative integral value, the return value is constructed via repeated multiplications;</li>
<li>otherwise, an exception will be raised.</li>
</ul>
<p>An internal thread-safe cache of natural powers of series is maintained in order to improve performance during, e.g., substitution operations. This cache can be cleared with <a class="el" href="classpiranha_1_1series.html#ae7da3b838cc92a235785ae4e339a1e97" title="Clear the internal cache of natural powers. ">clear_pow_cache()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> raised to the power of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if exponentiation is computed via repeated series multiplications and <code>x</code> does not represent a non-negative integer. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>series, term, coefficient and key construction,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#a0a826064332b8a234c2343d6975d2240" title="Test for single-coefficient series. ">is_single_coefficient()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">piranha::math::pow()</a>, <a class="el" href="namespacepiranha_1_1math.html#a39d210d7fd0c312b5a280445548a853c" title="Zero test. ">piranha::math::is_zero()</a> and <a class="el" href="namespacepiranha.html#a4d35b0701002d5db09bbc4e54406117d" title="Safe cast. ">piranha::safe_cast()</a>,</li>
<li>series multiplication,</li>
<li>memory errors in standard containers,</li>
<li>threading primitives,</li>
<li><a class="el" href="classpiranha_1_1series.html#a5650572085cb49da6c36ab4f12af12f4" title="Hash value. ">hash()</a> or <a class="el" href="classpiranha_1_1series.html#a3feab0d5ff5aa889f30caf9e1fb116ce" title="Check for identical series. ">is_identical()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02322">2322</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aa1c22ff3703ce20884442a7cb3fbe0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c22ff3703ce20884442a7cb3fbe0bd">&sect;&nbsp;</a></span>print_tex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::print_tex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print in TeX mode. </p>
<p>Print series to stream <code>os</code> in TeX mode. The representation is constructed in the same way as explained in <a class="el" href="classpiranha_1_1series.html#a9f4b6250352b1657f36a0f90e021b6ce" title="Overloaded stream operator for piranha::series. ">piranha::series::operator&lt;&lt;()</a>, but using <a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735" title="Print series coefficient in TeX mode. ">piranha::print_tex_coefficient()</a> and the key's TeX printing method instead of the plain printing functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>target stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735" title="Print series coefficient in TeX mode. ">piranha::print_tex_coefficient()</a>,</li>
<li>the TeX printing method of the key type,</li>
<li>memory allocation errors in standard containers,</li>
<li><a class="el" href="classpiranha_1_1settings__.html#a511786ba228e56986e36b1d2b85c48f7" title="Get max term output. ">piranha::settings::get_max_term_output()</a>,</li>
<li>streaming to <code>os</code> or to instances of <code>std::ostringstream</code>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpiranha_1_1series.html#a9f4b6250352b1657f36a0f90e021b6ce" title="Overloaded stream operator for piranha::series. ">operator&lt;&lt;()</a>. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02729">2729</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a5ee2cef7972c1ed1a410351c9f3e175e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee2cef7972c1ed1a410351c9f3e175e">&sect;&nbsp;</a></span>register_custom_derivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::register_custom_derivative </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register custom partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#adb0fc5df866edb13f058cc2ebdc741d6" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>, and if <code>F</code> is a type that can be used to construct <code>std::function&lt;partial_type(const Derived &amp;)</code>, where <code>partial_type</code> is the type resulting from the partial derivative of <code>Derived</code>.</dd></dl>
<p>Register a copy of a callable <code>func</code> associated to the symbol called <code>name</code> for use by <a class="el" href="namespacepiranha_1_1math.html#a90685f4074f56de82b6e4683227243d6" title="Partial derivative. ">piranha::math::partial()</a>. <code>func</code> will be used to compute the partial derivative of instances of type <code>Derived</code> with respect to <code>name</code> in place of the default partial differentiation algorithm.</p>
<p>It is safe to call this method from multiple threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>symbol for which the custom partial derivative function will be registered. </td></tr>
    <tr><td class="paramname">func</td><td>custom partial derivative function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>failure(s) in threading primitives,</li>
<li>lookup and insertion operations on <code>std::unordered_map</code>,</li>
<li>construction and move-assignment of <code>std::function</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02450">2450</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="ac3752460cc7a4c4cc0bea3330b31bcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3752460cc7a4c4cc0bea3330b31bcc9">&sect;&nbsp;</a></span>set_symbol_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::set_symbol_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbol set setter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td><a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a> that will be associated to the series.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the series is not empty. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02848">2848</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="afa3d2e7f83e5f80f5e7535ab3c74ae54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3d2e7f83e5f80f5e7535ab3c74ae54">&sect;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Series size. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of terms in the series. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02113">2113</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a83de874d3264155ff92521be46dc57f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83de874d3264155ff92521be46dc57f6">&sect;&nbsp;</a></span>subs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subs_type&lt;T&gt; <a class="el" href="classpiranha_1_1substitutable__series.html">piranha::substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt; , <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient and/or key types support substitution, and if the types involved in the substitution support the necessary arithmetic operations to compute the result. Also, the return type must satisfy piranha::is_constructible.</dd></dl>
<p>This method will return an object resulting from the substitution of the symbol called <code>name</code> in <code>this</code> with the generic object <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the symbol to be substituted. </td></tr>
    <tr><td class="paramname">x</td><td>object used for the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from:<ul>
<li>the substitution routines for the coefficients and/or keys,</li>
<li>the computation of the return value,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="substitutable__series_8hpp_source.html#l00220">220</a> of file <a class="el" href="substitutable__series_8hpp_source.html">substitutable_series.hpp</a>.</p>

</div>
</div>
<a id="a456359928f9f7134aaf23488d3e47928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456359928f9f7134aaf23488d3e47928">&sect;&nbsp;</a></span>table_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a06139c15c51191a979417513882cb02c">size_type</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::table_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table bucket count. </p>
<dl class="section return"><dt>Returns</dt><dd>the bucket count of the internal container. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02281">2281</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a05cb3fb9005133515123a3c0a4d7a28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cb3fb9005133515123a3c0a4d7a28f">&sect;&nbsp;</a></span>table_load_factor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::table_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table load factor. </p>
<p>Will call <a class="el" href="classpiranha_1_1hash__set.html#a669a2807083e38a90b3a0fc0ef467e3f" title="Load factor. ">piranha::hash_set::load_factor()</a> on the internal terms container and return the result.</p>
<dl class="section return"><dt>Returns</dt><dd>the load factor of the internal container. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02273">2273</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a9fd2a6b0508e72ba3e3b0012a6eb4cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd2a6b0508e72ba3e3b0012a6eb4cce">&sect;&nbsp;</a></span>table_sparsity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparsity_info_type <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::table_sparsity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table sparsity. </p>
<p>Will call <a class="el" href="classpiranha_1_1hash__set.html#a525256d52ac552b9a81e9978654f1d36" title="Get information on the sparsity of the set. ">piranha::hash_set::evaluate_sparsity()</a> on the internal terms container and return the result.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classpiranha_1_1hash__set.html#a525256d52ac552b9a81e9978654f1d36" title="Get information on the sparsity of the set. ">piranha::hash_set::evaluate_sparsity()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1hash__set.html#a525256d52ac552b9a81e9978654f1d36" title="Get information on the sparsity of the set. ">piranha::hash_set::evaluate_sparsity()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02262">2262</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="aea750c31fed6a17346955d34f119aa74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea750c31fed6a17346955d34f119aa74">&sect;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Term transformation. </p>
<p>This method will apply the functor <code>func</code> to each term in the series, and will use the return value of the functor to construct a new series. Terms are passed to <code>func</code> in the same format resulting from dereferencing the iterators obtained via <a class="el" href="classpiranha_1_1series.html#ad98b21393d8659e1257f79dbca5a759a" title="Begin iterator. ">piranha::series::begin()</a>, and <code>func</code> is expected to produce a return value of the same type.</p>
<p>The return series is first initialised as an empty series. For each input term <code>t</code>, the return value of <code>func</code> is used to construct a new temporary series from the multiplication of <code>t.first</code> and <code>t.second</code>. Each temporary series is then added to the return value series.</p>
<p>This method requires the coefficient type to be multipliable by <code>Derived</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>transforming functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformed series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the call operator of <code>func</code>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term, coefficient, key construction,</li>
<li>series multiplication and addition. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02603">2603</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="abc4d59b09e4496548b895a4c1212545d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4d59b09e4496548b895a4c1212545d">&sect;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim. </p>
<p>This method will return a series mathematically equivalent to <code>this</code> in which discardable arguments have been removed from the internal set of symbols. Which symbols are removed depends on the trimming method <code>trim_identify()</code> of the key type (e.g., in a polynomial a symbol can be discarded if its exponent is zero in all monomials).</p>
<p>If the coefficient type is an instance of <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>, <a class="el" href="classpiranha_1_1series.html#abc4d59b09e4496548b895a4c1212545d" title="Trim. ">trim()</a> will be called recursively on the coefficients while building the return value.</p>
<dl class="section return"><dt>Returns</dt><dd>trimmed version of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>operations on <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>the trimming methods of coefficient and/or key,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>term, coefficient and key type construction. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02695">2695</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a105b7fa2770982a071e2452af0fd94f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105b7fa2770982a071e2452af0fd94f4">&sect;&nbsp;</a></span>truncate_degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt; , <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total degree truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>This method can be used to eliminate the parts of a series whose degree is greater than <code>max_degree</code>. This includes the elimination of whole terms, but also the recursive truncation of coefficients via the <a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a> function, if supported by the coefficient. It must be noted that, in general, this method is not guaranteed to eliminate all the parts whose degree is greater than <code>max_degree</code> (in particular, in the current implementation there is no truncation implemented for keys - a key is kept as-is or completely eliminated).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_degree</td><td>maximum allowed total degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a>, if used,</li>
<li>the constructor of the term type,</li>
<li>the computation and comparison of degree types,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00516">516</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="ac308a9c055ae2d5af5dac621268d3e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac308a9c055ae2d5af5dac621268d3e43">&sect;&nbsp;</a></span>truncate_degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt;, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt; &gt; , <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial degree truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>This method is equivalent to the other overload, the only difference being that the partial degree is considered in the computation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_degree</td><td>maximum allowed partial degree. </td></tr>
    <tr><td class="paramname">names</td><td>names of the variables to be considered in the computation of the partial degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a>, if used,</li>
<li>the constructor of the term type,</li>
<li>the computation and comparison of degree types,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00549">549</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a id="a40680bb3e8f2801b3754f0b03abb0633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40680bb3e8f2801b3754f0b03abb0633">&sect;&nbsp;</a></span>unregister_all_custom_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::unregister_all_custom_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister all custom partial derivatives. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#adb0fc5df866edb13f058cc2ebdc741d6" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>.</dd></dl>
<p>Will unregister all custom derivatives currently registered via <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">register_custom_derivative()</a>. It is safe to call this method from multiple threads.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by failure(s) in threading primitives. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02496">2496</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a id="a041b2099313fa16a9b13d55ce7c0d930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041b2099313fa16a9b13d55ce7c0d930">&sect;&nbsp;</a></span>unregister_custom_derivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, <a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a>&lt; Cf, Key &gt;  &gt;::unregister_custom_derivative </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister custom partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#adb0fc5df866edb13f058cc2ebdc741d6" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>.</dd></dl>
<p>Unregister the custom partial derivative function associated to the symbol called <code>name</code>. If no custom partial derivative was previously registered using <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">register_custom_derivative()</a>, calling this function will be a no-op.</p>
<p>It is safe to call this method from multiple threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>symbol for which the custom partial derivative function will be unregistered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>failure(s) in threading primitives,</li>
<li>lookup and erase operations on <code>std::unordered_map</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02477">2477</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="divisor__series__fwd_8hpp_source.html">divisor_series_fwd.hpp</a></li>
<li><a class="el" href="divisor__series_8hpp_source.html">divisor_series.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
